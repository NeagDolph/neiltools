var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  const m3 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m3) {
    return;
  }
  const match = m3[2] || m3[3] || "";
  let filename = match.slice(match.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m4, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body2, ct2) {
  if (!/multipart/i.test(ct2)) {
    throw new TypeError("Failed to fetch");
  }
  const m3 = ct2.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m3) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser = new MultipartParser(m3[1] || m3[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData();
  const onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file = new File(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder = new TextDecoder("utf-8");
  decoder.decode();
  parser.onPartBegin = function() {
    parser.onPartData = onPartData;
    parser.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderEnd = function() {
    headerValue += decoder.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m4 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m4) {
        entryName = m4[2] || m4[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser.onPartData = appendToFile;
        parser.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body2) {
    parser.write(chunk);
  }
  parser.end();
  return formData;
}
var s, S, f, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser;
var init_multipart_parser = __esm({
  "node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js"() {
    init_shims();
    init_polyfills();
    s = 0;
    S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    f = 1;
    F = {
      PART_BOUNDARY: f,
      LAST_BOUNDARY: f *= 2
    };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    lower = (c2) => c2 | 32;
    noop = () => {
    };
    MultipartParser = class {
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop;
        this.onHeaderField = noop;
        this.onHeadersEnd = noop;
        this.onHeaderValue = noop;
        this.onPartBegin = noop;
        this.onPartData = noop;
        this.onPartEnd = noop;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i3 = 0; i3 < boundary.length; i3++) {
          ui8a[i3] = boundary.charCodeAt(i3);
          this.boundaryChars[ui8a[i3]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      write(data) {
        let i3 = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index: index7, state, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c2;
        let cl;
        const mark = (name) => {
          this[name + "Mark"] = i3;
        };
        const clear = (name) => {
          delete this[name + "Mark"];
        };
        const callback = (callbackSymbol, start, end, ui8a) => {
          if (start === void 0 || start !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start, end));
          }
        };
        const dataCallback = (name, clear2) => {
          const markSymbol = name + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name, this[markSymbol], i3, data);
            delete this[markSymbol];
          } else {
            callback(name, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        };
        for (i3 = 0; i3 < length_; i3++) {
          c2 = data[i3];
          switch (state) {
            case S.START_BOUNDARY:
              if (index7 === boundary.length - 2) {
                if (c2 === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c2 !== CR) {
                  return;
                }
                index7++;
                break;
              } else if (index7 - 1 === boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c2 === HYPHEN) {
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c2 === LF) {
                  index7 = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c2 !== boundary[index7 + 2]) {
                index7 = -2;
              }
              if (c2 === boundary[index7 + 2]) {
                index7++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("onHeaderField");
              index7 = 0;
            case S.HEADER_FIELD:
              if (c2 === CR) {
                clear("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index7++;
              if (c2 === HYPHEN) {
                break;
              }
              if (c2 === COLON) {
                if (index7 === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c2);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c2 === SPACE) {
                break;
              }
              mark("onHeaderValue");
              state = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              if (c2 === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c2 !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c2 !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("onPartData");
            case S.PART_DATA:
              previousIndex = index7;
              if (index7 === 0) {
                i3 += boundaryEnd;
                while (i3 < bufferLength && !(data[i3] in boundaryChars)) {
                  i3 += boundaryLength;
                }
                i3 -= boundaryEnd;
                c2 = data[i3];
              }
              if (index7 < boundary.length) {
                if (boundary[index7] === c2) {
                  if (index7 === 0) {
                    dataCallback("onPartData", true);
                  }
                  index7++;
                } else {
                  index7 = 0;
                }
              } else if (index7 === boundary.length) {
                index7++;
                if (c2 === CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c2 === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index7 = 0;
                }
              } else if (index7 - 1 === boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index7 = 0;
                  if (c2 === LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c2 === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags = 0;
                  } else {
                    index7 = 0;
                  }
                } else {
                  index7 = 0;
                }
              }
              if (index7 > 0) {
                lookbehind[index7 - 1] = c2;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i3--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index7;
        this.state = state;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
  }
});

// node_modules/@sveltejs/kit/dist/node/polyfills.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base642 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i3 = 1; i3 < meta.length; i3++) {
    if (meta[i3] === "base64") {
      base642 = true;
    } else {
      typeFull += `;${meta[i3]}`;
      if (meta[i3].indexOf("charset=") === 0) {
        charset = meta[i3].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base642 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* toIterator(parts, clone2) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0, b2 = part;
      while (position !== b2.size) {
        const chunk = b2.slice(position, Math.min(b2.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
function formDataToBlob(F3, B2 = Blob$1) {
  var b2 = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c2 = [], p2 = `--${b2}\r
Content-Disposition: form-data; name="`;
  F3.forEach((v2, n2) => typeof v2 == "string" ? c2.push(p2 + e(n2) + `"\r
\r
${v2.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c2.push(p2 + e(n2) + `"; filename="${e(v2.name, 1)}"\r
Content-Type: ${v2.type || "application/octet-stream"}\r
\r
`, v2, "\r\n"));
  c2.push(`--${b2}--`);
  return new B2(c2, { type: "multipart/form-data; boundary=" + b2 });
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  const { body } = data;
  if (body === null) {
    return import_node_buffer.Buffer.alloc(0);
  }
  if (!(body instanceof import_node_stream.default)) {
    return import_node_buffer.Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error2 = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error2);
        throw error2;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error2) {
    const error_ = error2 instanceof FetchBaseError ? error2 : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error2.message}`, "system", error2);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c2) => typeof c2 === "string")) {
        return import_node_buffer.Buffer.from(accum.join(""));
      }
      return import_node_buffer.Buffer.concat(accum, accumBytes);
    } catch (error2) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error2.message}`, "system", error2);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers2(headers.reduce((result, value, index7, array2) => {
    if (index7 % 2 === 0) {
      result.push(array2.slice(index7, index7 + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = (0, import_node_net.isIP)(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (/^(.+\.)*localhost$/.test(url.host)) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}
async function fetch2(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request2(url, options_);
    const { parsedURL, options } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = dataUriToBuffer(request.url);
      const response2 = new Response2(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? import_node_https.default : import_node_http.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error2 = new AbortError("The operation was aborted.");
      reject(error2);
      if (request.body && request.body instanceof import_node_stream.default.Readable) {
        request.body.destroy(error2);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL.toString(), options);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error2) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error2.message}`, "system", error2));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error2) => {
      response.body.destroy(error2);
    });
    if (process.version < "v14") {
      request_.on("socket", (s4) => {
        let endedWithEventsCount;
        s4.prependListener("end", () => {
          endedWithEventsCount = s4._eventsCount;
        });
        s4.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s4._eventsCount && !hadError) {
            const error2 = new Error("Premature close");
            error2.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error2);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = location === null ? null : new URL(location, request.url);
        } catch {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers2(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (!isDomainOrSubdomain(request.url, locationURL)) {
              for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOptions.headers.delete(name);
              }
            }
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve2(fetch2(new Request2(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_node_stream.pipeline)(response_, new import_node_stream.PassThrough(), (error2) => {
        if (error2) {
          reject(error2);
        }
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_node_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_node_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_node_stream.pipeline)(body, import_node_zlib.default.createGunzip(zlibOptions), (error2) => {
          if (error2) {
            reject(error2);
          }
        });
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_node_stream.pipeline)(response_, new import_node_stream.PassThrough(), (error2) => {
          if (error2) {
            reject(error2);
          }
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = (0, import_node_stream.pipeline)(body, import_node_zlib.default.createInflate(), (error2) => {
              if (error2) {
                reject(error2);
              }
            });
          } else {
            body = (0, import_node_stream.pipeline)(body, import_node_zlib.default.createInflateRaw(), (error2) => {
              if (error2) {
                reject(error2);
              }
            });
          }
          response = new Response2(body, responseOptions);
          resolve2(response);
        });
        raw.once("end", () => {
          if (!response) {
            response = new Response2(body, responseOptions);
            resolve2(response);
          }
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_node_stream.pipeline)(body, import_node_zlib.default.createBrotliDecompress(), (error2) => {
          if (error2) {
            reject(error2);
          }
        });
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response2(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request).catch(reject);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = import_node_buffer.Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error2 = new Error("Premature close");
        error2.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error2);
      }
    };
    socket.prependListener("close", onSocketClose);
    request.on("abort", () => {
      socket.removeListener("close", onSocketClose);
    });
    socket.on("data", (buf) => {
      properLastChunkReceived = import_node_buffer.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = import_node_buffer.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && import_node_buffer.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    });
  });
}
function installPolyfills() {
  for (const name in globals) {
    Object.defineProperty(globalThis, name, {
      enumerable: true,
      configurable: true,
      value: globals[name]
    });
  }
}
var import_node_http, import_node_https, import_node_zlib, import_node_stream, import_node_buffer, import_node_util, import_node_url, import_node_net, import_crypto, commonjsGlobal, ponyfill_es2018, POOL_SIZE$1, POOL_SIZE, _Blob, Blob3, Blob$1, _File, File, t, i, h, r, m, f2, e, x, FormData, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, isDomainOrSubdomain, pipeline, INTERNALS$2, Body, clone, getNonSpecFormDataBoundary, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers2, redirectStatus, isRedirect, INTERNALS$1, Response2, getSearch, ReferrerPolicy, DEFAULT_REFERRER_POLICY, INTERNALS, isRequest, doBadDataWarn, Request2, getNodeRequestOptions, AbortError, supportedSchemas, globals;
var init_polyfills = __esm({
  "node_modules/@sveltejs/kit/dist/node/polyfills.js"() {
    init_shims();
    import_node_http = __toESM(require("node:http"), 1);
    import_node_https = __toESM(require("node:https"), 1);
    import_node_zlib = __toESM(require("node:zlib"), 1);
    import_node_stream = __toESM(require("node:stream"), 1);
    import_node_buffer = require("node:buffer");
    import_node_util = require("node:util");
    import_node_url = require("node:url");
    import_node_net = require("node:net");
    import_crypto = require("crypto");
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    ponyfill_es2018 = { exports: {} };
    (function(module2, exports) {
      (function(global2, factory) {
        factory(exports);
      })(commonjsGlobal, function(exports2) {
        const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
        function noop4() {
          return void 0;
        }
        function getGlobals() {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else if (typeof commonjsGlobal !== "undefined") {
            return commonjsGlobal;
          }
          return void 0;
        }
        const globals2 = getGlobals();
        function typeIsObject(x3) {
          return typeof x3 === "object" && x3 !== null || typeof x3 === "function";
        }
        const rethrowAssertionErrorRejection = noop4;
        const originalPromise = Promise;
        const originalPromiseThen = Promise.prototype.then;
        const originalPromiseResolve = Promise.resolve.bind(originalPromise);
        const originalPromiseReject = Promise.reject.bind(originalPromise);
        function newPromise(executor) {
          return new originalPromise(executor);
        }
        function promiseResolvedWith(value) {
          return originalPromiseResolve(value);
        }
        function promiseRejectedWith(reason) {
          return originalPromiseReject(reason);
        }
        function PerformPromiseThen(promise, onFulfilled, onRejected) {
          return originalPromiseThen.call(promise, onFulfilled, onRejected);
        }
        function uponPromise(promise, onFulfilled, onRejected) {
          PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
        }
        function uponFulfillment(promise, onFulfilled) {
          uponPromise(promise, onFulfilled);
        }
        function uponRejection(promise, onRejected) {
          uponPromise(promise, void 0, onRejected);
        }
        function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
          return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
        }
        function setPromiseIsHandledToTrue(promise) {
          PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
        }
        const queueMicrotask = (() => {
          const globalQueueMicrotask = globals2 && globals2.queueMicrotask;
          if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
          }
          const resolvedPromise = promiseResolvedWith(void 0);
          return (fn2) => PerformPromiseThen(resolvedPromise, fn2);
        })();
        function reflectCall(F3, V2, args) {
          if (typeof F3 !== "function") {
            throw new TypeError("Argument is not a function");
          }
          return Function.prototype.apply.call(F3, V2, args);
        }
        function promiseCall(F3, V2, args) {
          try {
            return promiseResolvedWith(reflectCall(F3, V2, args));
          } catch (value) {
            return promiseRejectedWith(value);
          }
        }
        const QUEUE_MAX_ARRAY_SIZE = 16384;
        class SimpleQueue {
          constructor() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          get length() {
            return this._size;
          }
          push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          }
          shift() {
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          }
          forEach(callback) {
            let i3 = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i3 !== elements.length || node._next !== void 0) {
              if (i3 === elements.length) {
                node = node._next;
                elements = node._elements;
                i3 = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i3]);
              ++i3;
            }
          }
          peek() {
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
          }
        }
        function ReadableStreamReaderGenericInitialize(reader, stream) {
          reader._ownerReadableStream = stream;
          stream._reader = reader;
          if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
          } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
          } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
          }
        }
        function ReadableStreamReaderGenericCancel(reader, reason) {
          const stream = reader._ownerReadableStream;
          return ReadableStreamCancel(stream, reason);
        }
        function ReadableStreamReaderGenericRelease(reader) {
          if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          }
          reader._ownerReadableStream._reader = void 0;
          reader._ownerReadableStream = void 0;
        }
        function readerLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released reader");
        }
        function defaultReaderClosedPromiseInitialize(reader) {
          reader._closedPromise = newPromise((resolve2, reject) => {
            reader._closedPromise_resolve = resolve2;
            reader._closedPromise_reject = reject;
          });
        }
        function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseReject(reader, reason);
        }
        function defaultReaderClosedPromiseInitializeAsResolved(reader) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseResolve(reader);
        }
        function defaultReaderClosedPromiseReject(reader, reason) {
          if (reader._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(reader._closedPromise);
          reader._closedPromise_reject(reason);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        function defaultReaderClosedPromiseResetToRejected(reader, reason) {
          defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
        }
        function defaultReaderClosedPromiseResolve(reader) {
          if (reader._closedPromise_resolve === void 0) {
            return;
          }
          reader._closedPromise_resolve(void 0);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
        const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
        const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
        const PullSteps = SymbolPolyfill("[[PullSteps]]");
        const NumberIsFinite = Number.isFinite || function(x3) {
          return typeof x3 === "number" && isFinite(x3);
        };
        const MathTrunc = Math.trunc || function(v2) {
          return v2 < 0 ? Math.ceil(v2) : Math.floor(v2);
        };
        function isDictionary(x3) {
          return typeof x3 === "object" || typeof x3 === "function";
        }
        function assertDictionary(obj, context) {
          if (obj !== void 0 && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertFunction(x3, context) {
          if (typeof x3 !== "function") {
            throw new TypeError(`${context} is not a function.`);
          }
        }
        function isObject(x3) {
          return typeof x3 === "object" && x3 !== null || typeof x3 === "function";
        }
        function assertObject(x3, context) {
          if (!isObject(x3)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertRequiredArgument(x3, position, context) {
          if (x3 === void 0) {
            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
          }
        }
        function assertRequiredField(x3, field, context) {
          if (x3 === void 0) {
            throw new TypeError(`${field} is required in '${context}'.`);
          }
        }
        function convertUnrestrictedDouble(value) {
          return Number(value);
        }
        function censorNegativeZero(x3) {
          return x3 === 0 ? 0 : x3;
        }
        function integerPart(x3) {
          return censorNegativeZero(MathTrunc(x3));
        }
        function convertUnsignedLongLongWithEnforceRange(value, context) {
          const lowerBound = 0;
          const upperBound = Number.MAX_SAFE_INTEGER;
          let x3 = Number(value);
          x3 = censorNegativeZero(x3);
          if (!NumberIsFinite(x3)) {
            throw new TypeError(`${context} is not a finite number`);
          }
          x3 = integerPart(x3);
          if (x3 < lowerBound || x3 > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
          }
          if (!NumberIsFinite(x3) || x3 === 0) {
            return 0;
          }
          return x3;
        }
        function assertReadableStream(x3, context) {
          if (!IsReadableStream(x3)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
          }
        }
        function AcquireReadableStreamDefaultReader(stream) {
          return new ReadableStreamDefaultReader(stream);
        }
        function ReadableStreamAddReadRequest(stream, readRequest) {
          stream._reader._readRequests.push(readRequest);
        }
        function ReadableStreamFulfillReadRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readRequest = reader._readRequests.shift();
          if (done) {
            readRequest._closeSteps();
          } else {
            readRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadRequests(stream) {
          return stream._reader._readRequests.length;
        }
        function ReadableStreamHasDefaultReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamDefaultReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamDefaultReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: () => resolvePromise({ value: void 0, done: true }),
              _errorSteps: (e3) => rejectPromise(e3)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamDefaultReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
          });
        }
        function IsReadableStreamDefaultReader(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_readRequests")) {
            return false;
          }
          return x3 instanceof ReadableStreamDefaultReader;
        }
        function ReadableStreamDefaultReaderRead(reader, readRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "closed") {
            readRequest._closeSteps();
          } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
          } else {
            stream._readableStreamController[PullSteps](readRequest);
          }
        }
        function defaultReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
        }
        const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
        }).prototype);
        class ReadableStreamAsyncIteratorImpl {
          constructor(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          }
          return(value) {
            const returnSteps = () => this._returnSteps(value);
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }
          _nextSteps() {
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("iterate"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => {
                this._ongoingPromise = void 0;
                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
              },
              _closeSteps: () => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: (reason) => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          }
          _returnSteps(value) {
            if (this._isFinished) {
              return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("finish iterating"));
            }
            if (!this._preventCancel) {
              const result = ReadableStreamReaderGenericCancel(reader, value);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, () => ({ value, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
          }
        }
        const ReadableStreamAsyncIteratorPrototype = {
          next() {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
          },
          return(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value);
          }
        };
        if (AsyncIteratorPrototype !== void 0) {
          Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
        }
        function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
          const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
          iterator._asyncIteratorImpl = impl;
          return iterator;
        }
        function IsReadableStreamAsyncIterator(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_asyncIteratorImpl")) {
            return false;
          }
          try {
            return x3._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
          } catch (_a) {
            return false;
          }
        }
        function streamAsyncIteratorBrandCheckException(name) {
          return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
        }
        const NumberIsNaN = Number.isNaN || function(x3) {
          return x3 !== x3;
        };
        function CreateArrayFromList(elements) {
          return elements.slice();
        }
        function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n2) {
          new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n2), destOffset);
        }
        function TransferArrayBuffer(O2) {
          return O2;
        }
        function IsDetachedBuffer(O2) {
          return false;
        }
        function ArrayBufferSlice(buffer, begin, end) {
          if (buffer.slice) {
            return buffer.slice(begin, end);
          }
          const length = end - begin;
          const slice = new ArrayBuffer(length);
          CopyDataBlockBytes(slice, 0, buffer, begin, length);
          return slice;
        }
        function IsNonNegativeNumber(v2) {
          if (typeof v2 !== "number") {
            return false;
          }
          if (NumberIsNaN(v2)) {
            return false;
          }
          if (v2 < 0) {
            return false;
          }
          return true;
        }
        function CloneAsUint8Array(O2) {
          const buffer = ArrayBufferSlice(O2.buffer, O2.byteOffset, O2.byteOffset + O2.byteLength);
          return new Uint8Array(buffer);
        }
        function DequeueValue(container) {
          const pair = container._queue.shift();
          container._queueTotalSize -= pair.size;
          if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
          }
          return pair.value;
        }
        function EnqueueValueWithSize(container, value, size) {
          if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          }
          container._queue.push({ value, size });
          container._queueTotalSize += size;
        }
        function PeekQueueValue(container) {
          const pair = container._queue.peek();
          return pair.value;
        }
        function ResetQueue(container) {
          container._queue = new SimpleQueue();
          container._queueTotalSize = 0;
        }
        class ReadableStreamBYOBRequest {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("view");
            }
            return this._view;
          }
          respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer))
              ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }
          respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }
        }
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
          respond: { enumerable: true },
          respondWithNewView: { enumerable: true },
          view: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
          });
        }
        class ReadableByteStreamController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("byobRequest");
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
          }
          get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("desiredSize");
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
          }
          enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          }
          error(e3 = void 0) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e3);
          }
          [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              const entry7 = this._queue.shift();
              this._queueTotalSize -= entry7.byteLength;
              ReadableByteStreamControllerHandleQueueDrain(this);
              const view = new Uint8Array(entry7.buffer, entry7.byteOffset, entry7.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              let buffer;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              const pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          }
        }
        Object.defineProperties(ReadableByteStreamController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          byobRequest: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
          });
        }
        function IsReadableByteStreamController(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_controlledReadableByteStream")) {
            return false;
          }
          return x3 instanceof ReadableByteStreamController;
        }
        function IsReadableStreamBYOBRequest(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_associatedReadableByteStreamController")) {
            return false;
          }
          return x3 instanceof ReadableStreamBYOBRequest;
        }
        function ReadableByteStreamControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }, (e3) => {
            ReadableByteStreamControllerError(controller, e3);
          });
        }
        function ReadableByteStreamControllerClearPendingPullIntos(controller) {
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          controller._pendingPullIntos = new SimpleQueue();
        }
        function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
          let done = false;
          if (stream._state === "closed") {
            done = true;
          }
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
          } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
          }
        }
        function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
          const bytesFilled = pullIntoDescriptor.bytesFilled;
          const elementSize = pullIntoDescriptor.elementSize;
          return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
        }
        function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
          controller._queue.push({ buffer, byteOffset, byteLength });
          controller._queueTotalSize += byteLength;
        }
        function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
          const elementSize = pullIntoDescriptor.elementSize;
          const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
          const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
          const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
          const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
          let totalBytesToCopyRemaining = maxBytesToCopy;
          let ready = false;
          if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
          }
          const queue = controller._queue;
          while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
              queue.shift();
            } else {
              headOfQueue.byteOffset += bytesToCopy;
              headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
          }
          return ready;
        }
        function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
          pullIntoDescriptor.bytesFilled += size;
        }
        function ReadableByteStreamControllerHandleQueueDrain(controller) {
          if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
          } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }
        function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
          if (controller._byobRequest === null) {
            return;
          }
          controller._byobRequest._associatedReadableByteStreamController = void 0;
          controller._byobRequest._view = null;
          controller._byobRequest = null;
        }
        function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
          while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
              return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
          const stream = controller._controlledReadableByteStream;
          let elementSize = 1;
          if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
          }
          const ctor = view.constructor;
          const buffer = TransferArrayBuffer(view.buffer);
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: "byob"
          };
          if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
          }
          if (stream._state === "closed") {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
          }
          if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
              ReadableByteStreamControllerHandleQueueDrain(controller);
              readIntoRequest._chunkSteps(filledView);
              return;
            }
            if (controller._closeRequested) {
              const e3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e3);
              readIntoRequest._errorSteps(e3);
              return;
            }
          }
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
          const stream = controller._controlledReadableByteStream;
          if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
          if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
          }
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize;
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
          } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerShiftPendingPullInto(controller) {
          const descriptor = controller._pendingPullIntos.shift();
          return descriptor;
        }
        function ReadableByteStreamControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return false;
          }
          if (controller._closeRequested) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableByteStreamControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
        }
        function ReadableByteStreamControllerClose(controller) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              const e3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e3);
              throw e3;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
        function ReadableByteStreamControllerEnqueue(controller, chunk) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          const buffer = chunk.buffer;
          const byteOffset = chunk.byteOffset;
          const byteLength = chunk.byteLength;
          const transferredBuffer = TransferArrayBuffer(buffer);
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer))
              ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
              if (controller._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
              }
              const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
          } else if (ReadableStreamHasBYOBReader(stream)) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerError(controller, e3) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return;
          }
          ReadableByteStreamControllerClearPendingPullIntos(controller);
          ResetQueue(controller);
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e3);
        }
        function ReadableByteStreamControllerGetBYOBRequest(controller) {
          if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
          }
          return controller._byobRequest;
        }
        function ReadableByteStreamControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableByteStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableByteStreamControllerRespond(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (bytesWritten !== 0) {
              throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
          } else {
            if (bytesWritten === 0) {
              throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
              throw new RangeError("bytesWritten out of range");
            }
          }
          firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
          ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
        }
        function ReadableByteStreamControllerRespondWithNewView(controller, view) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (view.byteLength !== 0) {
              throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
          } else {
            if (view.byteLength === 0) {
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
          }
          if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
          }
          if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          }
          if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
          }
          const viewByteLength = view.byteLength;
          firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
          ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
        }
        function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
          controller._controlledReadableByteStream = stream;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._byobRequest = null;
          controller._queue = controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._closeRequested = false;
          controller._started = false;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          controller._autoAllocateChunkSize = autoAllocateChunkSize;
          controller._pendingPullIntos = new SimpleQueue();
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }, (r3) => {
            ReadableByteStreamControllerError(controller, r3);
          });
        }
        function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
          const controller = Object.create(ReadableByteStreamController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingByteSource.start !== void 0) {
            startAlgorithm = () => underlyingByteSource.start(controller);
          }
          if (underlyingByteSource.pull !== void 0) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
          }
          if (underlyingByteSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
          }
          const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
          if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
          }
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
        }
        function SetUpReadableStreamBYOBRequest(request, controller, view) {
          request._associatedReadableByteStreamController = controller;
          request._view = view;
        }
        function byobRequestBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
        }
        function byteStreamControllerBrandCheckException(name) {
          return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
        }
        function AcquireReadableStreamBYOBReader(stream) {
          return new ReadableStreamBYOBReader(stream);
        }
        function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
          stream._reader._readIntoRequests.push(readIntoRequest);
        }
        function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readIntoRequest = reader._readIntoRequests.shift();
          if (done) {
            readIntoRequest._closeSteps(chunk);
          } else {
            readIntoRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadIntoRequests(stream) {
          return stream._reader._readIntoRequests.length;
        }
        function ReadableStreamHasBYOBReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamBYOBReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamBYOBReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read(view) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readIntoRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
              _errorSteps: (e3) => rejectPromise(e3)
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readIntoRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamBYOBReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
          });
        }
        function IsReadableStreamBYOBReader(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_readIntoRequests")) {
            return false;
          }
          return x3 instanceof ReadableStreamBYOBReader;
        }
        function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
          } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
          }
        }
        function byobReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
        }
        function ExtractHighWaterMark(strategy, defaultHWM) {
          const { highWaterMark } = strategy;
          if (highWaterMark === void 0) {
            return defaultHWM;
          }
          if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
          }
          return highWaterMark;
        }
        function ExtractSizeAlgorithm(strategy) {
          const { size } = strategy;
          if (!size) {
            return () => 1;
          }
          return size;
        }
        function convertQueuingStrategy(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          const size = init2 === null || init2 === void 0 ? void 0 : init2.size;
          return {
            highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
            size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
          };
        }
        function convertQueuingStrategySize(fn2, context) {
          assertFunction(fn2, context);
          return (chunk) => convertUnrestrictedDouble(fn2(chunk));
        }
        function convertUnderlyingSink(original, context) {
          assertDictionary(original, context);
          const abort = original === null || original === void 0 ? void 0 : original.abort;
          const close = original === null || original === void 0 ? void 0 : original.close;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          const write = original === null || original === void 0 ? void 0 : original.write;
          return {
            abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
            write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type
          };
        }
        function convertUnderlyingSinkAbortCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (reason) => promiseCall(fn2, original, [reason]);
        }
        function convertUnderlyingSinkCloseCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return () => promiseCall(fn2, original, []);
        }
        function convertUnderlyingSinkStartCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (controller) => reflectCall(fn2, original, [controller]);
        }
        function convertUnderlyingSinkWriteCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (chunk, controller) => promiseCall(fn2, original, [chunk, controller]);
        }
        function assertWritableStream(x3, context) {
          if (!IsWritableStream(x3)) {
            throw new TypeError(`${context} is not a WritableStream.`);
          }
        }
        function isAbortSignal2(value) {
          if (typeof value !== "object" || value === null) {
            return false;
          }
          try {
            return typeof value.aborted === "boolean";
          } catch (_a) {
            return false;
          }
        }
        const supportsAbortController = typeof AbortController === "function";
        function createAbortController() {
          if (supportsAbortController) {
            return new AbortController();
          }
          return void 0;
        }
        class WritableStream {
          constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            const type = underlyingSink.type;
            if (type !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          get locked() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("locked");
            }
            return IsWritableStreamLocked(this);
          }
          abort(reason = void 0) {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          }
          close() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          }
          getWriter() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          }
        }
        Object.defineProperties(WritableStream.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          getWriter: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
          });
        }
        function AcquireWritableStreamDefaultWriter(stream) {
          return new WritableStreamDefaultWriter(stream);
        }
        function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(WritableStream.prototype);
          InitializeWritableStream(stream);
          const controller = Object.create(WritableStreamDefaultController.prototype);
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function InitializeWritableStream(stream) {
          stream._state = "writable";
          stream._storedError = void 0;
          stream._writer = void 0;
          stream._writableStreamController = void 0;
          stream._writeRequests = new SimpleQueue();
          stream._inFlightWriteRequest = void 0;
          stream._closeRequest = void 0;
          stream._inFlightCloseRequest = void 0;
          stream._pendingAbortRequest = void 0;
          stream._backpressure = false;
        }
        function IsWritableStream(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_writableStreamController")) {
            return false;
          }
          return x3 instanceof WritableStream;
        }
        function IsWritableStreamLocked(stream) {
          if (stream._writer === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamAbort(stream, reason) {
          var _a;
          if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(void 0);
          }
          stream._writableStreamController._abortReason = reason;
          (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseResolvedWith(void 0);
          }
          if (stream._pendingAbortRequest !== void 0) {
            return stream._pendingAbortRequest._promise;
          }
          let wasAlreadyErroring = false;
          if (state === "erroring") {
            wasAlreadyErroring = true;
            reason = void 0;
          }
          const promise = newPromise((resolve2, reject) => {
            stream._pendingAbortRequest = {
              _promise: void 0,
              _resolve: resolve2,
              _reject: reject,
              _reason: reason,
              _wasAlreadyErroring: wasAlreadyErroring
            };
          });
          stream._pendingAbortRequest._promise = promise;
          if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
          }
          return promise;
        }
        function WritableStreamClose(stream) {
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
          }
          const promise = newPromise((resolve2, reject) => {
            const closeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._closeRequest = closeRequest;
          });
          const writer = stream._writer;
          if (writer !== void 0 && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
          }
          WritableStreamDefaultControllerClose(stream._writableStreamController);
          return promise;
        }
        function WritableStreamAddWriteRequest(stream) {
          const promise = newPromise((resolve2, reject) => {
            const writeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._writeRequests.push(writeRequest);
          });
          return promise;
        }
        function WritableStreamDealWithRejection(stream, error2) {
          const state = stream._state;
          if (state === "writable") {
            WritableStreamStartErroring(stream, error2);
            return;
          }
          WritableStreamFinishErroring(stream);
        }
        function WritableStreamStartErroring(stream, reason) {
          const controller = stream._writableStreamController;
          stream._state = "erroring";
          stream._storedError = reason;
          const writer = stream._writer;
          if (writer !== void 0) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
          }
          if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
          }
        }
        function WritableStreamFinishErroring(stream) {
          stream._state = "errored";
          stream._writableStreamController[ErrorSteps]();
          const storedError = stream._storedError;
          stream._writeRequests.forEach((writeRequest) => {
            writeRequest._reject(storedError);
          });
          stream._writeRequests = new SimpleQueue();
          if (stream._pendingAbortRequest === void 0) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const abortRequest = stream._pendingAbortRequest;
          stream._pendingAbortRequest = void 0;
          if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
          uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          });
        }
        function WritableStreamFinishInFlightWrite(stream) {
          stream._inFlightWriteRequest._resolve(void 0);
          stream._inFlightWriteRequest = void 0;
        }
        function WritableStreamFinishInFlightWriteWithError(stream, error2) {
          stream._inFlightWriteRequest._reject(error2);
          stream._inFlightWriteRequest = void 0;
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamFinishInFlightClose(stream) {
          stream._inFlightCloseRequest._resolve(void 0);
          stream._inFlightCloseRequest = void 0;
          const state = stream._state;
          if (state === "erroring") {
            stream._storedError = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._resolve();
              stream._pendingAbortRequest = void 0;
            }
          }
          stream._state = "closed";
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseResolve(writer);
          }
        }
        function WritableStreamFinishInFlightCloseWithError(stream, error2) {
          stream._inFlightCloseRequest._reject(error2);
          stream._inFlightCloseRequest = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._reject(error2);
            stream._pendingAbortRequest = void 0;
          }
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamCloseQueuedOrInFlight(stream) {
          if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamHasOperationMarkedInFlight(stream) {
          if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamMarkCloseRequestInFlight(stream) {
          stream._inFlightCloseRequest = stream._closeRequest;
          stream._closeRequest = void 0;
        }
        function WritableStreamMarkFirstWriteRequestInFlight(stream) {
          stream._inFlightWriteRequest = stream._writeRequests.shift();
        }
        function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
          if (stream._closeRequest !== void 0) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = void 0;
          }
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
          }
        }
        function WritableStreamUpdateBackpressure(stream, backpressure) {
          const writer = stream._writer;
          if (writer !== void 0 && backpressure !== stream._backpressure) {
            if (backpressure) {
              defaultWriterReadyPromiseReset(writer);
            } else {
              defaultWriterReadyPromiseResolve(writer);
            }
          }
          stream._backpressure = backpressure;
        }
        class WritableStreamDefaultWriter {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              const storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("desiredSize");
            }
            if (this._ownerWritableStream === void 0) {
              throw defaultWriterLockException("desiredSize");
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
          }
          get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            }
            return this._readyPromise;
          }
          abort(reason = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          }
          close() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          }
          releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          }
          write(chunk = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          }
        }
        Object.defineProperties(WritableStreamDefaultWriter.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          releaseLock: { enumerable: true },
          write: { enumerable: true },
          closed: { enumerable: true },
          desiredSize: { enumerable: true },
          ready: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
          });
        }
        function IsWritableStreamDefaultWriter(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_ownerWritableStream")) {
            return false;
          }
          return x3 instanceof WritableStreamDefaultWriter;
        }
        function WritableStreamDefaultWriterAbort(writer, reason) {
          const stream = writer._ownerWritableStream;
          return WritableStreamAbort(stream, reason);
        }
        function WritableStreamDefaultWriterClose(writer) {
          const stream = writer._ownerWritableStream;
          return WritableStreamClose(stream);
        }
        function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          return WritableStreamDefaultWriterClose(writer);
        }
        function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error2) {
          if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error2);
          } else {
            defaultWriterClosedPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error2) {
          if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error2);
          } else {
            defaultWriterReadyPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterGetDesiredSize(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (state === "errored" || state === "erroring") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
        }
        function WritableStreamDefaultWriterRelease(writer) {
          const stream = writer._ownerWritableStream;
          const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
          WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
          stream._writer = void 0;
          writer._ownerWritableStream = void 0;
        }
        function WritableStreamDefaultWriterWrite(writer, chunk) {
          const stream = writer._ownerWritableStream;
          const controller = stream._writableStreamController;
          const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
          if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          const state = stream._state;
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
          }
          if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
          }
          const promise = WritableStreamAddWriteRequest(stream);
          WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
          return promise;
        }
        const closeSentinel = {};
        class WritableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("abortReason");
            }
            return this._abortReason;
          }
          get signal() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("signal");
            }
            if (this._abortController === void 0) {
              throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            }
            return this._abortController.signal;
          }
          error(e3 = void 0) {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            const state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e3);
          }
          [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [ErrorSteps]() {
            ResetQueue(this);
          }
        }
        Object.defineProperties(WritableStreamDefaultController.prototype, {
          abortReason: { enumerable: true },
          signal: { enumerable: true },
          error: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
          });
        }
        function IsWritableStreamDefaultController(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_controlledWritableStream")) {
            return false;
          }
          return x3 instanceof WritableStreamDefaultController;
        }
        function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledWritableStream = stream;
          stream._writableStreamController = controller;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._abortReason = void 0;
          controller._abortController = createAbortController();
          controller._started = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._writeAlgorithm = writeAlgorithm;
          controller._closeAlgorithm = closeAlgorithm;
          controller._abortAlgorithm = abortAlgorithm;
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
          const startResult = startAlgorithm();
          const startPromise = promiseResolvedWith(startResult);
          uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (r3) => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r3);
          });
        }
        function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(WritableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let writeAlgorithm = () => promiseResolvedWith(void 0);
          let closeAlgorithm = () => promiseResolvedWith(void 0);
          let abortAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSink.start !== void 0) {
            startAlgorithm = () => underlyingSink.start(controller);
          }
          if (underlyingSink.write !== void 0) {
            writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
          }
          if (underlyingSink.close !== void 0) {
            closeAlgorithm = () => underlyingSink.close();
          }
          if (underlyingSink.abort !== void 0) {
            abortAlgorithm = (reason) => underlyingSink.abort(reason);
          }
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function WritableStreamDefaultControllerClearAlgorithms(controller) {
          controller._writeAlgorithm = void 0;
          controller._closeAlgorithm = void 0;
          controller._abortAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function WritableStreamDefaultControllerClose(controller) {
          EnqueueValueWithSize(controller, closeSentinel, 0);
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
          try {
            return controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
          }
        }
        function WritableStreamDefaultControllerGetDesiredSize(controller) {
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
          }
          const stream = controller._controlledWritableStream;
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
          const stream = controller._controlledWritableStream;
          if (!controller._started) {
            return;
          }
          if (stream._inFlightWriteRequest !== void 0) {
            return;
          }
          const state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length === 0) {
            return;
          }
          const value = PeekQueueValue(controller);
          if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
          } else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
        function WritableStreamDefaultControllerErrorIfNeeded(controller, error2) {
          if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error2);
          }
        }
        function WritableStreamDefaultControllerProcessClose(controller) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkCloseRequestInFlight(stream);
          DequeueValue(controller);
          const sinkClosePromise = controller._closeAlgorithm();
          WritableStreamDefaultControllerClearAlgorithms(controller);
          uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
          }, (reason) => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkFirstWriteRequestInFlight(stream);
          const sinkWritePromise = controller._writeAlgorithm(chunk);
          uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
              const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (reason) => {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerGetBackpressure(controller) {
          const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
          return desiredSize <= 0;
        }
        function WritableStreamDefaultControllerError(controller, error2) {
          const stream = controller._controlledWritableStream;
          WritableStreamDefaultControllerClearAlgorithms(controller);
          WritableStreamStartErroring(stream, error2);
        }
        function streamBrandCheckException$2(name) {
          return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
        }
        function defaultControllerBrandCheckException$2(name) {
          return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
        }
        function defaultWriterBrandCheckException(name) {
          return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
        }
        function defaultWriterLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released writer");
        }
        function defaultWriterClosedPromiseInitialize(writer) {
          writer._closedPromise = newPromise((resolve2, reject) => {
            writer._closedPromise_resolve = resolve2;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = "pending";
          });
        }
        function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseReject(writer, reason);
        }
        function defaultWriterClosedPromiseInitializeAsResolved(writer) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseResolve(writer);
        }
        function defaultWriterClosedPromiseReject(writer, reason) {
          if (writer._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._closedPromise);
          writer._closedPromise_reject(reason);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "rejected";
        }
        function defaultWriterClosedPromiseResetToRejected(writer, reason) {
          defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterClosedPromiseResolve(writer) {
          if (writer._closedPromise_resolve === void 0) {
            return;
          }
          writer._closedPromise_resolve(void 0);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "resolved";
        }
        function defaultWriterReadyPromiseInitialize(writer) {
          writer._readyPromise = newPromise((resolve2, reject) => {
            writer._readyPromise_resolve = resolve2;
            writer._readyPromise_reject = reject;
          });
          writer._readyPromiseState = "pending";
        }
        function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseReject(writer, reason);
        }
        function defaultWriterReadyPromiseInitializeAsResolved(writer) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseResolve(writer);
        }
        function defaultWriterReadyPromiseReject(writer, reason) {
          if (writer._readyPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._readyPromise);
          writer._readyPromise_reject(reason);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "rejected";
        }
        function defaultWriterReadyPromiseReset(writer) {
          defaultWriterReadyPromiseInitialize(writer);
        }
        function defaultWriterReadyPromiseResetToRejected(writer, reason) {
          defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterReadyPromiseResolve(writer) {
          if (writer._readyPromise_resolve === void 0) {
            return;
          }
          writer._readyPromise_resolve(void 0);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "fulfilled";
        }
        const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
        function isDOMExceptionConstructor(ctor) {
          if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
          }
          try {
            new ctor();
            return true;
          } catch (_a) {
            return false;
          }
        }
        function createDOMExceptionPolyfill() {
          const ctor = function DOMException2(message, name) {
            this.message = message || "";
            this.name = name || "Error";
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          };
          ctor.prototype = Object.create(Error.prototype);
          Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
          return ctor;
        }
        const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
        function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
          const reader = AcquireReadableStreamDefaultReader(source);
          const writer = AcquireWritableStreamDefaultWriter(dest);
          source._disturbed = true;
          let shuttingDown = false;
          let currentWrite = promiseResolvedWith(void 0);
          return newPromise((resolve2, reject) => {
            let abortAlgorithm;
            if (signal !== void 0) {
              abortAlgorithm = () => {
                const error2 = new DOMException$1("Aborted", "AbortError");
                const actions = [];
                if (!preventAbort) {
                  actions.push(() => {
                    if (dest._state === "writable") {
                      return WritableStreamAbort(dest, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                if (!preventCancel) {
                  actions.push(() => {
                    if (source._state === "readable") {
                      return ReadableStreamCancel(source, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error2);
              };
              if (signal.aborted) {
                abortAlgorithm();
                return;
              }
              signal.addEventListener("abort", abortAlgorithm);
            }
            function pipeLoop() {
              return newPromise((resolveLoop, rejectLoop) => {
                function next(done) {
                  if (done) {
                    resolveLoop();
                  } else {
                    PerformPromiseThen(pipeStep(), next, rejectLoop);
                  }
                }
                next(false);
              });
            }
            function pipeStep() {
              if (shuttingDown) {
                return promiseResolvedWith(true);
              }
              return PerformPromiseThen(writer._readyPromise, () => {
                return newPromise((resolveRead, rejectRead) => {
                  ReadableStreamDefaultReaderRead(reader, {
                    _chunkSteps: (chunk) => {
                      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop4);
                      resolveRead(false);
                    },
                    _closeSteps: () => resolveRead(true),
                    _errorSteps: rejectRead
                  });
                });
              });
            }
            isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
              if (!preventAbort) {
                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesClosed(source, reader._closedPromise, () => {
              if (!preventClose) {
                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
              } else {
                shutdown();
              }
            });
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
              const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
              } else {
                shutdown(true, destClosed);
              }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
              const oldCurrentWrite = currentWrite;
              return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
            }
            function isOrBecomesErrored(stream, promise, action) {
              if (stream._state === "errored") {
                action(stream._storedError);
              } else {
                uponRejection(promise, action);
              }
            }
            function isOrBecomesClosed(stream, promise, action) {
              if (stream._state === "closed") {
                action();
              } else {
                uponFulfillment(promise, action);
              }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), doTheRest);
              } else {
                doTheRest();
              }
              function doTheRest() {
                uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              }
            }
            function shutdown(isError, error2) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error2));
              } else {
                finalize(isError, error2);
              }
            }
            function finalize(isError, error2) {
              WritableStreamDefaultWriterRelease(writer);
              ReadableStreamReaderGenericRelease(reader);
              if (signal !== void 0) {
                signal.removeEventListener("abort", abortAlgorithm);
              }
              if (isError) {
                reject(error2);
              } else {
                resolve2(void 0);
              }
            }
          });
        }
        class ReadableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("desiredSize");
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          }
          enqueue(chunk = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }
          error(e3 = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e3);
          }
          [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              const chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          }
        }
        Object.defineProperties(ReadableStreamDefaultController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
          });
        }
        function IsReadableStreamDefaultController(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_controlledReadableStream")) {
            return false;
          }
          return x3 instanceof ReadableStreamDefaultController;
        }
        function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
          }, (e3) => {
            ReadableStreamDefaultControllerError(controller, e3);
          });
        }
        function ReadableStreamDefaultControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableStream;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableStreamDefaultControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function ReadableStreamDefaultControllerClose(controller) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          controller._closeRequested = true;
          if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
        }
        function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
          } else {
            let chunkSize;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              ReadableStreamDefaultControllerError(controller, chunkSizeE);
              throw chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              ReadableStreamDefaultControllerError(controller, enqueueE);
              throw enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        function ReadableStreamDefaultControllerError(controller, e3) {
          const stream = controller._controlledReadableStream;
          if (stream._state !== "readable") {
            return;
          }
          ResetQueue(controller);
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e3);
        }
        function ReadableStreamDefaultControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableStreamDefaultControllerHasBackpressure(controller) {
          if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
          }
          return true;
        }
        function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
          const state = controller._controlledReadableStream._state;
          if (!controller._closeRequested && state === "readable") {
            return true;
          }
          return false;
        }
        function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledReadableStream = stream;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._started = false;
          controller._closeRequested = false;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }, (r3) => {
            ReadableStreamDefaultControllerError(controller, r3);
          });
        }
        function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSource.start !== void 0) {
            startAlgorithm = () => underlyingSource.start(controller);
          }
          if (underlyingSource.pull !== void 0) {
            pullAlgorithm = () => underlyingSource.pull(controller);
          }
          if (underlyingSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
          }
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function defaultControllerBrandCheckException$1(name) {
          return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
        }
        function ReadableStreamTee(stream, cloneForBranch2) {
          if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
          }
          return ReadableStreamDefaultTee(stream);
        }
        function ReadableStreamDefaultTee(stream, cloneForBranch2) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgain = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function pullAlgorithm() {
            if (reading) {
              readAgain = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgain = false;
                  const chunk1 = chunk;
                  const chunk2 = chunk;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgain) {
                    pullAlgorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
          }
          branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
          branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
          uponRejection(reader._closedPromise, (r3) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r3);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r3);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
          return [branch1, branch2];
        }
        function ReadableByteStreamTee(stream) {
          let reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgainForBranch1 = false;
          let readAgainForBranch2 = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, (r3) => {
              if (thisReader !== reader) {
                return;
              }
              ReadableByteStreamControllerError(branch1._readableStreamController, r3);
              ReadableByteStreamControllerError(branch2._readableStreamController, r3);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
          }
          function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamDefaultReader(stream);
              forwardReaderError(reader);
            }
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const chunk1 = chunk;
                  let chunk2 = chunk;
                  if (!canceled1 && !canceled2) {
                    try {
                      chunk2 = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                  }
                  if (!canceled1) {
                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableByteStreamControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerClose(branch2._readableStreamController);
                }
                if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                }
                if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
          }
          function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamBYOBReader(stream);
              forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const byobCanceled = forBranch2 ? canceled2 : canceled1;
                  const otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!otherCanceled) {
                    let clonedChunk;
                    try {
                      clonedChunk = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                  } else if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: (chunk) => {
                reading = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!byobCanceled) {
                  ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                }
                if (!otherCanceled) {
                  ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                }
                if (chunk !== void 0) {
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                  }
                }
                if (!byobCanceled || !otherCanceled) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
          }
          function pull1Algorithm() {
            if (reading) {
              readAgainForBranch1 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(void 0);
          }
          function pull2Algorithm() {
            if (reading) {
              readAgainForBranch2 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
            return;
          }
          branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
          branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
          forwardReaderError(reader);
          return [branch1, branch2];
        }
        function convertUnderlyingDefaultOrByteSource(source, context) {
          assertDictionary(source, context);
          const original = source;
          const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
          const cancel = original === null || original === void 0 ? void 0 : original.cancel;
          const pull = original === null || original === void 0 ? void 0 : original.pull;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          return {
            autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
            type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
          };
        }
        function convertUnderlyingSourceCancelCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (reason) => promiseCall(fn2, original, [reason]);
        }
        function convertUnderlyingSourcePullCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (controller) => promiseCall(fn2, original, [controller]);
        }
        function convertUnderlyingSourceStartCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (controller) => reflectCall(fn2, original, [controller]);
        }
        function convertReadableStreamType(type, context) {
          type = `${type}`;
          if (type !== "bytes") {
            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
          }
          return type;
        }
        function convertReaderOptions(options, context) {
          assertDictionary(options, context);
          const mode = options === null || options === void 0 ? void 0 : options.mode;
          return {
            mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
          };
        }
        function convertReadableStreamReaderMode(mode, context) {
          mode = `${mode}`;
          if (mode !== "byob") {
            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
          }
          return mode;
        }
        function convertIteratorOptions(options, context) {
          assertDictionary(options, context);
          const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
          return { preventCancel: Boolean(preventCancel) };
        }
        function convertPipeOptions(options, context) {
          assertDictionary(options, context);
          const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
          const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
          const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
          const signal = options === null || options === void 0 ? void 0 : options.signal;
          if (signal !== void 0) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
          }
          return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
          };
        }
        function assertAbortSignal(signal, context) {
          if (!isAbortSignal2(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
          }
        }
        function convertReadableWritablePair(pair, context) {
          assertDictionary(pair, context);
          const readable3 = pair === null || pair === void 0 ? void 0 : pair.readable;
          assertRequiredField(readable3, "readable", "ReadableWritablePair");
          assertReadableStream(readable3, `${context} has member 'readable' that`);
          const writable3 = pair === null || pair === void 0 ? void 0 : pair.writable;
          assertRequiredField(writable3, "writable", "ReadableWritablePair");
          assertWritableStream(writable3, `${context} has member 'writable' that`);
          return { readable: readable3, writable: writable3 };
        }
        class ReadableStream2 {
          constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              const highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              const highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          get locked() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("locked");
            }
            return IsReadableStreamLocked(this);
          }
          cancel(reason = void 0) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          }
          getReader(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            const options = convertReaderOptions(rawOptions, "First parameter");
            if (options.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          }
          pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            const transform = convertReadableWritablePair(rawTransform, "First parameter");
            const options = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
          }
          pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options;
            try {
              options = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e3) {
              return promiseRejectedWith(e3);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          }
          tee() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }
          values(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            const options = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
          }
        }
        Object.defineProperties(ReadableStream2.prototype, {
          cancel: { enumerable: true },
          getReader: { enumerable: true },
          pipeThrough: { enumerable: true },
          pipeTo: { enumerable: true },
          tee: { enumerable: true },
          values: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
          });
        }
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream2.prototype.values,
            writable: true,
            configurable: true
          });
        }
        function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableByteStreamController.prototype);
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
          return stream;
        }
        function InitializeReadableStream(stream) {
          stream._state = "readable";
          stream._reader = void 0;
          stream._storedError = void 0;
          stream._disturbed = false;
        }
        function IsReadableStream(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_readableStreamController")) {
            return false;
          }
          return x3 instanceof ReadableStream2;
        }
        function IsReadableStreamLocked(stream) {
          if (stream._reader === void 0) {
            return false;
          }
          return true;
        }
        function ReadableStreamCancel(stream, reason) {
          stream._disturbed = true;
          if (stream._state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          ReadableStreamClose(stream);
          const reader = stream._reader;
          if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._closeSteps(void 0);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
          const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
          return transformPromiseWith(sourceCancelPromise, noop4);
        }
        function ReadableStreamClose(stream) {
          stream._state = "closed";
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseResolve(reader);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
          }
        }
        function ReadableStreamError(stream, e3) {
          stream._state = "errored";
          stream._storedError = e3;
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseReject(reader, e3);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._errorSteps(e3);
            });
            reader._readRequests = new SimpleQueue();
          } else {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._errorSteps(e3);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
        }
        function streamBrandCheckException$1(name) {
          return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
        }
        function convertQueuingStrategyInit(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
          return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
          };
        }
        const byteLengthSizeFunction = (chunk) => {
          return chunk.byteLength;
        };
        try {
          Object.defineProperty(byteLengthSizeFunction, "name", {
            value: "size",
            configurable: true
          });
        } catch (_a) {
        }
        class ByteLengthQueuingStrategy {
          constructor(options) {
            assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("highWaterMark");
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("size");
            }
            return byteLengthSizeFunction;
          }
        }
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
          });
        }
        function byteLengthBrandCheckException(name) {
          return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
        }
        function IsByteLengthQueuingStrategy(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x3 instanceof ByteLengthQueuingStrategy;
        }
        const countSizeFunction = () => {
          return 1;
        };
        try {
          Object.defineProperty(countSizeFunction, "name", {
            value: "size",
            configurable: true
          });
        } catch (_a) {
        }
        class CountQueuingStrategy {
          constructor(options) {
            assertRequiredArgument(options, 1, "CountQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._countQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("highWaterMark");
            }
            return this._countQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("size");
            }
            return countSizeFunction;
          }
        }
        Object.defineProperties(CountQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
          });
        }
        function countBrandCheckException(name) {
          return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
        }
        function IsCountQueuingStrategy(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_countQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x3 instanceof CountQueuingStrategy;
        }
        function convertTransformer(original, context) {
          assertDictionary(original, context);
          const flush2 = original === null || original === void 0 ? void 0 : original.flush;
          const readableType = original === null || original === void 0 ? void 0 : original.readableType;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const transform = original === null || original === void 0 ? void 0 : original.transform;
          const writableType = original === null || original === void 0 ? void 0 : original.writableType;
          return {
            flush: flush2 === void 0 ? void 0 : convertTransformerFlushCallback(flush2, original, `${context} has member 'flush' that`),
            readableType,
            start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
            transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
            writableType
          };
        }
        function convertTransformerFlushCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (controller) => promiseCall(fn2, original, [controller]);
        }
        function convertTransformerStartCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (controller) => reflectCall(fn2, original, [controller]);
        }
        function convertTransformerTransformCallback(fn2, original, context) {
          assertFunction(fn2, context);
          return (chunk, controller) => promiseCall(fn2, original, [chunk, controller]);
        }
        class TransformStream {
          constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            const transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise((resolve2) => {
              startPromise_resolve = resolve2;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== void 0) {
              startPromise_resolve(transformer.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          get readable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("readable");
            }
            return this._readable;
          }
          get writable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("writable");
            }
            return this._writable;
          }
        }
        Object.defineProperties(TransformStream.prototype, {
          readable: { enumerable: true },
          writable: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
          });
        }
        function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
          function startAlgorithm() {
            return startPromise;
          }
          function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
          }
          function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
          }
          function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
          }
          stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
          function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
          }
          function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(void 0);
          }
          stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          stream._backpressure = void 0;
          stream._backpressureChangePromise = void 0;
          stream._backpressureChangePromise_resolve = void 0;
          TransformStreamSetBackpressure(stream, true);
          stream._transformStreamController = void 0;
        }
        function IsTransformStream(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_transformStreamController")) {
            return false;
          }
          return x3 instanceof TransformStream;
        }
        function TransformStreamError(stream, e3) {
          ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e3);
          TransformStreamErrorWritableAndUnblockWrite(stream, e3);
        }
        function TransformStreamErrorWritableAndUnblockWrite(stream, e3) {
          TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
          WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e3);
          if (stream._backpressure) {
            TransformStreamSetBackpressure(stream, false);
          }
        }
        function TransformStreamSetBackpressure(stream, backpressure) {
          if (stream._backpressureChangePromise !== void 0) {
            stream._backpressureChangePromise_resolve();
          }
          stream._backpressureChangePromise = newPromise((resolve2) => {
            stream._backpressureChangePromise_resolve = resolve2;
          });
          stream._backpressure = backpressure;
        }
        class TransformStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("desiredSize");
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
          }
          enqueue(chunk = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }
          error(reason = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          }
          terminate() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          }
        }
        Object.defineProperties(TransformStreamDefaultController.prototype, {
          enqueue: { enumerable: true },
          error: { enumerable: true },
          terminate: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
          });
        }
        function IsTransformStreamDefaultController(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_controlledTransformStream")) {
            return false;
          }
          return x3 instanceof TransformStreamDefaultController;
        }
        function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
          controller._controlledTransformStream = stream;
          stream._transformStreamController = controller;
          controller._transformAlgorithm = transformAlgorithm;
          controller._flushAlgorithm = flushAlgorithm;
        }
        function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
          const controller = Object.create(TransformStreamDefaultController.prototype);
          let transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
          let flushAlgorithm = () => promiseResolvedWith(void 0);
          if (transformer.transform !== void 0) {
            transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
          }
          if (transformer.flush !== void 0) {
            flushAlgorithm = () => transformer.flush(controller);
          }
          SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
        }
        function TransformStreamDefaultControllerClearAlgorithms(controller) {
          controller._transformAlgorithm = void 0;
          controller._flushAlgorithm = void 0;
        }
        function TransformStreamDefaultControllerEnqueue(controller, chunk) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
          }
          try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
          } catch (e3) {
            TransformStreamErrorWritableAndUnblockWrite(stream, e3);
            throw stream._readable._storedError;
          }
          const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
          if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
          }
        }
        function TransformStreamDefaultControllerError(controller, e3) {
          TransformStreamError(controller._controlledTransformStream, e3);
        }
        function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
          const transformPromise = controller._transformAlgorithm(chunk);
          return transformPromiseWith(transformPromise, void 0, (r3) => {
            TransformStreamError(controller._controlledTransformStream, r3);
            throw r3;
          });
        }
        function TransformStreamDefaultControllerTerminate(controller) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          ReadableStreamDefaultControllerClose(readableController);
          const error2 = new TypeError("TransformStream terminated");
          TransformStreamErrorWritableAndUnblockWrite(stream, error2);
        }
        function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
          const controller = stream._transformStreamController;
          if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
              const writable3 = stream._writable;
              const state = writable3._state;
              if (state === "erroring") {
                throw writable3._storedError;
              }
              return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }
        function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
          TransformStreamError(stream, reason);
          return promiseResolvedWith(void 0);
        }
        function TransformStreamDefaultSinkCloseAlgorithm(stream) {
          const readable3 = stream._readable;
          const controller = stream._transformStreamController;
          const flushPromise = controller._flushAlgorithm();
          TransformStreamDefaultControllerClearAlgorithms(controller);
          return transformPromiseWith(flushPromise, () => {
            if (readable3._state === "errored") {
              throw readable3._storedError;
            }
            ReadableStreamDefaultControllerClose(readable3._readableStreamController);
          }, (r3) => {
            TransformStreamError(stream, r3);
            throw readable3._storedError;
          });
        }
        function TransformStreamDefaultSourcePullAlgorithm(stream) {
          TransformStreamSetBackpressure(stream, false);
          return stream._backpressureChangePromise;
        }
        function defaultControllerBrandCheckException(name) {
          return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
        }
        function streamBrandCheckException(name) {
          return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
        }
        exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
        exports2.CountQueuingStrategy = CountQueuingStrategy;
        exports2.ReadableByteStreamController = ReadableByteStreamController;
        exports2.ReadableStream = ReadableStream2;
        exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
        exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
        exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
        exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
        exports2.TransformStream = TransformStream;
        exports2.TransformStreamDefaultController = TransformStreamDefaultController;
        exports2.WritableStream = WritableStream;
        exports2.WritableStreamDefaultController = WritableStreamDefaultController;
        exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    })(ponyfill_es2018, ponyfill_es2018.exports);
    POOL_SIZE$1 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = require("node:process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, require("node:stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error2) {
          process2.emitWarning = emitWarning;
          throw error2;
        }
      } catch (error2) {
        Object.assign(globalThis, ponyfill_es2018.exports);
      }
    }
    try {
      const { Blob: Blob4 } = require("buffer");
      if (Blob4 && !Blob4.prototype.stream) {
        Blob4.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error2) {
    }
    POOL_SIZE = 65536;
    _Blob = class Blob2 {
      #parts = [];
      #type = "";
      #size = 0;
      #endings = "transparent";
      constructor(blobParts = [], options = {}) {
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && typeof options !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options === null)
          options = {};
        const encoder2 = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob2) {
            part = element;
          } else {
            part = encoder2.encode(`${element}`);
          }
          const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (size) {
            this.#size += size;
            this.#parts.push(part);
          }
        }
        this.#endings = `${options.endings === void 0 ? "transparent" : options.endings}`;
        const type = options.type === void 0 ? "" : String(options.type);
        this.#type = /^[\x20-\x7E]*$/.test(type) ? type : "";
      }
      get size() {
        return this.#size;
      }
      get type() {
        return this.#type;
      }
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(this.#parts, false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it2 = toIterator(this.#parts, true);
        return new globalThis.ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it2.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it2.return();
          }
        });
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob2([], { type: String(type).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob3 = _Blob;
    Blob$1 = Blob3;
    _File = class File2 extends Blob$1 {
      #lastModified = 0;
      #name = "";
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options);
        if (options === null)
          options = {};
        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          this.#lastModified = lastModified;
        }
        this.#name = String(fileName);
      }
      get name() {
        return this.#name;
      }
      get lastModified() {
        return this.#lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      static [Symbol.hasInstance](object) {
        return !!object && object instanceof Blob$1 && /^(File)$/.test(object[Symbol.toStringTag]);
      }
    };
    File = _File;
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
    r = Math.random;
    m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    f2 = (a2, b2, c2) => (a2 += "", /^(Blob|File)$/.test(b2 && b2[t]) ? [(c2 = c2 !== void 0 ? c2 + "" : b2[t] == "File" ? b2.name : "blob", a2), b2.name !== c2 || b2[t] == "blob" ? new File([b2], c2, b2) : b2] : [a2, b2 + ""]);
    e = (c2, f4) => (f4 ? c2 : c2.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    x = (n2, a2, e3) => {
      if (a2.length < e3) {
        throw new TypeError(`Failed to execute '${n2}' on 'FormData': ${e3} arguments required, but only ${a2.length} present.`);
      }
    };
    FormData = class FormData2 {
      #d = [];
      constructor(...a2) {
        if (a2.length)
          throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o2) {
        return o2 && typeof o2 === "object" && o2[t] === "FormData" && !m.some((m3) => typeof o2[m3] != "function");
      }
      append(...a2) {
        x("append", arguments, 2);
        this.#d.push(f2(...a2));
      }
      delete(a2) {
        x("delete", arguments, 1);
        a2 += "";
        this.#d = this.#d.filter(([b2]) => b2 !== a2);
      }
      get(a2) {
        x("get", arguments, 1);
        a2 += "";
        for (var b2 = this.#d, l2 = b2.length, c2 = 0; c2 < l2; c2++)
          if (b2[c2][0] === a2)
            return b2[c2][1];
        return null;
      }
      getAll(a2, b2) {
        x("getAll", arguments, 1);
        b2 = [];
        a2 += "";
        this.#d.forEach((c2) => c2[0] === a2 && b2.push(c2[1]));
        return b2;
      }
      has(a2) {
        x("has", arguments, 1);
        a2 += "";
        return this.#d.some((b2) => b2[0] === a2);
      }
      forEach(a2, b2) {
        x("forEach", arguments, 1);
        for (var [c2, d2] of this)
          a2.call(b2, d2, c2, this);
      }
      set(...a2) {
        x("set", arguments, 2);
        var b2 = [], c2 = true;
        a2 = f2(...a2);
        this.#d.forEach((d2) => {
          d2[0] === a2[0] ? c2 && (c2 = !b2.push(a2)) : b2.push(d2);
        });
        c2 && b2.push(a2);
        this.#d = b2;
      }
      *entries() {
        yield* this.#d;
      }
      *keys() {
        for (var [a2] of this)
          yield a2;
      }
      *values() {
        for (var [, a2] of this)
          yield a2;
      }
    };
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
    };
    isDomainOrSubdomain = (destination, original) => {
      const orig = new URL(original).hostname;
      const dest = new URL(destination).hostname;
      return orig === dest || orig.endsWith(`.${dest}`);
    };
    pipeline = (0, import_node_util.promisify)(import_node_stream.default.pipeline);
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = import_node_buffer.Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (import_node_buffer.Buffer.isBuffer(body))
          ;
        else if (import_node_util.types.isAnyArrayBuffer(body)) {
          body = import_node_buffer.Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = import_node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_node_stream.default)
          ;
        else if (body instanceof FormData) {
          body = formDataToBlob(body);
          boundary = body.type.split("=")[1];
        } else {
          body = import_node_buffer.Buffer.from(String(body));
        }
        let stream = body;
        if (import_node_buffer.Buffer.isBuffer(body)) {
          stream = import_node_stream.default.Readable.from(body);
        } else if (isBlob(body)) {
          stream = import_node_stream.default.Readable.from(body.stream());
        }
        this[INTERNALS$2] = {
          body,
          stream,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_node_stream.default) {
          body.on("error", (error_) => {
            const error2 = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS$2].error = error2;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].stream;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async formData() {
        const ct2 = this.headers.get("content-type");
        if (ct2.startsWith("application/x-www-form-urlencoded")) {
          const formData = new FormData();
          const parameters = new URLSearchParams(await this.text());
          for (const [name, value] of parameters) {
            formData.append(name, value);
          }
          return formData;
        }
        const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
        return toFormData2(this.body, ct2);
      }
      async blob() {
        const ct2 = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.arrayBuffer();
        return new Blob$1([buf], {
          type: ct2
        });
      }
      async json() {
        const text = await this.text();
        return JSON.parse(text);
      }
      async text() {
        const buffer = await consumeBody(this);
        return new TextDecoder().decode(buffer);
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Body.prototype.buffer = (0, import_node_util.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true },
      data: { get: (0, import_node_util.deprecate)(() => {
      }, "data doesn't exist, use json(), text(), arrayBuffer(), or body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (response)") }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance[INTERNALS$2];
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_node_stream.default && typeof body.getBoundary !== "function") {
        p1 = new import_node_stream.PassThrough({ highWaterMark });
        p2 = new import_node_stream.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].stream = p1;
        body = p2;
      }
      return body;
    };
    getNonSpecFormDataBoundary = (0, import_node_util.deprecate)((body) => body.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167");
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (import_node_buffer.Buffer.isBuffer(body) || import_node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body instanceof FormData) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
      }
      if (body instanceof import_node_stream.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request[INTERNALS$2];
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (import_node_buffer.Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      return null;
    };
    writeToStream = async (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else {
        await pipeline(body, dest);
      }
    };
    validateHeaderName = typeof import_node_http.default.validateHeaderName === "function" ? import_node_http.default.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const error2 = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error2;
      }
    };
    validateHeaderValue = typeof import_node_http.default.validateHeaderValue === "function" ? import_node_http.default.validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error2 = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_CHAR" });
        throw error2;
      }
    };
    Headers2 = class extends URLSearchParams {
      constructor(init2) {
        let result = [];
        if (init2 instanceof Headers2) {
          const raw = init2.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !import_node_util.types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || import_node_util.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p2, receiver) {
            switch (p2) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p2].call(target, String(name).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p2].call(target, String(name).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p2, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback, thisArg = void 0) {
        for (const name of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key2) => {
          result[key2] = this.getAll(key2);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key2) => {
          const values = this.getAll(key2);
          if (key2 === "host") {
            result[key2] = values[0];
          } else {
            result[key2] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers2.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response2 = class extends Body {
      constructor(body = null, options = {}) {
        super(body, options);
        const status = options.status != null ? options.status : 200;
        const headers = new Headers2(options.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          type: "default",
          url: options.url,
          status,
          statusText: options.statusText || "",
          headers,
          counter: options.counter,
          highWaterMark: options.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS$1].type;
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response2(clone(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size,
          highWaterMark: this.highWaterMark
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response2(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      static error() {
        const response = new Response2(null, { status: 0, statusText: "" });
        response[INTERNALS$1].type = "error";
        return response;
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response2.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    ReferrerPolicy = /* @__PURE__ */ new Set([
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]);
    DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
    INTERNALS = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    doBadDataWarn = (0, import_node_util.deprecate)(() => {
    }, ".data is not a valid RequestInit property, use .body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (request)");
    Request2 = class extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        if (parsedURL.username !== "" || parsedURL.password !== "") {
          throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
        }
        let method = init2.method || input.method || "GET";
        if (/^(delete|get|head|options|post|put)$/i.test(method)) {
          method = method.toUpperCase();
        }
        if ("data" in init2) {
          doBadDataWarn();
        }
        if ((init2.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers2(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.set("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        let referrer = init2.referrer == null ? input.referrer : init2.referrer;
        if (referrer === "") {
          referrer = "no-referrer";
        } else if (referrer) {
          const parsedReferrer = new URL(referrer);
          referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
        } else {
          referrer = void 0;
        }
        this[INTERNALS] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal,
          referrer
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
        this.referrerPolicy = init2.referrerPolicy || input.referrerPolicy || "";
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return (0, import_node_url.format)(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      get referrer() {
        if (this[INTERNALS].referrer === "no-referrer") {
          return "";
        }
        if (this[INTERNALS].referrer === "client") {
          return "about:client";
        }
        if (this[INTERNALS].referrer) {
          return this[INTERNALS].referrer.toString();
        }
        return void 0;
      }
      get referrerPolicy() {
        return this[INTERNALS].referrerPolicy;
      }
      set referrerPolicy(referrerPolicy) {
        this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);
      }
      clone() {
        return new Request2(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true },
      referrer: { enumerable: true },
      referrerPolicy: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers2(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = DEFAULT_REFERRER_POLICY;
      }
      if (request.referrer && request.referrer !== "no-referrer") {
        request[INTERNALS].referrer = determineRequestsReferrer(request);
      } else {
        request[INTERNALS].referrer = "no-referrer";
      }
      if (request[INTERNALS].referrer instanceof URL) {
        headers.set("Referer", request.referrer);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const options = {
        path: parsedURL.pathname + search,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return {
        parsedURL,
        options
      };
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    if (!globalThis.DOMException) {
      try {
        const { MessageChannel } = require("worker_threads"), port = new MessageChannel().port1, ab = new ArrayBuffer();
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
      }
    }
    supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
    globals = {
      crypto: import_crypto.webcrypto,
      fetch: fetch2,
      Response: Response2,
      Request: Request2,
      Headers: Headers2
    };
  }
});

// node_modules/svelte-adapter-firebase/src/files/shims.js
var init_shims = __esm({
  "node_modules/svelte-adapter-firebase/src/files/shims.js"() {
    init_polyfills();
    installPolyfills();
  }
});

// .svelte-kit/output/server/chunks/index-7a55addd.js
function noop2() {
}
function assign(tar, src) {
  for (const k2 in src)
    tar[k2] = src[k2];
  return tar;
}
function run(fn2) {
  return fn2();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || (a2 && typeof a2 === "object" || typeof a2 === "function");
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop2;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_2) => value = _2)();
  return value;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function run_tasks(now22) {
  tasks.forEach((task) => {
    if (!task.c(now22)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e3 = document.createEvent("CustomEvent");
  e3.initCustomEvent(type, bubbles, cancelable, detail);
  return e3;
}
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onDestroy(fn2) {
  get_current_component().$$.on_destroy.push(fn2);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn2) => {
        fn2.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key2, context) {
  get_current_component().$$.context.set(key2, context);
  return context;
}
function getContext(key2) {
  return get_current_component().$$.context.get(key2);
}
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn2) {
  render_callbacks.push(fn2);
}
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i3 = 0; i3 < render_callbacks.length; i3 += 1) {
      const callback = render_callbacks[i3];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function escape2(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped[match]);
}
function escape_attribute_value(value) {
  return typeof value === "string" ? escape2(value) : value;
}
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
function create_ssr_component(fn2) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn2(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = /* @__PURE__ */ new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: /* @__PURE__ */ new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css8) => css8.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  const assignment = boolean && value === true ? "" : `="${escape_attribute_value(value.toString())}"`;
  return ` ${name}${assignment}`;
}
function add_classes(classes) {
  return classes ? ` class="${classes}"` : "";
}
var identity, is_client, now, raf, tasks, current_component, dirty_components, binding_callbacks, render_callbacks, flush_callbacks, resolved_promise, update_scheduled, seen_callbacks, flushidx, escaped, missing_component, on_destroy;
var init_index_7a55addd = __esm({
  ".svelte-kit/output/server/chunks/index-7a55addd.js"() {
    init_shims();
    identity = (x3) => x3;
    is_client = typeof window !== "undefined";
    now = is_client ? () => window.performance.now() : () => Date.now();
    raf = is_client ? (cb) => requestAnimationFrame(cb) : noop2;
    tasks = /* @__PURE__ */ new Set();
    dirty_components = [];
    binding_callbacks = [];
    render_callbacks = [];
    flush_callbacks = [];
    resolved_promise = Promise.resolve();
    update_scheduled = false;
    seen_callbacks = /* @__PURE__ */ new Set();
    flushidx = 0;
    escaped = {
      '"': "&quot;",
      "'": "&#39;",
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;"
    };
    missing_component = {
      $$render: () => ""
    };
  }
});

// .svelte-kit/output/server/chunks/hooks-1c45ba0b.js
var hooks_1c45ba0b_exports = {};
var init_hooks_1c45ba0b = __esm({
  ".svelte-kit/output/server/chunks/hooks-1c45ba0b.js"() {
    init_shims();
  }
});

// .svelte-kit/output/server/entries/fallbacks/layout.svelte.js
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: () => Layout
});
var Layout;
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/fallbacks/layout.svelte.js"() {
    init_shims();
    init_index_7a55addd();
    Layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${slots.default ? slots.default({}) : ``}`;
    });
  }
});

// .svelte-kit/output/server/nodes/0.js
var __exports = {};
__export(__exports, {
  css: () => css,
  entry: () => entry,
  index: () => index,
  js: () => js,
  module: () => layout_svelte_exports
});
var index, entry, js, css;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    init_shims();
    init_layout_svelte();
    index = 0;
    entry = "layout.svelte-f4f52364.js";
    js = ["layout.svelte-f4f52364.js", "chunks/index-fb8c27ab.js"];
    css = [];
  }
});

// .svelte-kit/output/server/entries/fallbacks/error.svelte.js
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: () => Error2,
  load: () => load
});
function load({ error: error2, status }) {
  return { props: { error: error2, status } };
}
var Error2;
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/fallbacks/error.svelte.js"() {
    init_shims();
    init_index_7a55addd();
    Error2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { status } = $$props;
      let { error: error2 } = $$props;
      if ($$props.status === void 0 && $$bindings.status && status !== void 0)
        $$bindings.status(status);
      if ($$props.error === void 0 && $$bindings.error && error2 !== void 0)
        $$bindings.error(error2);
      return `<h1>${escape2(status)}</h1>

<pre>${escape2(error2.message)}</pre>



${error2.frame ? `<pre>${escape2(error2.frame)}</pre>` : ``}
${error2.stack ? `<pre>${escape2(error2.stack)}</pre>` : ``}`;
    });
  }
});

// .svelte-kit/output/server/nodes/1.js
var __exports2 = {};
__export(__exports2, {
  css: () => css2,
  entry: () => entry2,
  index: () => index2,
  js: () => js2,
  module: () => error_svelte_exports
});
var index2, entry2, js2, css2;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    init_shims();
    init_error_svelte();
    index2 = 1;
    entry2 = "error.svelte-b817d57a.js";
    js2 = ["error.svelte-b817d57a.js", "chunks/index-fb8c27ab.js"];
    css2 = [];
  }
});

// .svelte-kit/output/server/chunks/page-0c511438.js
var Footer, favicon32, favicon16, faviconApple, Page;
var init_page_0c511438 = __esm({
  ".svelte-kit/output/server/chunks/page-0c511438.js"() {
    init_shims();
    init_index_7a55addd();
    Footer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let year = new Date().getFullYear();
      return `<div><div class="${"w-full left-0 bg-primaryBg p-6"}">
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="${"flex flex-row items-center px-10 justify-around sm:justify-between max-w-3xl mx-auto w-full sm:w-auto mt-3 mb-8"}"><a href="${"/privacy"}"><p class="${"font-baloo2 text-md md:text-xl text-light whitespace-nowrap"}">\xA0 Privacy
        </p></a>
      <div class="${"min-w-2 w-2 sm:min-w-6 sm:w-6 h-0.5 rounded-full bg-light mx-3 sm:mx-12 hidden sm:block"}"></div>
      <a href="${"/terms"}"><p class="${"font-baloo2 text-md md:text-xl text-light whitespace-nowrap"}">\xA0 Terms
        </p></a>
      <div class="${"min-w-2 w-2 sm:min-w-6 sm:w-6 h-0.5 rounded-full bg-light mx-3 sm:mx-12 hidden sm:block"}"></div>
      <a href="${"/license"}"><p class="${"font-baloo2 text-md md:text-xl text-light whitespace-nowrap"}">\xA0 License
        </p></a></div>
    <div class="${"mx-auto"}"><p class="${"font-roboto text-md text-light text-center"}">\xA9 <span id="${"copyright"}">${escape2(year || 2022)}</span> Neil Agrawal
      </p></div></div></div>`;
    });
    favicon32 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABZhJREFUWEedV29MU1cU/z3oKOBiH9VRoWAQCKFzcf6pXaYkE01qMhMX+wqpZAbmB74zSGAsGIks3Ui6+BWXqInxC1KMfiDQzWwzkMgyBziSAouzQqtFIc8YKZqBXe59f/re63uU7X5p333vnPM75/zOOfcyAAMgCfrLkF/xUfiXvhgGSIrfSaKyDvK5vCnKinpFEUmhbFWpg9jXfCd8r2tIiY18kAm5gT+6TkpB0DpjFBUjJZvAJEE3hpceEqaqqqrY5/M5DzqdrhyzuWB2dva34MDA+K937/4FYO2/4FED0PGYZVnW5/PtPVJb6youKnKxLOsqttvt26zWLJE51N5KIoGF+fllnufvx+Pxe6Ojo+O3bt36/eHDh882CpwIQLZsPvnZyfdPfHrCVVFZ4SpgC1w2m62qqKgoJysrS6VHaVzPQDKZxPPnz9efxJ78zb/g7z169IgAGr99+/Y0gNcSsQinKfHcx90HWr9s/cVms72bl5cHu92OLflbZBJSg4SkhNSputHY1oe1urqKaDSKRCKBxcXFV4FA4EgoFLov8Zsq8Xg8h4PB4CiBs77+FtFoDInEimzMarWisLAQDIWsWDo2X/AvEF+Mg0SBrNzcXJSWlML0jok+cxxXMzg4OEZckbWlAOhnbHl5Gc+epdJpNudgZ+lOZJtM1BgxKi2WZbFjxw4FWInJgjkK4ObNMdJPNg1A6lVSZb15/ZqGdWFhAfv27QMxmiEw8utUBKQYJJUpAK5du0aVO51O7N9/ANu2WQ2JHJ4Jw1Ht0H9PUiCzLJU6TQoESilT0NLSgosXL1KlJOeVlZU4e/Ys2traYDJli61RsBkOh+FwKABkKg8VB4QBkAaAGAoEAmleeb1e9Pf3q3IbDs/A4aimoGTbShA6gOQIiNYpBBKBAVoFQHt7O3p7e3XD2n+jH3XeOvmdMgKbcF5TBYL7dHk4z+HggACg86tO+L/10/3GxkY8mJrCxOQkfXa73RgZGdEFYEgUDT05rq5mcDA4JsWfhs/jOUUjQBB1dXWhp6eHihFClpSUoLa2llathbWA53kNACEFm11CCm6OEe7JbSWVgiTOn+9Gd3c31XfadxpbLVvR19cn619bW0N2NiGjloQ6SdDpnuoylFIgcoD4caHnAs51nUtziLzLy9+ClZVXGVKwARuSAOfN0An9fj86v+7UPZ0cPXoUP925Ix+eaB9QlqE0J+QeIGFNgdqwEZHPer/rRUdHO5UkuY/FYpibmwOZB8PDIzjodMopVzeizdWBYQqEYQR8Hwigta2Nku7ylctoamzC0/hTWCwW5Ofnq1JDyrDa4VBT0AiHuJ8OgAE8p6RpCNoFSTck6/KVK/iiqUk8t2o0JwE5BdK8NqoGhWhGAC9fvkQwGMT169fR2NiEM2c+T50ANBhmaARIGZKlKMUNuqGX42qCdBwrJDjOc3hAbETKGJOZnnYGoHCEUSq0YoNhRBQpgAgyjHweIP/lWXXc7a7+xu+/sauszFFgtWar2woRVR0f0spwM/Tjef5tJBIJd3R0eEOh0IwmZoKB3R/sLm1ubj6258M97ve2bz9WUVFZaDabqUHJA2WEVNNQ5S2wvraGSCTCx+Pxn6f/nB6+9MOl0MTExGPJsOyUfCFJPxWbOI7bW19f7y4rK3MXFxd/ZLfbc1MpSaalYGlpaX3+8fyDaCw6PDQ0NNzX1zcOhnkj36Y07c24gWsvOwxQvqvc0tDQ8ElNTY3bVmhzl1eUV0QikaycnJyleDx+Z3Jycvjq1as/Tk1NxQROKq5xOoOCmNAey8XjgXBYFDKvDJhCCwPm0MeHylmW3T40NPQHgH+M7KludhIxJc3/5/aVktFKi88ZlCrlJVdTt+P0q5hO8DJs6VyIjUDLHNADnban2aDCG6fZkAZSuv4FwgODSDkcvF8AAAAASUVORK5CYII=";
    favicon16 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAqRJREFUOE9VU01PE1EUPQ9KKWlpmziDDWmAglLiwsYFBNCCpKUm8hMkMRkWan+CILaxriS4ItFF8VdIgAAGJVE21sYu+JBOqyLKTENpMSRIGHPfm1Z8mczHnXfPPee8exnAAGbQBYPez90ZDBgiBAb+Ze5AdTHGAKOyywxTsKOjo358/OFVh73R9uRp4uPndPq3UUkTNTk4AdOqicXil4ZDoZ6LHk+PzdbQ0+hwBJwup41+lo+O/pRLpczx8fG6pmkfFhYW1+Oxx1sG2BkjhNV3b1/4Oy/fY6yW83W5XLBarYK7KIPT01MUi0WiizPDwObW5svB4MB9Xj+rqsm2tlalorN0WMLJyQmnRk+rtR51FgvcbheEZ0Aul5v1tfvGuAQ1qyZ3d38oU1PP0N3djdE7o2hpbeEE9IIGSZKEeoPBMA3P5XOzPl/7GIdT1Wxy+8u2EolEuCmUkMlkIDc1Qdc0yLJMzCvFORZnQACkgSRksztKOBTG+MQEEokEZmZmEI1GoWnEQAbfKFzhJ6Dmc7MdJIHiO6qa/JrPKzeHhnAtEEDqUxrxeAyTk4+g6zoHMFOrT8GAPAC4hO/fdpWBgSCam5vxa38fKytvELxxHbpegCRXPBAyuASVTDwn4efentLX349UKoUufxdsDbwFuAeSLFe5i14E8v8zUJNer1dZXl5GIBCAx+MRWmFA0wuQJcn8/ucDSWgXHjC8npsb9Ps77zrsjmFJkrystsasQwA65AsSyEU6iUJB2yuXjxY3NjZejdweWeUm8h4352j6+fSVcCgccbvdt5xOV/DgoFBnsdS9LxaL82tra/PR6IM0NSNPqcyCmESBIoaLfhro7e1rsDvs1qWlpUNqIorxfji3TE/N5KpSc5cJVu0gPtZmR/HhBv4C7wMsLczBVQQAAAAASUVORK5CYII=";
    faviconApple = "/_app/immutable/assets/apple-touch-icon-ed367713.png";
    Page = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let topRight1, topRight2, documentEl;
      let { home } = $$props;
      if ($$props.home === void 0 && $$bindings.home && home !== void 0)
        $$bindings.home(home);
      return `${$$result.head += `<link rel="${"apple-touch-icon"}" sizes="${"180x180"}"${add_attribute("href", faviconApple, 0)} data-svelte="svelte-12jv3av"><link rel="${"icon"}" type="${"image/png"}" sizes="${"32x32"}"${add_attribute("href", favicon32, 0)} data-svelte="svelte-12jv3av"><link rel="${"icon"}" type="${"image/png"}" sizes="${"16x16"}"${add_attribute("href", favicon16, 0)} data-svelte="svelte-12jv3av"><meta name="${"apple-itunes-app"}" content="${"app-id=1592436336"}" data-svelte="svelte-12jv3av">`, ""}


<div class="${"h-0"}">
  

  
  
  

  
  <svg class="${"fixed bottom-0 left-0 below2"}" width="${"2560px"}" height="${"1440px"}" viewBox="${"0 0 2560 1440"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}"${add_attribute("this", topRight2, 0)}><path id="${"a1"}" d="${"M0 1144C33.7449 1163.62 67.41 1183.25 102.91 1196.62C138.33 1209.91 175.585 1216.87 207.017 1237.12C238.448 1257.29 264.136 1290.75 279.053 1326.71C293.892 1362.75 297.96 1401.38 302.029 1440H0V1144Z"}" fill="${"#EEF4FA"}"></path></svg>

  <svg class="${"fixed top-0 right-0 below2"}" width="${"2560px"}" height="${"1440px"}" viewBox="${"0 0 2560 1440"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}"${add_attribute("this", topRight1, 0)}><path id="${"b1"}" d="${"M2560 328C2510 328 2460.13 328 2428.33 303.012C2396.65 278.145 2383.17 228.29 2354.03 196.388C2324.9 164.485 2279.99 150.414 2254.42 120.695C2228.85 90.9763 2222.36 45.4882 2216 0H2560V328Z"}" fill="${"#EEF4FA"}"></path></svg>

  <svg class="${"fixed bottom-0 left-0 below2"}" width="${"2560px"}" height="${"1440px"}" viewBox="${"0 0 2560 1440"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}"${add_attribute("this", topRight2, 0)}><path id="${"a2"}" d="${"M0 1203.18C26.964 1218.9 53.928 1234.61 82.328 1245.25C110.648 1255.88 140.484 1261.51 165.613 1277.69C190.742 1293.88 211.324 1320.54 223.211 1349.39C235.097 1378.16 238.368 1409.12 241.639 1440H0V1203.18Z"}" fill="${"#D6E9FB"}"></path></svg>

  <svg class="${"fixed top-0 right-0 below2"}" width="${"2560px"}" height="${"1440px"}" viewBox="${"0 0 2560 1440"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}"${add_attribute("this", topRight1, 0)}><path id="${"b2"}" d="${"M2560 263.163C2519.85 263.163 2479.84 263.163 2454.39 243.179C2428.94 223.195 2418.05 183.228 2394.78 157.534C2371.37 131.971 2335.31 120.681 2314.76 96.8045C2294.21 72.9278 2289.17 36.4639 2284 0H2560V263.163Z"}" fill="${"#D6E9FB"}"></path></svg>

  <svg class="${"fixed bottom-0 left-0 below2"}" width="${"2560px"}" height="${"1440px"}" viewBox="${"0 0 2560 1440"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}"${add_attribute("this", topRight2, 0)}><path id="${"a3"}" d="${"M0 1262.45C20.2629 1274.17 40.446 1285.98 61.746 1293.95C83.0459 1301.93 105.303 1306.15 124.21 1318.27C143.117 1330.39 158.513 1350.4 167.448 1372.06C176.303 1393.64 178.776 1416.86 181.169 1440H0V1262.45Z"}" fill="${"#BEDFFD"}"></path></svg>

  <svg class="${"fixed top-0 right-0 below2"}" width="${"2560px"}" height="${"1440px"}" viewBox="${"0 0 2560 1440"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}"${add_attribute("this", topRight1, 0)}><path id="${"b3"}" d="${"M2560 196.419C2530.14 196.419 2500.12 196.419 2481.23 181.455C2462.18 166.491 2454.11 136.709 2436.58 117.677C2419.21 98.4999 2392.4 90.0736 2377.01 72.2042C2361.62 54.48 2357.81 27.1674 2354 0H2560V196.419Z"}" fill="${"#BEDFFD"}"></path></svg>

  <svg class="${"fixed bottom-0 left-0 below2"}" width="${"2560px"}" height="${"1440px"}" viewBox="${"0 0 2560 1440"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}"${add_attribute("this", topRight2, 0)}><path id="${"a4"}" d="${"M0 1321.63C13.482 1329.45 26.964 1337.27 41.164 1342.66C55.3639 1347.98 70.2021 1350.79 82.8066 1358.85C95.411 1366.9 105.702 1380.27 111.605 1394.65C117.589 1409.12 119.184 1424.52 120.78 1440H0V1321.63Z"}" fill="${"#A3D4FE"}"></path></svg>

  <svg class="${"fixed top-0 right-0 below2"}" width="${"2560px"}" height="${"1440px"}" viewBox="${"0 0 2560 1440"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}"${add_attribute("this", topRight1, 0)}><path id="${"b4"}" d="${"M2560 128.912C2540.4 128.912 2520.7 128.912 2508.3 119.091C2495.8 109.27 2490.5 89.7233 2479 77.2326C2467.6 64.6465 2450 59.1163 2439.9 47.3884C2429.8 35.7558 2427.3 17.8302 2424.8 0H2560V128.912Z"}" fill="${"#A3D4FE"}"></path></svg>

  <svg class="${"fixed bottom-0 left-0 below2"}" width="${"2560px"}" height="${"1440px"}" viewBox="${"0 0 2560 1440"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}"${add_attribute("this", topRight2, 0)}><path id="${"a5"}" d="${"M0 1380.82C6.78088 1384.72 13.482 1388.63 20.582 1391.29C27.682 1393.95 35.101 1395.36 41.4033 1399.42C47.7055 1403.49 52.8111 1410.13 55.8426 1417.33C58.7943 1424.52 59.592 1432.26 60.3898 1440H0V1380.82Z"}" fill="${"#95CFFF"}"></path></svg>

  <svg class="${"fixed top-0 right-0 below2"}" width="${"2560px"}" height="${"1440px"}" viewBox="${"0 0 2560 1440"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}"${add_attribute("this", topRight1, 0)}><path id="${"b5"}" d="${"M2560 64.4558C2550.2 64.4558 2540.4 64.4558 2534.1 59.593C2527.9 54.6349 2525.2 44.9093 2519.5 38.6163C2513.8 32.3233 2505 29.5581 2499.9 23.7419C2494.9 17.8302 2493.7 8.96279 2492.4 0H2560V64.4558Z"}" fill="${"#95CFFF"}"></path></svg></div>
<div class="${"siteWrapper"}"${add_attribute("this", documentEl, 0)}><div class="${"hidden flex flex-row h-28 items-center sm:pl-8 lg:pl-16 border-b border-gray-900 justify-between header w-full"}"><div class="${"flex flex-row"}">${home === "true" ? `<p class="${"text-black font-futura font-bold tracking-tight text-5xl hidden sm:block"}">PeaceBox</p>` : `<a href="${"/"}"><p class="${"text-black font-futura font-bold tracking-tight text-5xl hidden sm:block"}">PeaceBox</p></a>`}

      <div class="${"max-w-28 min-w-24 pr-3 sm:hidden"}"><p class="${"text-black font-futura font-bold tracking-tight text-7xl pl-4"}">P</p></div></div>
    <div class="${"flex flex-row h-full items-center"}"><div class="${"mr-4 md:mr-8 lg:mr-12 py-2"}"><a href="${"mailto:contact@peacebox.app"}" target="${"_blank"}"><p class="${"font-baloo2 text-md whitespace-nowrap"}"><i class="${"fa-solid fa-envelope fa-md"}"></i> \xA0Email</p></a></div>
      <div class="${"mr-6 md:mr-10 lg:mr-14 py-2 hidden sm:block"}"><a href="${"https://github.com/neagdolph/peacebox"}" target="${"_blank"}"><p class="${"font-baloo2 text-md"}"><i class="${"fa-brands fa-github fa-md"}"></i> \xA0Github</p></a></div>
      
      
      
      
      
      
      
      
      <div class="${"h-full pr-8 pl-4 block sm:hidden border-gray-900 flex items-center"}"><a href="${"https://apps.apple.com/us/app/peacebox-tools-for-your-mind/id1592436336"}" aria-label="${"Visit PeaceBox on the Appstore"}"><i class="${"fa-solid fa-cloud-arrow-down fa-2x"}"></i></a></div></div></div>
  ${slots.default ? slots.default({}) : ``}
  ${validate_component(Footer, "Footer").$$render($$result, {}, {}, {})}</div>`;
    });
  }
});

// .svelte-kit/output/server/chunks/github_button-7b97a99c.js
var Github_button;
var init_github_button_7b97a99c = __esm({
  ".svelte-kit/output/server/chunks/github_button-7b97a99c.js"() {
    init_shims();
    init_index_7a55addd();
    Github_button = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<a href="${"https://github.com/neagdolph/peacebox"}" target="${"_blank"}" aria-label="${"Visit the PeaceBox GitHub Repository"}"><p class="${"font-baloo2 text-lg sm:text-xl whitespace-nowrap text-primary"}"><i class="${"fa-brands fa-github fa-md sm:fa-lg"}"></i> \xA0
    Github
  </p></a>`;
    });
  }
});

// .svelte-kit/output/server/entries/pages/index.svelte.js
var index_svelte_exports = {};
__export(index_svelte_exports, {
  default: () => Routes
});
function readable2(value, start) {
  return {
    subscribe: writable2(value, start).subscribe
  };
}
function writable2(value, start = noop2) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue2.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue2.push(subscriber, value);
        }
        if (run_queue) {
          for (let i22 = 0; i22 < subscriber_queue2.length; i22 += 2) {
            subscriber_queue2[i22][0](subscriber_queue2[i22 + 1]);
          }
          subscriber_queue2.length = 0;
        }
      }
    }
  }
  function update2(fn2) {
    set(fn2(value));
  }
  function subscribe2(run2, invalidate = noop2) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop2;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn2, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto = fn2.length < 2;
  return readable2(initial_value, (set) => {
    let inited = false;
    const values = [];
    let pending = 0;
    let cleanup = noop2;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn2(single ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop2;
      }
    };
    const unsubscribers = stores_array.map((store, i22) => subscribe(store, (value) => {
      values[i22] = value;
      pending &= ~(1 << i22);
      if (inited) {
        sync();
      }
    }, () => {
      pending |= 1 << i22;
    }));
    inited = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
    };
  });
}
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n2, m22) {
  return (n2 % m22 + m22) % m22;
}
function mapLinear(x22, a1, a2, b1, b2) {
  return b1 + (x22 - a1) * (b2 - b1) / (a2 - a1);
}
function inverseLerp(x22, y2, value) {
  if (x22 !== y2) {
    return (value - x22) / (y2 - x22);
  } else {
    return 0;
  }
}
function lerp(x22, y2, t22) {
  return (1 - t22) * x22 + t22 * y2;
}
function damp(x22, y2, lambda, dt2) {
  return lerp(x22, y2, 1 - Math.exp(-lambda * dt2));
}
function pingpong(x22, length = 1) {
  return length - Math.abs(euclideanModulo(x22, length * 2) - length);
}
function smoothstep(x22, min, max) {
  if (x22 <= min)
    return 0;
  if (x22 >= max)
    return 1;
  x22 = (x22 - min) / (max - min);
  return x22 * x22 * (3 - 2 * x22);
}
function smootherstep(x22, min, max) {
  if (x22 <= min)
    return 0;
  if (x22 >= max)
    return 1;
  x22 = (x22 - min) / (max - min);
  return x22 * x22 * x22 * (x22 * (x22 * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s22) {
  if (s22 !== void 0)
    _seed = s22;
  let t22 = _seed += 1831565813;
  t22 = Math.imul(t22 ^ t22 >>> 15, t22 | 1);
  t22 ^= t22 + Math.imul(t22 ^ t22 >>> 7, t22 | 61);
  return ((t22 ^ t22 >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q2, a2, b2, c2, order) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c22 = cos(b2 / 2);
  const s22 = sin(b2 / 2);
  const c13 = cos((a2 + c2) / 2);
  const s13 = sin((a2 + c2) / 2);
  const c1_3 = cos((a2 - c2) / 2);
  const s1_3 = sin((a2 - c2) / 2);
  const c3_1 = cos((c2 - a2) / 2);
  const s3_1 = sin((c2 - a2) / 2);
  switch (order) {
    case "XYX":
      q2.set(c22 * s13, s22 * c1_3, s22 * s1_3, c22 * c13);
      break;
    case "YZY":
      q2.set(s22 * s1_3, c22 * s13, s22 * c1_3, c22 * c13);
      break;
    case "ZXZ":
      q2.set(s22 * c1_3, s22 * s1_3, c22 * s13, c22 * c13);
      break;
    case "XZX":
      q2.set(c22 * s13, s22 * s3_1, s22 * c3_1, c22 * c13);
      break;
    case "YXY":
      q2.set(s22 * c3_1, c22 * s13, s22 * s3_1, c22 * c13);
      break;
    case "ZYZ":
      q2.set(s22 * s3_1, s22 * c3_1, c22 * s13, c22 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
function denormalize$1(value, array2) {
  switch (array2.constructor) {
    case Float32Array:
      return value;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize2(value, array2) {
  switch (array2.constructor) {
    case Float32Array:
      return value;
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
function arrayNeedsUint32(array2) {
  for (let i22 = array2.length - 1; i22 >= 0; --i22) {
    if (array2[i22] > 65535)
      return true;
  }
  return false;
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function SRGBToLinear(c2) {
  return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c2) {
  return c2 < 31308e-7 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
function hue2rgb(p2, q2, t22) {
  if (t22 < 0)
    t22 += 1;
  if (t22 > 1)
    t22 -= 1;
  if (t22 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t22;
  if (t22 < 1 / 2)
    return q2;
  if (t22 < 2 / 3)
    return p2 + (q2 - p2) * 6 * (2 / 3 - t22);
  return p2;
}
function toComponents(source, target) {
  target.r = source.r;
  target.g = source.g;
  target.b = source.b;
  return target;
}
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i22 = 0, j2 = axes.length - 3; i22 <= j2; i22 += 3) {
    _testAxis.fromArray(axes, i22);
    const r22 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r22) {
      return false;
    }
  }
  return true;
}
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far)
    return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2) {
  _vA$1.fromBufferAttribute(position, a2);
  _vB$1.fromBufferAttribute(position, b2);
  _vC$1.fromBufferAttribute(position, c2);
  const morphInfluences = object.morphTargetInfluences;
  if (morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i22 = 0, il = morphPosition.length; i22 < il; i22++) {
      const influence = morphInfluences[i22];
      const morphAttribute = morphPosition[i22];
      if (influence === 0)
        continue;
      _tempA.fromBufferAttribute(morphAttribute, a2);
      _tempB.fromBufferAttribute(morphAttribute, b2);
      _tempC.fromBufferAttribute(morphAttribute, c2);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
      }
    }
    _vA$1.add(_morphA);
    _vB$1.add(_morphB);
    _vC$1.add(_morphC);
  }
  if (object.isSkinnedMesh) {
    object.boneTransform(a2, _vA$1);
    object.boneTransform(b2, _vB$1);
    object.boneTransform(c2, _vC$1);
  }
  const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a2);
      _uvB$1.fromBufferAttribute(uv, b2);
      _uvC$1.fromBufferAttribute(uv, c2);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a2);
      _uvB$1.fromBufferAttribute(uv2, b2);
      _uvC$1.fromBufferAttribute(uv2, c2);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    const face = {
      a: a2,
      b: b2,
      c: c2,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }
  return intersection;
}
function cloneUniforms(src) {
  const dst = {};
  for (const u2 in src) {
    dst[u2] = {};
    for (const p2 in src[u2]) {
      const property = src[u2][p2];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u2][p2] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u2][p2] = property.slice();
      } else {
        dst[u2][p2] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u2 = 0; u2 < uniforms.length; u2++) {
    const tmp = cloneUniforms(uniforms[u2]);
    for (const p2 in tmp) {
      merged[p2] = tmp[p2];
    }
  }
  return merged;
}
function isUniqueEdge(start, end, edges) {
  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;
  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}
function now2() {
  return (typeof performance === "undefined" ? Date : performance).now();
}
function ascSort(a2, b2) {
  return a2.distance - b2.distance;
}
function intersectObject(object, raycaster, intersects, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects);
  }
  if (recursive === true) {
    const children = object.children;
    for (let i22 = 0, l2 = children.length; i22 < l2; i22++) {
      intersectObject(children[i22], raycaster, intersects, true);
    }
  }
}
function Vi(t22) {
  return typeof TextEncoder != "undefined" ? new TextEncoder().encode(t22) : Buffer.from(t22);
}
function Ei(t22) {
  return typeof TextDecoder != "undefined" ? new TextDecoder().decode(t22) : Buffer.from(t22).toString("utf8");
}
function Fi(t22) {
  let e22 = 0;
  for (const n3 of t22)
    e22 += n3.byteLength;
  const n2 = new Uint8Array(e22);
  let i22 = 0;
  for (const e3 of t22)
    n2.set(new Uint8Array(e3), i22), i22 += e3.byteLength;
  return n2;
}
function Pi(t22) {
  const e22 = new Uint8Array(t22.buffer, t22.byteOffset, Ti.length);
  if (e22[0] !== Ti[0] || e22[1] !== Ti[1] || e22[2] !== Ti[2] || e22[3] !== Ti[3] || e22[4] !== Ti[4] || e22[5] !== Ti[5] || e22[6] !== Ti[6] || e22[7] !== Ti[7] || e22[8] !== Ti[8] || e22[9] !== Ti[9] || e22[10] !== Ti[10] || e22[11] !== Ti[11])
    throw new Error("Missing KTX 2.0 identifier.");
  const n2 = new Si(), i22 = 17 * Uint32Array.BYTES_PER_ELEMENT, s22 = new Ii(t22, Ti.length, i22, true);
  n2.vkFormat = s22._nextUint32(), n2.typeSize = s22._nextUint32(), n2.pixelWidth = s22._nextUint32(), n2.pixelHeight = s22._nextUint32(), n2.pixelDepth = s22._nextUint32(), n2.layerCount = s22._nextUint32(), n2.faceCount = s22._nextUint32();
  const a2 = s22._nextUint32();
  n2.supercompressionScheme = s22._nextUint32();
  const r22 = s22._nextUint32(), o2 = s22._nextUint32(), l2 = s22._nextUint32(), f22 = s22._nextUint32(), U2 = s22._nextUint64(), c2 = s22._nextUint64(), h22 = new Ii(t22, Ti.length + i22, 3 * a2 * 8, true);
  for (let e3 = 0; e3 < a2; e3++)
    n2.levels.push({ levelData: new Uint8Array(t22.buffer, t22.byteOffset + h22._nextUint64(), h22._nextUint64()), uncompressedByteLength: h22._nextUint64() });
  const _2 = new Ii(t22, r22, o2, true), p2 = { vendorId: _2._skip(4)._nextUint16(), descriptorType: _2._nextUint16(), versionNumber: _2._nextUint16(), descriptorBlockSize: _2._nextUint16(), colorModel: _2._nextUint8(), colorPrimaries: _2._nextUint8(), transferFunction: _2._nextUint8(), flags: _2._nextUint8(), texelBlockDimension: [_2._nextUint8(), _2._nextUint8(), _2._nextUint8(), _2._nextUint8()], bytesPlane: [_2._nextUint8(), _2._nextUint8(), _2._nextUint8(), _2._nextUint8(), _2._nextUint8(), _2._nextUint8(), _2._nextUint8(), _2._nextUint8()], samples: [] }, g2 = (p2.descriptorBlockSize / 4 - 6) / 4;
  for (let t3 = 0; t3 < g2; t3++) {
    const e3 = { bitOffset: _2._nextUint16(), bitLength: _2._nextUint8(), channelType: _2._nextUint8(), samplePosition: [_2._nextUint8(), _2._nextUint8(), _2._nextUint8(), _2._nextUint8()], sampleLower: -Infinity, sampleUpper: Infinity };
    64 & e3.channelType ? (e3.sampleLower = _2._nextInt32(), e3.sampleUpper = _2._nextInt32()) : (e3.sampleLower = _2._nextUint32(), e3.sampleUpper = _2._nextUint32()), p2.samples[t3] = e3;
  }
  n2.dataFormatDescriptor.length = 0, n2.dataFormatDescriptor.push(p2);
  const y2 = new Ii(t22, l2, f22, true);
  for (; y2._offset < f22; ) {
    const t3 = y2._nextUint32(), e3 = y2._scan(t3), i3 = Ei(e3), s32 = y2._scan(t3 - e3.byteLength);
    n2.keyValue[i3] = i3.match(/^ktx/i) ? Ei(s32) : s32, y2._offset % 4 && y2._skip(4 - y2._offset % 4);
  }
  if (c2 <= 0)
    return n2;
  const x22 = new Ii(t22, U2, c2, true), u2 = x22._nextUint16(), b2 = x22._nextUint16(), d2 = x22._nextUint32(), m22 = x22._nextUint32(), w2 = x22._nextUint32(), D2 = x22._nextUint32(), B2 = [];
  for (let t3 = 0; t3 < a2; t3++)
    B2.push({ imageFlags: x22._nextUint32(), rgbSliceByteOffset: x22._nextUint32(), rgbSliceByteLength: x22._nextUint32(), alphaSliceByteOffset: x22._nextUint32(), alphaSliceByteLength: x22._nextUint32() });
  const L2 = U2 + x22._offset, A22 = L2 + d2, k2 = A22 + m22, v2 = k2 + w2, S22 = new Uint8Array(t22.buffer, t22.byteOffset + L2, d2), I2 = new Uint8Array(t22.buffer, t22.byteOffset + A22, m22), O2 = new Uint8Array(t22.buffer, t22.byteOffset + k2, w2), T2 = new Uint8Array(t22.buffer, t22.byteOffset + v2, D2);
  return n2.globalData = { endpointCount: u2, selectorCount: b2, imageDescs: B2, endpointsData: S22, selectorsData: I2, tablesData: O2, extendedData: T2 }, n2;
}
function Ci() {
  return (Ci = Object.assign || function(t22) {
    for (var e22 = 1; e22 < arguments.length; e22++) {
      var n2 = arguments[e22];
      for (var i22 in n2)
        Object.prototype.hasOwnProperty.call(n2, i22) && (t22[i22] = n2[i22]);
    }
    return t22;
  }).apply(this, arguments);
}
function Mi(t22, e22 = {}) {
  e22 = Ci({}, zi, e22);
  let n2 = new ArrayBuffer(0);
  if (t22.globalData) {
    const e3 = new ArrayBuffer(20 + 5 * t22.globalData.imageDescs.length * 4), i3 = new DataView(e3);
    i3.setUint16(0, t22.globalData.endpointCount, true), i3.setUint16(2, t22.globalData.selectorCount, true), i3.setUint32(4, t22.globalData.endpointsData.byteLength, true), i3.setUint32(8, t22.globalData.selectorsData.byteLength, true), i3.setUint32(12, t22.globalData.tablesData.byteLength, true), i3.setUint32(16, t22.globalData.extendedData.byteLength, true);
    for (let e4 = 0; e4 < t22.globalData.imageDescs.length; e4++) {
      const n3 = t22.globalData.imageDescs[e4];
      i3.setUint32(20 + 5 * e4 * 4 + 0, n3.imageFlags, true), i3.setUint32(20 + 5 * e4 * 4 + 4, n3.rgbSliceByteOffset, true), i3.setUint32(20 + 5 * e4 * 4 + 8, n3.rgbSliceByteLength, true), i3.setUint32(20 + 5 * e4 * 4 + 12, n3.alphaSliceByteOffset, true), i3.setUint32(20 + 5 * e4 * 4 + 16, n3.alphaSliceByteLength, true);
    }
    n2 = Fi([e3, t22.globalData.endpointsData, t22.globalData.selectorsData, t22.globalData.tablesData, t22.globalData.extendedData]);
  }
  const i22 = [];
  let s22 = t22.keyValue;
  e22.keepWriter || (s22 = Ci({}, t22.keyValue, { KTXwriter: "KTX-Parse v0.3.1" }));
  for (const t3 in s22) {
    const e3 = s22[t3], n3 = Vi(t3), a3 = typeof e3 == "string" ? Vi(e3) : e3, r3 = n3.byteLength + 1 + a3.byteLength + 1, o3 = r3 % 4 ? 4 - r3 % 4 : 0;
    i22.push(Fi([new Uint32Array([r3]), n3, Oi, a3, Oi, new Uint8Array(o3).fill(0)]));
  }
  const a2 = Fi(i22);
  if (t22.dataFormatDescriptor.length !== 1 || t22.dataFormatDescriptor[0].descriptorType !== 0)
    throw new Error("Only BASICFORMAT Data Format Descriptor output supported.");
  const r22 = t22.dataFormatDescriptor[0], o2 = new ArrayBuffer(28 + 16 * r22.samples.length), l2 = new DataView(o2), f22 = 24 + 16 * r22.samples.length;
  if (l2.setUint32(0, o2.byteLength, true), l2.setUint16(4, r22.vendorId, true), l2.setUint16(6, r22.descriptorType, true), l2.setUint16(8, r22.versionNumber, true), l2.setUint16(10, f22, true), l2.setUint8(12, r22.colorModel), l2.setUint8(13, r22.colorPrimaries), l2.setUint8(14, r22.transferFunction), l2.setUint8(15, r22.flags), !Array.isArray(r22.texelBlockDimension))
    throw new Error("texelBlockDimension is now an array. For dimensionality `d`, set `d - 1`.");
  l2.setUint8(16, r22.texelBlockDimension[0]), l2.setUint8(17, r22.texelBlockDimension[1]), l2.setUint8(18, r22.texelBlockDimension[2]), l2.setUint8(19, r22.texelBlockDimension[3]);
  for (let t3 = 0; t3 < 8; t3++)
    l2.setUint8(20 + t3, r22.bytesPlane[t3]);
  for (let t3 = 0; t3 < r22.samples.length; t3++) {
    const e3 = r22.samples[t3], n3 = 28 + 16 * t3;
    if (e3.channelID)
      throw new Error("channelID has been renamed to channelType.");
    l2.setUint16(n3 + 0, e3.bitOffset, true), l2.setUint8(n3 + 2, e3.bitLength), l2.setUint8(n3 + 3, e3.channelType), l2.setUint8(n3 + 4, e3.samplePosition[0]), l2.setUint8(n3 + 5, e3.samplePosition[1]), l2.setUint8(n3 + 6, e3.samplePosition[2]), l2.setUint8(n3 + 7, e3.samplePosition[3]), 64 & e3.channelType ? (l2.setInt32(n3 + 8, e3.sampleLower, true), l2.setInt32(n3 + 12, e3.sampleUpper, true)) : (l2.setUint32(n3 + 8, e3.sampleLower, true), l2.setUint32(n3 + 12, e3.sampleUpper, true));
  }
  const U2 = Ti.length + 68 + 3 * t22.levels.length * 8, c2 = U2 + o2.byteLength;
  let h22 = n2.byteLength > 0 ? c2 + a2.byteLength : 0;
  h22 % 8 && (h22 += 8 - h22 % 8);
  const _2 = [], p2 = new DataView(new ArrayBuffer(3 * t22.levels.length * 8));
  let g2 = (h22 || c2 + a2.byteLength) + n2.byteLength;
  for (let e3 = 0; e3 < t22.levels.length; e3++) {
    const n3 = t22.levels[e3];
    _2.push(n3.levelData), p2.setBigUint64(24 * e3 + 0, BigInt(g2), true), p2.setBigUint64(24 * e3 + 8, BigInt(n3.levelData.byteLength), true), p2.setBigUint64(24 * e3 + 16, BigInt(n3.uncompressedByteLength), true), g2 += n3.levelData.byteLength;
  }
  const y2 = new ArrayBuffer(68), x22 = new DataView(y2);
  return x22.setUint32(0, t22.vkFormat, true), x22.setUint32(4, t22.typeSize, true), x22.setUint32(8, t22.pixelWidth, true), x22.setUint32(12, t22.pixelHeight, true), x22.setUint32(16, t22.pixelDepth, true), x22.setUint32(20, t22.layerCount, true), x22.setUint32(24, t22.faceCount, true), x22.setUint32(28, t22.levels.length, true), x22.setUint32(32, t22.supercompressionScheme, true), x22.setUint32(36, U2, true), x22.setUint32(40, o2.byteLength, true), x22.setUint32(44, c2, true), x22.setUint32(48, a2.byteLength, true), x22.setBigUint64(52, BigInt(n2.byteLength > 0 ? h22 : 0), true), x22.setBigUint64(60, BigInt(n2.byteLength), true), new Uint8Array(Fi([new Uint8Array(Ti).buffer, y2, p2.buffer, o2, a2, h22 > 0 ? new ArrayBuffer(h22 - (c2 + a2.byteLength)) : new ArrayBuffer(0), n2, ..._2]));
}
function createDataTexture(container) {
  const { vkFormat, pixelWidth, pixelHeight, pixelDepth } = container;
  if (FORMAT_MAP[vkFormat] === void 0) {
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  }
  let view;
  const levelData = container.levels[0].levelData;
  if (TYPE_MAP[vkFormat] === FloatType) {
    view = new Float32Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Float32Array.BYTES_PER_ELEMENT);
  } else if (TYPE_MAP[vkFormat] === HalfFloatType) {
    view = new Uint16Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT);
  } else {
    view = levelData;
  }
  const texture = pixelDepth === 0 ? new DataTexture(view, pixelWidth, pixelHeight) : new Data3DTexture(view, pixelWidth, pixelHeight, pixelDepth);
  texture.type = TYPE_MAP[vkFormat];
  texture.format = FORMAT_MAP[vkFormat];
  texture.encoding = ENCODING_MAP[vkFormat] || LinearEncoding;
  texture.needsUpdate = true;
  return Promise.resolve(texture);
}
function getWorldSpaceHalfWidth(camera, distance, resolution) {
  _clipToWorldVector.set(0, 0, -distance, 1).applyMatrix4(camera.projectionMatrix);
  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
  _clipToWorldVector.x = _lineWidth / resolution.width;
  _clipToWorldVector.y = _lineWidth / resolution.height;
  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);
  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));
}
function raycastWorldUnits(lineSegments, intersects) {
  for (let i22 = 0, l2 = _instanceStart.count; i22 < l2; i22++) {
    _line.start.fromBufferAttribute(_instanceStart, i22);
    _line.end.fromBufferAttribute(_instanceEnd, i22);
    const pointOnLine = new Vector3();
    const point = new Vector3();
    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;
    if (isInside) {
      intersects.push({
        point,
        pointOnLine,
        distance: _ray.origin.distanceTo(point),
        object: lineSegments,
        face: null,
        faceIndex: i22,
        uv: null,
        uv2: null
      });
    }
  }
}
function raycastScreenSpace(lineSegments, camera, intersects) {
  const projectionMatrix = camera.projectionMatrix;
  const material = lineSegments.material;
  const resolution = material.resolution;
  const matrixWorld = lineSegments.matrixWorld;
  const geometry = lineSegments.geometry;
  const instanceStart = geometry.attributes.instanceStart;
  const instanceEnd = geometry.attributes.instanceEnd;
  const near = -camera.near;
  _ray.at(1, _ssOrigin);
  _ssOrigin.w = 1;
  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);
  _ssOrigin.applyMatrix4(projectionMatrix);
  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);
  _ssOrigin.x *= resolution.x / 2;
  _ssOrigin.y *= resolution.y / 2;
  _ssOrigin.z = 0;
  _ssOrigin3.copy(_ssOrigin);
  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);
  for (let i22 = 0, l2 = instanceStart.count; i22 < l2; i22++) {
    _start4.fromBufferAttribute(instanceStart, i22);
    _end4.fromBufferAttribute(instanceEnd, i22);
    _start4.w = 1;
    _end4.w = 1;
    _start4.applyMatrix4(_mvMatrix);
    _end4.applyMatrix4(_mvMatrix);
    const isBehindCameraNear = _start4.z > near && _end4.z > near;
    if (isBehindCameraNear) {
      continue;
    }
    if (_start4.z > near) {
      const deltaDist = _start4.z - _end4.z;
      const t22 = (_start4.z - near) / deltaDist;
      _start4.lerp(_end4, t22);
    } else if (_end4.z > near) {
      const deltaDist = _end4.z - _start4.z;
      const t22 = (_end4.z - near) / deltaDist;
      _end4.lerp(_start4, t22);
    }
    _start4.applyMatrix4(projectionMatrix);
    _end4.applyMatrix4(projectionMatrix);
    _start4.multiplyScalar(1 / _start4.w);
    _end4.multiplyScalar(1 / _end4.w);
    _start4.x *= resolution.x / 2;
    _start4.y *= resolution.y / 2;
    _end4.x *= resolution.x / 2;
    _end4.y *= resolution.y / 2;
    _line.start.copy(_start4);
    _line.start.z = 0;
    _line.end.copy(_end4);
    _line.end.z = 0;
    const param = _line.closestPointToPointParameter(_ssOrigin3, true);
    _line.at(param, _closestPoint);
    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);
    const isInClipSpace = zPos >= -1 && zPos <= 1;
    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;
    if (isInClipSpace && isInside) {
      _line.start.fromBufferAttribute(instanceStart, i22);
      _line.end.fromBufferAttribute(instanceEnd, i22);
      _line.start.applyMatrix4(matrixWorld);
      _line.end.applyMatrix4(matrixWorld);
      const pointOnLine = new Vector3();
      const point = new Vector3();
      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
      intersects.push({
        point,
        pointOnLine,
        distance: _ray.origin.distanceTo(point),
        object: lineSegments,
        face: null,
        faceIndex: i22,
        uv: null,
        uv2: null
      });
    }
  }
}
function useTexture(paths, options) {
  if (pathsIsString(paths)) {
    if (!browser)
      return new Texture();
    return convertTextureColor(loadTexture(paths, options));
  } else if (pathsIsArray(paths)) {
    if (!browser) {
      return paths.map(() => new Texture());
    }
    return paths.map((path) => convertTextureColor(loadTexture(path, options)));
  } else {
    const entries = Object.entries(paths);
    const map = entries.reduce((acc, [key2, value]) => {
      acc[key2] = browser ? loadTexture(value, options) : new Texture();
      return acc;
    }, {});
    return map;
  }
}
function cubicIn(t22) {
  return t22 * t22 * t22;
}
function is_date(obj) {
  return Object.prototype.toString.call(obj) === "[object Date]";
}
function tick_spring(ctx, last_value, current_value, target_value) {
  if (typeof current_value === "number" || is_date(current_value)) {
    const delta = target_value - current_value;
    const velocity = (current_value - last_value) / (ctx.dt || 1 / 60);
    const spring2 = ctx.opts.stiffness * delta;
    const damper = ctx.opts.damping * velocity;
    const acceleration = (spring2 - damper) * ctx.inv_mass;
    const d2 = (velocity + acceleration) * ctx.dt;
    if (Math.abs(d2) < ctx.opts.precision && Math.abs(delta) < ctx.opts.precision) {
      return target_value;
    } else {
      ctx.settled = false;
      return is_date(current_value) ? new Date(current_value.getTime() + d2) : current_value + d2;
    }
  } else if (Array.isArray(current_value)) {
    return current_value.map((_2, i22) => tick_spring(ctx, last_value[i22], current_value[i22], target_value[i22]));
  } else if (typeof current_value === "object") {
    const next_value = {};
    for (const k2 in current_value) {
      next_value[k2] = tick_spring(ctx, last_value[k2], current_value[k2], target_value[k2]);
    }
    return next_value;
  } else {
    throw new Error(`Cannot spring ${typeof current_value} values`);
  }
}
function spring(value, opts = {}) {
  const store = writable2(value);
  const { stiffness = 0.15, damping = 0.8, precision = 0.01 } = opts;
  let last_time;
  let task;
  let current_token;
  let last_value = value;
  let target_value = value;
  let inv_mass = 1;
  let inv_mass_recovery_rate = 0;
  let cancel_task = false;
  function set(new_value, opts2 = {}) {
    target_value = new_value;
    const token = current_token = {};
    if (value == null || opts2.hard || spring2.stiffness >= 1 && spring2.damping >= 1) {
      cancel_task = true;
      last_time = now();
      last_value = new_value;
      store.set(value = target_value);
      return Promise.resolve();
    } else if (opts2.soft) {
      const rate = opts2.soft === true ? 0.5 : +opts2.soft;
      inv_mass_recovery_rate = 1 / (rate * 60);
      inv_mass = 0;
    }
    if (!task) {
      last_time = now();
      cancel_task = false;
      task = loop((now22) => {
        if (cancel_task) {
          cancel_task = false;
          task = null;
          return false;
        }
        inv_mass = Math.min(inv_mass + inv_mass_recovery_rate, 1);
        const ctx = {
          inv_mass,
          opts: spring2,
          settled: true,
          dt: (now22 - last_time) * 60 / 1e3
        };
        const next_value = tick_spring(ctx, last_value, value, target_value);
        last_time = now22;
        last_value = value;
        store.set(value = next_value);
        if (ctx.settled) {
          task = null;
        }
        return !ctx.settled;
      });
    }
    return new Promise((fulfil) => {
      task.promise.then(() => {
        if (token === current_token)
          fulfil();
      });
    });
  }
  const spring2 = {
    set,
    update: (fn2, opts2) => set(fn2(target_value, value), opts2),
    subscribe: store.subscribe,
    stiffness,
    damping,
    precision
  };
  return spring2;
}
function get_interpolator(a2, b2) {
  if (a2 === b2 || a2 !== a2)
    return () => a2;
  const type = typeof a2;
  if (type !== typeof b2 || Array.isArray(a2) !== Array.isArray(b2)) {
    throw new Error("Cannot interpolate values of different type");
  }
  if (Array.isArray(a2)) {
    const arr = b2.map((bi2, i22) => {
      return get_interpolator(a2[i22], bi2);
    });
    return (t22) => arr.map((fn2) => fn2(t22));
  }
  if (type === "object") {
    if (!a2 || !b2)
      throw new Error("Object cannot be null");
    if (is_date(a2) && is_date(b2)) {
      a2 = a2.getTime();
      b2 = b2.getTime();
      const delta = b2 - a2;
      return (t22) => new Date(a2 + t22 * delta);
    }
    const keys = Object.keys(b2);
    const interpolators = {};
    keys.forEach((key2) => {
      interpolators[key2] = get_interpolator(a2[key2], b2[key2]);
    });
    return (t22) => {
      const result = {};
      keys.forEach((key2) => {
        result[key2] = interpolators[key2](t22);
      });
      return result;
    };
  }
  if (type === "number") {
    const delta = b2 - a2;
    return (t22) => a2 + t22 * delta;
  }
  throw new Error(`Cannot interpolate ${type} values`);
}
function tweened(value, defaults = {}) {
  const store = writable2(value);
  let task;
  let target_value = value;
  function set(new_value, opts) {
    if (value == null) {
      store.set(value = new_value);
      return Promise.resolve();
    }
    target_value = new_value;
    let previous_task = task;
    let started = false;
    let { delay = 0, duration = 400, easing = identity, interpolate = get_interpolator } = assign(assign({}, defaults), opts);
    if (duration === 0) {
      if (previous_task) {
        previous_task.abort();
        previous_task = null;
      }
      store.set(value = target_value);
      return Promise.resolve();
    }
    const start = now() + delay;
    let fn2;
    task = loop((now22) => {
      if (now22 < start)
        return true;
      if (!started) {
        fn2 = interpolate(value, new_value);
        if (typeof duration === "function")
          duration = duration(value, new_value);
        started = true;
      }
      if (previous_task) {
        previous_task.abort();
        previous_task = null;
      }
      const elapsed = now22 - start;
      if (elapsed > duration) {
        store.set(value = new_value);
        return false;
      }
      store.set(value = fn2(easing(elapsed / duration)));
      return true;
    });
    return task.promise;
  }
  return {
    set,
    update: (fn2, opts) => set(fn2(target_value, value), opts),
    subscribe: store.subscribe
  };
}
function cube(size) {
  const h22 = size * 0.5;
  const position = [];
  position.push([-h22, -h22, -h22], [-h22, h22, -h22], [h22, h22, -h22], [h22, -h22, -h22], [-h22, -h22, -h22], [-h22, -h22, h22], [-h22, h22, h22], [-h22, h22, -h22], [h22, -h22, h22], [h22, -h22, -h22], [-h22, h22, h22], [h22, h22, h22], [h22, -h22, h22], [-h22, -h22, h22], [h22, h22, -h22], [h22, h22, h22]);
  const newPos = Math.random() > 0.5 ? position : position.reverse();
  return newPos;
}
var ___ASSET___0, ___ASSET___1, paper, Writing_pad, Logo_anim, subscriber_queue2, logoActive, REVISION, MOUSE, TOUCH, PCFSoftShadowMap, FrontSide, BackSide, DoubleSide, FlatShading, NormalBlending, AddEquation, SrcAlphaFactor, OneMinusSrcAlphaFactor, LessEqualDepth, MultiplyOperation, NoToneMapping, ACESFilmicToneMapping, UVMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, LinearFilter, LinearMipmapLinearFilter, UnsignedByteType, FloatType, HalfFloatType, RGBAFormat, RedFormat, RGFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_BPTC_Format, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, AdditiveAnimationBlendMode, LinearEncoding, sRGBEncoding, TangentSpaceNormalMap, SRGBColorSpace, LinearSRGBColorSpace, KeepStencilOp, AlwaysStencilFunc, StaticDrawUsage, EventDispatcher, _lut, _seed, DEG2RAD, RAD2DEG, MathUtils, Vector2, Matrix3, FN, ColorManagement, _colorKeywords, _rgb, _hslA, _hslB, Color, _canvas, ImageUtils, Source, textureId, Texture, Vector4, Data3DTexture, Quaternion, Vector3, _vector$c, _quaternion$4, Box3, _points, _vector$b, _box$3, _v0$2, _v1$7, _v2$3, _f0, _f1, _f2, _center, _extents, _triangleNormal, _testAxis, _box$2, _v1$6, _toFarthestPoint, _toPoint, Sphere, _vector$a, _segCenter, _segDir, _diff, _edge1, _edge2, _normal$1, Ray, Matrix4, _v1$5, _m1$2, _zero, _one, _x, _y, _z, _matrix$1, _quaternion$3, Euler, Layers, _object3DId, _v1$4, _q1, _m1$1, _target, _position$3, _scale$2, _quaternion$2, _xAxis, _yAxis, _zAxis, _addedEvent, _removedEvent, Object3D, _v0$1, _v1$3, _v2$2, _v3$1, _vab, _vac, _vbc, _vap, _vbp, _vcp, Triangle, materialId, Material, MeshBasicMaterial, _vector$9, _vector2$1, BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute, Float32BufferAttribute, _id$1, _m1, _obj, _offset, _box$1$1, _boxMorphTargets, _vector$8, BufferGeometry, _inverseMatrix$2, _ray$2, _sphere$3, _vA$1, _vB$1, _vC$1, _tempA, _tempB, _tempC, _morphA, _morphB, _morphC, _uvA$1, _uvB$1, _uvC$1, _intersectionPoint, _intersectionPointWorld, Mesh$1, BoxGeometry, UniformsUtils, default_vertex, default_fragment, ShaderMaterial, Camera, PerspectiveCamera$1, _vector1, _vector2, _normalMatrix, Plane, _sphere$2, _vector$7, Frustum, PlaneGeometry, alphamap_fragment, alphamap_pars_fragment, alphatest_fragment, alphatest_pars_fragment, aomap_fragment, aomap_pars_fragment, begin_vertex, beginnormal_vertex, bsdfs, iridescence_fragment, bumpmap_pars_fragment, clipping_planes_fragment, clipping_planes_pars_fragment, clipping_planes_pars_vertex, clipping_planes_vertex, color_fragment, color_pars_fragment, color_pars_vertex, color_vertex, common, cube_uv_reflection_fragment, defaultnormal_vertex, displacementmap_pars_vertex, displacementmap_vertex, emissivemap_fragment, emissivemap_pars_fragment, encodings_fragment, encodings_pars_fragment, envmap_fragment, envmap_common_pars_fragment, envmap_pars_fragment, envmap_pars_vertex, envmap_vertex, fog_vertex, fog_pars_vertex, fog_fragment, fog_pars_fragment, gradientmap_pars_fragment, lightmap_fragment, lightmap_pars_fragment, lights_lambert_vertex, lights_pars_begin, envmap_physical_pars_fragment, lights_toon_fragment, lights_toon_pars_fragment, lights_phong_fragment, lights_phong_pars_fragment, lights_physical_fragment, lights_physical_pars_fragment, lights_fragment_begin, lights_fragment_maps, lights_fragment_end, logdepthbuf_fragment, logdepthbuf_pars_fragment, logdepthbuf_pars_vertex, logdepthbuf_vertex, map_fragment, map_pars_fragment, map_particle_fragment, map_particle_pars_fragment, metalnessmap_fragment, metalnessmap_pars_fragment, morphcolor_vertex, morphnormal_vertex, morphtarget_pars_vertex, morphtarget_vertex, normal_fragment_begin, normal_fragment_maps, normal_pars_fragment, normal_pars_vertex, normal_vertex, normalmap_pars_fragment, clearcoat_normal_fragment_begin, clearcoat_normal_fragment_maps, clearcoat_pars_fragment, iridescence_pars_fragment, output_fragment, packing, premultiplied_alpha_fragment, project_vertex, dithering_fragment, dithering_pars_fragment, roughnessmap_fragment, roughnessmap_pars_fragment, shadowmap_pars_fragment, shadowmap_pars_vertex, shadowmap_vertex, shadowmask_pars_fragment, skinbase_vertex, skinning_pars_vertex, skinning_vertex, skinnormal_vertex, specularmap_fragment, specularmap_pars_fragment, tonemapping_fragment, tonemapping_pars_fragment, transmission_fragment, transmission_pars_fragment, uv_pars_fragment, uv_pars_vertex, uv_vertex, uv2_pars_fragment, uv2_pars_vertex, uv2_vertex, worldpos_vertex, vertex$g, fragment$g, vertex$f, fragment$f, vertex$e, fragment$e, vertex$d, fragment$d, vertex$c, fragment$c, vertex$b, fragment$b, vertex$a, fragment$a, vertex$9, fragment$9, vertex$8, fragment$8, vertex$7, fragment$7, vertex$6, fragment$6, vertex$5, fragment$5, vertex$4, fragment$4, vertex$3, fragment$3, vertex$2, fragment$2, vertex$1, fragment$1, ShaderChunk, UniformsLib, ShaderLib, OrthographicCamera, Group$1, Scene, InterleavedBuffer, _vector$6, InterleavedBufferAttribute, DataTexture, CompressedTexture, WireframeGeometry, MeshPhongMaterial, AnimationUtils, Interpolant, CubicInterpolant, LinearInterpolant, DiscreteInterpolant, KeyframeTrack, BooleanKeyframeTrack, ColorKeyframeTrack, NumberKeyframeTrack, QuaternionLinearInterpolant, QuaternionKeyframeTrack, StringKeyframeTrack, VectorKeyframeTrack, Cache, LoadingManager, DefaultLoadingManager, Loader, loading, FileLoader, ImageLoader, TextureLoader, Light, _projScreenMatrix$1, _lightPositionWorld$1, _lookTarget$1, LightShadow, SpotLightShadow, SpotLight$1, AmbientLight$1, InstancedBufferGeometry, Clock, _RESERVED_CHARS_RE, _reservedRe, _wordChar, _wordCharOrDot, _directoryRe, _nodeRe, _objectRe, _propertyRe, _trackRe, _supportedObjectNames, Composite, PropertyBinding, InstancedInterleavedBuffer, Raycaster, Spherical, _startP, _startEnd, Line3, Pass, _geometry$1, _geometry, RenderPass, setRendererColorOutput, setRendererAndComposerSize, setRendererShadows, getThrelteUserData, setPointerFromEvent, runRaycaster, targetChanged, useEventRaycast, useFrameloopRaycast, browser, useRaf, runFrameloopCallbacks, debugFrame, useFrameloop, getDefaultCamera, setDefaultCameraAspectOnSizeChange, createContexts, useParentSize, css3, invalidationHandlers, invalidateGlobally, Canvas, useThrelte, useThrelteRoot, createObjectStore, setParent, getParent, HierarchicalObject, LayerableObject, useFrame, useTicked, TransformableObject, ViewportAwareObject, Object3DInstance, CameraInstance, PerspectiveCamera, loaders, useLoader, _changeEvent$1, _startEvent, _endEvent, OrbitControls$1, OrbitControls, _raycaster, _tempVector, _tempVector2, _tempQuaternion, _unit, _tempEuler, _alignVector, _zeroVector, _lookAtMatrix, _tempQuaternion2, _identityQuaternion, _dirVector, _tempMatrix, _unitX, _unitY, _unitZ, _v1, _v2, _v3, convertColorRepresentationToColor, LightInstance, AmbientLight, SpotLight, InteractiveObject, MeshInstance, Mesh, placeholderObject3D, Group, _q, WorkerPool, t2, e2, n, i2, s3, a, r2, o, l, f3, U, c, h2, _, p, g, y, x2, u, b, d, m2, w, D, B, L, A2, k, v, S2, I, O, T, V, E, F2, P, C, z, M, W, N, H, K, X, j, R, Y, q, G, J, Q, Z2, $, tt, et, nt, it, st, at, rt, ot, lt, ft, Ut, ct, ht, _t, pt, gt, yt, xt, ut, bt, dt, mt, wt, Dt, Bt, Lt, At, kt, vt, St, It, Ot, Tt, Vt, Et, Ft, Pt, Ct, zt, Mt, Wt, Nt, Ht, Kt, Xt, jt, Rt, Yt, qt, Gt, Jt, Qt, Zt, $t, te, ee, ne, ie, se, ae, re, oe, le, fe, Ue, ce, he, _e, pe, ge, ye, xe, ue, be, de, me, we, De, Be, Le, Ae, ke, ve, Se, Ie, Oe, Te, Ve, Ee, Fe, Pe, Ce, ze, Me, We, Ne, He, Ke, Xe, je, Re, Ye, qe, Ge, Je, Qe, Ze, $e, tn, en, nn, sn, an, rn, on, ln, fn, Un, cn, hn, _n, pn, gn, yn, xn, un, bn, dn, mn, wn, Dn, Bn, Ln, An, kn, vn, Sn, In, On, Tn, Vn, En, Fn, Pn, Cn, zn, Mn, Wn, Nn, Hn, Kn, Xn, jn, Rn, Yn, qn, Gn, Jn, Qn, Zn, $n, ti, ei, ni, ii, si, ai, ri, oi, li, fi, Ui, ci, hi, _i, pi, gi, yi, xi, ui, bi, di, mi, wi, Di, Bi, Li, Ai, ki, vi, Si, Ii, Oi, Ti, zi, KTX, read2, KHR_DF_FLAG_ALPHA_PREMULTIPLIED, KHR_DF_TRANSFER_SRGB, VK_FORMAT_UNDEFINED, VK_FORMAT_R16_SFLOAT, VK_FORMAT_R16G16_SFLOAT, VK_FORMAT_R16G16B16A16_SFLOAT, VK_FORMAT_R32_SFLOAT, VK_FORMAT_R32G32_SFLOAT, VK_FORMAT_R32G32B32A32_SFLOAT, VK_FORMAT_R8_SRGB, VK_FORMAT_R8_UNORM, VK_FORMAT_R8G8_SRGB, VK_FORMAT_R8G8_UNORM, VK_FORMAT_R8G8B8A8_SRGB, VK_FORMAT_R8G8B8A8_UNORM, _taskCache, _activeLoaders, KTX2Loader, FORMAT_MAP, TYPE_MAP, ENCODING_MAP, _box$1, _vector, LineSegmentsGeometry, LineGeometry, LineMaterial, _start, _end, _start4, _end4, _ssOrigin, _ssOrigin3, _mvMatrix, _line, _closestPoint, _box, _sphere, _clipToWorldVector, _ray, _instanceStart, _instanceEnd, _lineWidth, LineSegments2, Line2$1, Line2, loader, loadTexture, pathsIsString, pathsIsArray, convertTextureColor, px, px_upside, py, pz, ny, nz, o_px, o_px_transparent, o_px_upside, o_px_upside_transparent, o_ny, o_transparent, useCursor, SHOW_INSIDE, Game, Routes;
var init_index_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/index.svelte.js"() {
    init_shims();
    init_index_7a55addd();
    init_page_0c511438();
    init_github_button_7b97a99c();
    ___ASSET___0 = "/_app/immutable/assets/appstore-3c23a8b2.svg";
    ___ASSET___1 = "/_app/immutable/assets/homepage_image2-3c55d2db.webp";
    paper = "/_app/immutable/assets/paper-e7c3e2b8.jpg";
    Writing_pad = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let pageWidth;
      let lineHeight;
      let fontSize;
      let paddingTop;
      let paddingLeft;
      let { size } = $$props;
      let textarea;
      console.log("HI");
      if ($$props.size === void 0 && $$bindings.size && size !== void 0)
        $$bindings.size(size);
      pageWidth = size * 50;
      lineHeight = pageWidth / 12.2;
      fontSize = size * 2.5;
      paddingTop = lineHeight - fontSize * 1.3;
      paddingLeft = pageWidth / 15;
      return `<div class="${"aspect-[9/14] relative overflow-hidden rounded-md shadow-lg"}"${add_attribute("style", `width: ${pageWidth}px`, 0)}><textarea wrap="${"hard"}" rows="${"5"}" cols="${"33"}" autocorrect="${"off"}"${add_attribute("style", `line-height: ${lineHeight}px; font-size: ${fontSize}px; padding-left: ${paddingLeft}px; padding-top: ${paddingTop}px;`, 0)} spellcheck="${"false"}" class="${"overflow-hidden absolute top-0 left-0 w-full h-full bg-transparent border-none outline-none resize-none"}"${add_attribute("this", textarea, 0)}></textarea>
  <img${add_attribute("src", paper, 0)} class="${"z-[-1] absolute top-0 left-0 w-full h-full"}"></div>`;
    });
    Logo_anim = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { active } = $$props;
      if ($$props.active === void 0 && $$bindings.active && active !== void 0)
        $$bindings.active(active);
      return `<div style="${"width: 400px; height: 400px; display: flex; align-content: center; justify-content: center; align-items: center"}"><svg style="${"width: 350px; height: 350px; cursor: pointer"}" viewBox="${"-14 -15 116 116"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}"${add_classes(((active <= 1 ? "svg1" : "") + " " + (active > 1 ? "svg2" : "") + " " + (active === 1 || active === 3 ? "active" : "")).trim())}><path d="${"M0.5 11.5L43.8621 21.6089L87.4409 11.3847L43.9549 1.5L0.5 11.5Z"}" fill="${"#6874E8"}" class="${"svg-elem-1"}"></path><path d="${"M43.9459 81.6974L87.2968 70.9561L87.4409 11.3847L43.8621 21.6089V52.4493L43.9459 81.6974Z"}" fill="${"#6874E8"}" class="${"svg-elem-2"}"></path><path d="${"M0.5 11.5V71L43.9459 81.6974L43.8621 52.4493V21.6089L0.5 11.5Z"}" fill="${"#6874E8"}" class="${"svg-elem-3"}"></path><path d="${"M0.5 11.5V71L43.9459 81.6974M0.5 11.5L43.8621 21.6089M0.5 11.5L43.9549 1.5L87.4409 11.3847M43.9459 81.6974L87.2968 70.9561L87.4409 11.3847M43.9459 81.6974L43.8621 52.4493V21.6089M87.4409 11.3847L43.8621 21.6089"}" stroke="${"#C3C8E5"}" class="${"svg-elem-4"}"></path><mask id="${"path-3-inside-1_1075_131"}" fill="${"white"}"><path d="${"M21.2723 69.1026L10.5 66.6026L10.5 22.1026L21.2723 69.1026ZM21.0991 55.6585L21.2723 69.1026L10.5 22.1026L21.0991 55.6585ZM26.3046 56.9791L23.4583 56.2227L21.0991 55.6585L10.5 22.1026L26.3046 56.9791ZM10.5 22.1026L21.1559 36.68L21.1302 44.2635L10.5 22.1026ZM26.3046 56.9791L10.5 22.1026L21.1302 44.2635L26.3046 56.9791ZM23.3471 37.266L21.1559 36.68L10.5 22.1026L23.3471 37.266ZM26.3046 56.9791L25.0481 56.5945L21.0991 55.6585L23.4583 56.2227L26.3046 56.9791ZM23.5322 37.3266L23.3471 37.266L10.5 22.1026L23.5322 37.3266ZM23.7195 37.404L23.5322 37.3266L10.5 22.1026L23.7195 37.404ZM23.9073 37.4971L23.7195 37.404L10.5 22.1026L23.9073 37.4971ZM24.072 37.5787L23.9073 37.4971L10.5 22.1026L24.072 37.5787ZM26.3046 56.9791L21.1302 44.2635L22.7427 44.7126L26.3046 56.9791ZM24.2404 37.6657L24.072 37.5787L10.5 22.1026L24.2404 37.6657ZM24.4204 37.799L24.2404 37.6657L10.5 22.1026L24.4204 37.799ZM24.5946 37.9436L24.4204 37.799L10.5 22.1026L24.5946 37.9436ZM24.7614 38.0981L24.5946 37.9436L10.5 22.1026L24.7614 38.0981ZM24.9219 38.2305L24.7614 38.0981L10.5 22.1026L24.9219 38.2305ZM25.0825 38.4147L24.9219 38.2305L10.5 22.1026L25.0825 38.4147ZM26.3046 56.9791L22.7427 44.7126L23.0037 44.7725L26.3046 56.9791ZM26.3046 56.9791L23.0037 44.7725L23.1833 44.7939L26.3046 56.9791ZM26.3046 56.9791L23.1833 44.7939L23.3672 44.8067L26.3046 56.9791ZM26.3046 56.9791L23.3672 44.8067L23.5597 44.8196L26.3046 56.9791ZM26.3046 56.9791L23.5597 44.8196L23.7137 44.8153L26.3046 56.9791ZM26.3046 56.9791L23.7137 44.8153L23.9062 44.8153L26.3046 56.9791ZM26.3046 56.9791L23.9062 44.8153L24.0943 44.8067L26.3046 56.9791ZM26.3046 56.9791L24.0943 44.8067L24.3382 44.7854L26.3046 56.9791ZM26.3046 56.9791L24.3382 44.7854L24.5777 44.7469L26.3046 56.9791ZM27.5483 57.2484L26.9841 57.1201L26.3046 56.9791L27.5483 57.2484ZM26.3046 56.9791L24.5777 44.7469L24.7109 44.707L26.3046 56.9791ZM26.3046 56.9791L24.7109 44.707L24.8359 44.6336L26.3046 56.9791ZM29.0773 57.3299L28.1894 57.2227L27.5483 57.2484L26.3046 56.9791L27.5821 57.186L28.152 57.3475L29.0773 57.3299ZM29.0773 57.3299L28.0622 57.3318L27.5483 57.2484L28.1894 57.2227L29.0773 57.3299ZM10.5 22.1026L24.5906 25.2998L25.6892 25.6437L10.5 22.1026ZM31.3837 56.8316L29.0773 57.3299L28.152 57.3475L27.5821 57.186L26.3046 56.9791L31.3837 56.8316ZM10.5 22.1026L25.6892 25.6437L27.8058 26.5113L10.5 22.1026ZM30.0997 57.2099L29.3946 57.2996L29.0773 57.3299L30.0997 57.2099ZM25.0825 38.4147L10.5 22.1026L35.3264 35.9485L25.0825 38.4147ZM31.3837 56.8316L30.7682 57.0368L30.0997 57.2099L29.0773 57.3299L31.3837 56.8316ZM10.5 22.1026L27.8058 26.5113L30.7664 28.5927L10.5 22.1026ZM35.3264 35.9485L26.3046 56.9791L24.8359 44.6336L35.3264 35.9485ZM35.3052 52.5301L31.3837 56.8316L26.3046 56.9791L35.3052 52.5301ZM35.3264 35.9485L24.8359 44.6336L25.0469 44.5117L35.3264 35.9485ZM35.3264 35.9485L25.0469 44.5117L25.25 44.3516L35.3264 35.9485ZM32.523 56.1714L31.9204 56.5432L31.3837 56.8316L32.523 56.1714ZM35.3264 35.9485L25.25 44.3516L25.4453 44.1445L35.3264 35.9485ZM35.3264 35.9485L25.4453 44.1445L25.5938 43.9492L35.3264 35.9485ZM35.3264 35.9485L25.5938 43.9492L25.7009 43.7813L35.3264 35.9485ZM10.5 22.1026L30.7664 28.5927L35.3264 35.9485L10.5 22.1026ZM35.3264 35.9485L25.7009 43.7813L25.8027 43.6032L35.3264 35.9485ZM35.3264 35.9485L25.8027 43.6032L25.8686 43.4161L35.3264 35.9485ZM35.3264 35.9485L25.8686 43.4161L25.9246 43.1971L35.3264 35.9485ZM35.3264 35.9485L25.9246 43.1971L25.9722 42.958L35.3264 35.9485ZM35.3264 35.9485L25.9722 42.958L26.0107 42.6981L35.3264 35.9485ZM35.3264 35.9485L26.0107 42.6981L26.0393 42.4167L35.3264 35.9485ZM25.2174 38.5922L25.0825 38.4147L35.3264 35.9485L25.2174 38.5922ZM26.0393 42.4167L26.0573 42.1132L35.3264 35.9485L26.0393 42.4167ZM33.7282 55.0816L33.1043 55.613L32.523 56.1714L31.3837 56.8316L33.7282 55.0816ZM25.3385 38.7751L25.2174 38.5922L35.3264 35.9485L25.3385 38.7751ZM25.4313 38.929L25.3385 38.7751L35.3264 35.9485L25.4313 38.929ZM26.0573 42.1132L26.0639 41.7868L35.3264 35.9485L26.0573 42.1132ZM25.5352 39.0977L25.4313 38.929L35.3264 35.9485L25.5352 39.0977ZM26.0639 41.7868L26.0571 41.4406L35.3264 35.9485L26.0639 41.7868ZM25.6328 39.2891L25.5352 39.0977L35.3264 35.9485L25.6328 39.2891ZM26.0571 41.4406L26.0359 41.1122L35.3264 35.9485L26.0571 41.4406ZM25.7227 39.4922L25.6328 39.2891L35.3264 35.9485L25.7227 39.4922ZM26.0359 41.1122L26.0195 40.7969L35.3264 35.9485L26.0359 41.1122ZM25.7933 39.6672L25.7227 39.4922L35.3264 35.9485L25.7933 39.6672ZM25.8867 39.9492L25.7933 39.6672L35.3264 35.9485L25.8867 39.9492ZM26.0195 40.7969L25.9961 40.5L35.3264 35.9485L26.0195 40.7969ZM25.9553 40.2576L25.8867 39.9492L35.3264 35.9485L25.9553 40.2576ZM25.9961 40.5L25.9553 40.2576L35.3264 35.9485L25.9961 40.5ZM33.7282 55.0816L33.189 55.6563L32.523 56.1714L33.1043 55.613L33.7282 55.0816ZM25.6892 25.6437L26.7918 26.0156L27.8058 26.5113L25.6892 25.6437ZM35.3052 52.5301L33.7282 55.0816L31.3837 56.8316L35.3052 52.5301ZM35.3264 35.9485L35.3052 52.5301L26.3046 56.9791L35.3264 35.9485ZM34.6257 53.8507L34.2419 54.481L33.7282 55.0816L34.1513 54.479L34.6257 53.8507ZM35.3052 52.5301L34.6257 53.8507L34.1513 54.479L33.7282 55.0816L35.3052 52.5301ZM27.8058 26.5113L28.5868 26.9772L29.3914 27.5035L28.5607 27.0385L27.8058 26.5113ZM35.3052 52.5301L35.0117 53.1719L34.6257 53.8507L35.3052 52.5301ZM27.8058 26.5113L28.5607 27.0385L29.3914 27.5035L30.7664 28.5927L27.8058 26.5113ZM29.3914 27.5035L30.1135 28.085L30.7664 28.5927L29.3914 27.5035ZM36.3101 48.5659L36.1359 49.4813L35.9463 50.4274L35.6514 51.53L35.3052 52.5301L36.3101 48.5659ZM30.7664 28.5927L31.4203 29.2337L31.9588 29.862L30.7664 28.5927ZM36.6258 44.786L36.5108 46.7529L36.3101 48.5659L35.3052 52.5301L36.6258 44.786ZM30.7664 28.5927L31.9588 29.862L32.5112 30.483L33.0102 31.2082L30.7664 28.5927ZM36.5192 46.7033L36.4255 47.6037L36.3101 48.5659L36.5192 46.7033ZM35.3264 35.9485L36.5 39.9271L36.6258 44.786L35.3052 52.5301L35.3264 35.9485ZM30.7664 28.5927L33.0102 31.2082L34.3308 33.5161L34.6808 34.2258L35.0038 34.9807L35.3264 35.9485L30.7664 28.5927ZM36.6258 44.786L36.613 45.722L36.5192 46.7033L36.3101 48.5659L36.5108 46.7529L36.6258 44.786ZM36.6258 44.786L36.5873 45.6579L36.5192 46.7033L36.613 45.722L36.6258 44.786ZM33.0102 31.2082L33.6443 32.236L34.3308 33.5161L33.0102 31.2082ZM36.5536 42.6536L36.5873 43.709L36.6258 44.786L36.5536 42.6536ZM36.2661 40.2967L36.5745 41.6576L36.5536 42.6536L36.6258 44.786L36.2661 40.2967ZM35.3264 35.9485L35.8615 37.937L36.2661 40.2967L36.6258 44.786L36.5 39.9271L35.3264 35.9485ZM36.2661 40.2967L36.4436 41.6036L36.5536 42.6536L36.5745 41.6576L36.2661 40.2967ZM35.3264 35.9485L35.6394 37.0303L35.8615 37.937L35.3264 35.9485ZM35.8615 37.937L36.1614 39.4844L36.2661 40.2967L35.8615 37.937Z"}" class="${"svg-elem-5"}"></path></mask><path d="${"M21.2723 69.1026L10.5 66.6026L10.5 22.1026L21.2723 69.1026ZM21.0991 55.6585L21.2723 69.1026L10.5 22.1026L21.0991 55.6585ZM26.3046 56.9791L23.4583 56.2227L21.0991 55.6585L10.5 22.1026L26.3046 56.9791ZM10.5 22.1026L21.1559 36.68L21.1302 44.2635L10.5 22.1026ZM26.3046 56.9791L10.5 22.1026L21.1302 44.2635L26.3046 56.9791ZM23.3471 37.266L21.1559 36.68L10.5 22.1026L23.3471 37.266ZM26.3046 56.9791L25.0481 56.5945L21.0991 55.6585L23.4583 56.2227L26.3046 56.9791ZM23.5322 37.3266L23.3471 37.266L10.5 22.1026L23.5322 37.3266ZM23.7195 37.404L23.5322 37.3266L10.5 22.1026L23.7195 37.404ZM23.9073 37.4971L23.7195 37.404L10.5 22.1026L23.9073 37.4971ZM24.072 37.5787L23.9073 37.4971L10.5 22.1026L24.072 37.5787ZM26.3046 56.9791L21.1302 44.2635L22.7427 44.7126L26.3046 56.9791ZM24.2404 37.6657L24.072 37.5787L10.5 22.1026L24.2404 37.6657ZM24.4204 37.799L24.2404 37.6657L10.5 22.1026L24.4204 37.799ZM24.5946 37.9436L24.4204 37.799L10.5 22.1026L24.5946 37.9436ZM24.7614 38.0981L24.5946 37.9436L10.5 22.1026L24.7614 38.0981ZM24.9219 38.2305L24.7614 38.0981L10.5 22.1026L24.9219 38.2305ZM25.0825 38.4147L24.9219 38.2305L10.5 22.1026L25.0825 38.4147ZM26.3046 56.9791L22.7427 44.7126L23.0037 44.7725L26.3046 56.9791ZM26.3046 56.9791L23.0037 44.7725L23.1833 44.7939L26.3046 56.9791ZM26.3046 56.9791L23.1833 44.7939L23.3672 44.8067L26.3046 56.9791ZM26.3046 56.9791L23.3672 44.8067L23.5597 44.8196L26.3046 56.9791ZM26.3046 56.9791L23.5597 44.8196L23.7137 44.8153L26.3046 56.9791ZM26.3046 56.9791L23.7137 44.8153L23.9062 44.8153L26.3046 56.9791ZM26.3046 56.9791L23.9062 44.8153L24.0943 44.8067L26.3046 56.9791ZM26.3046 56.9791L24.0943 44.8067L24.3382 44.7854L26.3046 56.9791ZM26.3046 56.9791L24.3382 44.7854L24.5777 44.7469L26.3046 56.9791ZM27.5483 57.2484L26.9841 57.1201L26.3046 56.9791L27.5483 57.2484ZM26.3046 56.9791L24.5777 44.7469L24.7109 44.707L26.3046 56.9791ZM26.3046 56.9791L24.7109 44.707L24.8359 44.6336L26.3046 56.9791ZM29.0773 57.3299L28.1894 57.2227L27.5483 57.2484L26.3046 56.9791L27.5821 57.186L28.152 57.3475L29.0773 57.3299ZM29.0773 57.3299L28.0622 57.3318L27.5483 57.2484L28.1894 57.2227L29.0773 57.3299ZM10.5 22.1026L24.5906 25.2998L25.6892 25.6437L10.5 22.1026ZM31.3837 56.8316L29.0773 57.3299L28.152 57.3475L27.5821 57.186L26.3046 56.9791L31.3837 56.8316ZM10.5 22.1026L25.6892 25.6437L27.8058 26.5113L10.5 22.1026ZM30.0997 57.2099L29.3946 57.2996L29.0773 57.3299L30.0997 57.2099ZM25.0825 38.4147L10.5 22.1026L35.3264 35.9485L25.0825 38.4147ZM31.3837 56.8316L30.7682 57.0368L30.0997 57.2099L29.0773 57.3299L31.3837 56.8316ZM10.5 22.1026L27.8058 26.5113L30.7664 28.5927L10.5 22.1026ZM35.3264 35.9485L26.3046 56.9791L24.8359 44.6336L35.3264 35.9485ZM35.3052 52.5301L31.3837 56.8316L26.3046 56.9791L35.3052 52.5301ZM35.3264 35.9485L24.8359 44.6336L25.0469 44.5117L35.3264 35.9485ZM35.3264 35.9485L25.0469 44.5117L25.25 44.3516L35.3264 35.9485ZM32.523 56.1714L31.9204 56.5432L31.3837 56.8316L32.523 56.1714ZM35.3264 35.9485L25.25 44.3516L25.4453 44.1445L35.3264 35.9485ZM35.3264 35.9485L25.4453 44.1445L25.5938 43.9492L35.3264 35.9485ZM35.3264 35.9485L25.5938 43.9492L25.7009 43.7813L35.3264 35.9485ZM10.5 22.1026L30.7664 28.5927L35.3264 35.9485L10.5 22.1026ZM35.3264 35.9485L25.7009 43.7813L25.8027 43.6032L35.3264 35.9485ZM35.3264 35.9485L25.8027 43.6032L25.8686 43.4161L35.3264 35.9485ZM35.3264 35.9485L25.8686 43.4161L25.9246 43.1971L35.3264 35.9485ZM35.3264 35.9485L25.9246 43.1971L25.9722 42.958L35.3264 35.9485ZM35.3264 35.9485L25.9722 42.958L26.0107 42.6981L35.3264 35.9485ZM35.3264 35.9485L26.0107 42.6981L26.0393 42.4167L35.3264 35.9485ZM25.2174 38.5922L25.0825 38.4147L35.3264 35.9485L25.2174 38.5922ZM26.0393 42.4167L26.0573 42.1132L35.3264 35.9485L26.0393 42.4167ZM33.7282 55.0816L33.1043 55.613L32.523 56.1714L31.3837 56.8316L33.7282 55.0816ZM25.3385 38.7751L25.2174 38.5922L35.3264 35.9485L25.3385 38.7751ZM25.4313 38.929L25.3385 38.7751L35.3264 35.9485L25.4313 38.929ZM26.0573 42.1132L26.0639 41.7868L35.3264 35.9485L26.0573 42.1132ZM25.5352 39.0977L25.4313 38.929L35.3264 35.9485L25.5352 39.0977ZM26.0639 41.7868L26.0571 41.4406L35.3264 35.9485L26.0639 41.7868ZM25.6328 39.2891L25.5352 39.0977L35.3264 35.9485L25.6328 39.2891ZM26.0571 41.4406L26.0359 41.1122L35.3264 35.9485L26.0571 41.4406ZM25.7227 39.4922L25.6328 39.2891L35.3264 35.9485L25.7227 39.4922ZM26.0359 41.1122L26.0195 40.7969L35.3264 35.9485L26.0359 41.1122ZM25.7933 39.6672L25.7227 39.4922L35.3264 35.9485L25.7933 39.6672ZM25.8867 39.9492L25.7933 39.6672L35.3264 35.9485L25.8867 39.9492ZM26.0195 40.7969L25.9961 40.5L35.3264 35.9485L26.0195 40.7969ZM25.9553 40.2576L25.8867 39.9492L35.3264 35.9485L25.9553 40.2576ZM25.9961 40.5L25.9553 40.2576L35.3264 35.9485L25.9961 40.5ZM33.7282 55.0816L33.189 55.6563L32.523 56.1714L33.1043 55.613L33.7282 55.0816ZM25.6892 25.6437L26.7918 26.0156L27.8058 26.5113L25.6892 25.6437ZM35.3052 52.5301L33.7282 55.0816L31.3837 56.8316L35.3052 52.5301ZM35.3264 35.9485L35.3052 52.5301L26.3046 56.9791L35.3264 35.9485ZM34.6257 53.8507L34.2419 54.481L33.7282 55.0816L34.1513 54.479L34.6257 53.8507ZM35.3052 52.5301L34.6257 53.8507L34.1513 54.479L33.7282 55.0816L35.3052 52.5301ZM27.8058 26.5113L28.5868 26.9772L29.3914 27.5035L28.5607 27.0385L27.8058 26.5113ZM35.3052 52.5301L35.0117 53.1719L34.6257 53.8507L35.3052 52.5301ZM27.8058 26.5113L28.5607 27.0385L29.3914 27.5035L30.7664 28.5927L27.8058 26.5113ZM29.3914 27.5035L30.1135 28.085L30.7664 28.5927L29.3914 27.5035ZM36.3101 48.5659L36.1359 49.4813L35.9463 50.4274L35.6514 51.53L35.3052 52.5301L36.3101 48.5659ZM30.7664 28.5927L31.4203 29.2337L31.9588 29.862L30.7664 28.5927ZM36.6258 44.786L36.5108 46.7529L36.3101 48.5659L35.3052 52.5301L36.6258 44.786ZM30.7664 28.5927L31.9588 29.862L32.5112 30.483L33.0102 31.2082L30.7664 28.5927ZM36.5192 46.7033L36.4255 47.6037L36.3101 48.5659L36.5192 46.7033ZM35.3264 35.9485L36.5 39.9271L36.6258 44.786L35.3052 52.5301L35.3264 35.9485ZM30.7664 28.5927L33.0102 31.2082L34.3308 33.5161L34.6808 34.2258L35.0038 34.9807L35.3264 35.9485L30.7664 28.5927ZM36.6258 44.786L36.613 45.722L36.5192 46.7033L36.3101 48.5659L36.5108 46.7529L36.6258 44.786ZM36.6258 44.786L36.5873 45.6579L36.5192 46.7033L36.613 45.722L36.6258 44.786ZM33.0102 31.2082L33.6443 32.236L34.3308 33.5161L33.0102 31.2082ZM36.5536 42.6536L36.5873 43.709L36.6258 44.786L36.5536 42.6536ZM36.2661 40.2967L36.5745 41.6576L36.5536 42.6536L36.6258 44.786L36.2661 40.2967ZM35.3264 35.9485L35.8615 37.937L36.2661 40.2967L36.6258 44.786L36.5 39.9271L35.3264 35.9485ZM36.2661 40.2967L36.4436 41.6036L36.5536 42.6536L36.5745 41.6576L36.2661 40.2967ZM35.3264 35.9485L35.6394 37.0303L35.8615 37.937L35.3264 35.9485ZM35.8615 37.937L36.1614 39.4844L36.2661 40.2967L35.8615 37.937Z"}" fill="${"white"}" class="${"svg-elem-6"}"></path><path d="${"M10.5 22.1026L10.6135 21.6156L9.83376 21.4338L10.0126 22.2143L10.5 22.1026ZM21.0991 55.6585L20.6224 55.8091L20.7076 56.079L20.9829 56.1448L21.0991 55.6585ZM26.3046 56.9791L26.1762 57.4623L26.1874 57.4653L26.1988 57.4678L26.3046 56.9791ZM21.1302 44.2635L21.5934 44.0751L21.5876 44.061L21.5811 44.0473L21.1302 44.2635ZM25.0825 38.4147L24.7097 38.7479L24.9089 38.9707L25.1995 38.9008L25.0825 38.4147ZM27.5483 57.2484L27.4425 57.737L27.5047 57.7505L27.5683 57.748L27.5483 57.2484ZM24.8359 44.6336L24.517 44.2485L24.3072 44.4222L24.3394 44.6927L24.8359 44.6336ZM29.0773 57.3299L29.0868 57.8298L29.1113 57.8294L29.1356 57.8265L29.0773 57.3299ZM25.6892 25.6437L25.8788 25.1811L25.8417 25.1659L25.8027 25.1568L25.6892 25.6437ZM31.3837 56.8316L31.4893 57.3203L31.5663 57.3037L31.6345 57.2642L31.3837 56.8316ZM27.8058 26.5113L28.0921 26.1014L28.0467 26.0697L27.9955 26.0487L27.8058 26.5113ZM35.3264 35.9485L35.8059 35.807L35.7869 35.7424L35.7513 35.6851L35.3264 35.9485ZM30.7664 28.5927L31.1309 28.2503L31.1057 28.2235L31.0769 28.2007L30.7664 28.5927ZM35.3052 52.5301L35.7498 52.7589L35.7759 52.7082L35.7899 52.653L35.3052 52.5301ZM32.523 56.1714L32.7737 56.604L32.8258 56.5737L32.8693 56.532L32.523 56.1714ZM33.7282 55.0816L34.0524 55.4622L34.1008 55.4209L34.1374 55.3689L33.7282 55.0816ZM34.6257 53.8507L35.0247 54.152L35.0506 54.1177L35.0703 54.0795L34.6257 53.8507ZM29.3914 27.5035L29.7019 27.1116L29.6705 27.0867L29.6356 27.0672L29.3914 27.5035ZM36.3101 48.5659L36.7947 48.6887L36.8031 48.6556L36.8069 48.6217L36.3101 48.5659ZM36.6258 44.786L37.1257 44.7929L37.1259 44.783L37.1256 44.7731L36.6258 44.786ZM33.0102 31.2082L33.4441 30.9599L33.4206 30.9187L33.3897 30.8827L33.0102 31.2082ZM36.5192 46.7033L37.0162 46.7591L37.017 46.7508L36.5192 46.7033ZM36.5536 42.6536L36.0537 42.6431L36.0534 42.6568L36.0539 42.6705L36.5536 42.6536ZM35.8615 37.937L36.3543 37.8525L36.3503 37.8296L36.3443 37.8071L35.8615 37.937ZM36.5 39.9271L36.9998 39.9142L36.9981 39.8486L36.9796 39.7856L36.5 39.9271ZM22.2723 36.5539L22.4083 36.0728L21.7709 35.8926L21.7723 36.555L22.2723 36.5539ZM22.2886 44.1996L21.7886 44.2006L21.7894 44.5672L22.1392 44.6767L22.2886 44.1996ZM24.0543 37.0575L24.2099 36.5824L24.2002 36.5792L24.1903 36.5764L24.0543 37.0575ZM24.2395 37.1182L24.4305 36.6561L24.413 36.6489L24.3951 36.643L24.2395 37.1182ZM24.4267 37.1956L24.6488 36.7476L24.6335 36.74L24.6177 36.7335L24.4267 37.1956ZM24.6145 37.2887L24.8642 36.8555L24.8506 36.8476L24.8366 36.8407L24.6145 37.2887ZM24.8013 37.3963L24.5516 37.8295L24.5863 37.8495L24.6238 37.8637L24.8013 37.3963ZM23.9363 44.7156L23.7869 45.1928L23.7934 45.1948L23.9363 44.7156ZM25.2404 37.5631L25.5381 37.1614L25.4826 37.1202L25.418 37.0957L25.2404 37.5631ZM25.4204 37.6965L25.7397 37.3117L25.7291 37.3029L25.7181 37.2947L25.4204 37.6965ZM25.5946 37.841L25.9344 37.4742L25.9244 37.4649L25.9139 37.4562L25.5946 37.841ZM25.7614 37.9955L26.1211 37.6481L26.1114 37.6382L26.1012 37.6287L25.7614 37.9955ZM25.9192 38.1589L26.2982 37.8328L26.2889 37.8219L26.2789 37.8115L25.9192 38.1589ZM24.0682 44.755L23.9253 45.2341L23.9341 45.2367L23.9429 45.239L24.0682 44.755ZM24.2193 44.7941L24.0939 45.2781L24.106 45.2812L24.1183 45.2838L24.2193 44.7941ZM24.3865 44.8286L24.2856 45.3183L24.3011 45.3215L24.3167 45.3237L24.3865 44.8286ZM24.5672 44.854L24.4974 45.3491L24.5165 45.3518L24.5358 45.353L24.5672 44.854ZM24.7583 44.8661L24.7269 45.3651L24.7499 45.3665L24.7729 45.3658L24.7583 44.8661ZM24.9569 44.8602L24.9716 45.36L24.9987 45.3592L25.0255 45.3555L24.9569 44.8602ZM25.1602 44.8321L25.2287 45.3274L25.2596 45.3231L25.2896 45.315L25.1602 44.8321ZM25.3651 44.7772L25.4945 45.2601L25.5281 45.2511L25.56 45.2376L25.3651 44.7772ZM25.5687 44.6909L25.7636 45.1514L25.7979 45.1368L25.8297 45.1174L25.5687 44.6909ZM25.768 44.5689L26.029 44.9954L26.0616 44.9755L26.0908 44.9508L25.768 44.5689ZM25.9601 44.4066L26.2828 44.7885L26.2843 44.7872L25.9601 44.4066ZM26.7842 25.2718L26.9715 24.8081L26.9477 24.7985L26.9231 24.7914L26.7842 25.2718ZM28.7237 26.1652L28.9939 25.7446L28.9749 25.7324L28.9549 25.722L28.7237 26.1652ZM36.0714 35.7935L36.5427 35.6265L36.5407 35.6211L36.0714 35.7935ZM31.7734 28.6588L32.1521 28.3322L32.142 28.3206L32.1313 28.3096L31.7734 28.6588ZM25.9464 38.4618L25.5767 38.1252L25.3146 38.4132L25.5295 38.7379L25.9464 38.4618ZM27.7887 25.6775L28.0199 25.2342L27.9984 25.2229L27.9759 25.2139L27.7887 25.6775ZM29.5892 26.7214L29.8934 26.3245L29.877 26.3119L29.8595 26.3007L29.5892 26.7214ZM30.3857 27.3319L30.7189 26.9591L30.7048 26.9465L30.6899 26.935L30.3857 27.3319ZM31.1135 27.9825L31.4714 27.6333L31.4595 27.6211L31.4467 27.6097L31.1135 27.9825ZM32.3663 29.3462L32.7624 29.0411L32.754 29.0302L32.745 29.0197L32.3663 29.3462ZM32.8933 30.0303L33.304 29.7452L33.297 29.735L33.2894 29.7251L32.8933 30.0303ZM37.4984 44.6004L37 44.6402L37.9984 44.6006L37.4984 44.6004ZM33.3555 30.6962L33.7786 30.4297L33.7726 30.4203L33.7663 30.4111L33.3555 30.6962ZM34.0915 31.9154L33.6581 32.1647L33.6668 32.1798L33.6765 32.1943L34.0915 31.9154ZM35.1562 33.5L35.6153 33.3021L35.5988 33.2638L35.5762 33.2287L35.1562 33.5ZM37.4051 42.5579L37.9042 42.5277L37.9037 42.5194L37.903 42.5112L37.4051 42.5579ZM37.4683 43.5997L37.9681 43.5847L37.9679 43.577L37.9674 43.5694L37.4683 43.5997ZM37.1607 40.3756L37.6566 40.3113L37.6553 40.3018L37.6537 40.2924L37.1607 40.3756ZM35.6482 34.6413L36.1175 34.4689L36.1128 34.456L36.1073 34.4433L35.6482 34.6413ZM37.3042 41.4812L37.802 41.4345L37.8011 41.4257L37.8 41.4169L37.3042 41.4812ZM36.7281 38.1034L37.2173 37.9999L37.215 37.989L37.2122 37.9783L36.7281 38.1034ZM36.43 36.9498L36.9141 36.8247L36.9111 36.8132L36.9075 36.8017L36.43 36.9498ZM36.9702 39.2475L37.4632 39.1643L37.4615 39.1541L37.4594 39.144L36.9702 39.2475ZM37.5 39.8245L38 39.8247L38 39.7386L37.9713 39.6575L37.5 39.8245ZM36.5745 41.6576L37.0744 41.6681L37.0757 41.6069L37.0621 41.5471L36.5745 41.6576ZM36.613 45.722L37.1107 45.7695L37.1126 45.7492L37.1129 45.7288L36.613 45.722ZM28.5607 27.0385L28.2744 27.4484L28.2948 27.4626L28.3165 27.4748L28.5607 27.0385ZM34.1513 54.479L33.7523 54.1776L33.747 54.1846L33.7421 54.1916L34.1513 54.479ZM28.1894 57.2227L28.2493 56.7263L28.2094 56.7215L28.1694 56.7231L28.1894 57.2227ZM27.5821 57.186L27.7184 56.705L27.6906 56.6971L27.6621 56.6925L27.5821 57.186ZM23.4583 56.2227L23.5867 55.7393L23.5746 55.7364L23.4583 56.2227ZM36.5108 46.7529L37.0077 46.8079L37.0092 46.795L37.0099 46.7821L36.5108 46.7529ZM33.1043 55.613L32.78 55.2324L32.7687 55.2421L32.7579 55.2524L33.1043 55.613ZM28.152 57.3475L28.0157 57.8285L28.0872 57.8488L28.1614 57.8474L28.152 57.3475ZM10.0126 22.2143L20.7849 69.2143L21.7597 68.9909L10.9874 21.9909L10.0126 22.2143ZM10.0232 22.2532L20.6224 55.8091L21.5759 55.5079L10.9768 21.952L10.0232 22.2532ZM10.0446 22.3089L25.8492 57.1855L26.76 56.7727L10.9554 21.8962L10.0446 22.3089ZM10.0963 22.3976L20.7522 36.9751L21.5596 36.385L10.9037 21.8075L10.0963 22.3976ZM21.5811 44.0473L10.9508 21.8863L10.0492 22.3188L20.6794 44.4798L21.5811 44.0473ZM20.6671 44.452L25.8415 57.1676L26.7677 56.7907L21.5934 44.0751L20.6671 44.452ZM10.1185 22.4258L22.9656 37.5892L23.7286 36.9427L10.8815 21.7794L10.1185 22.4258ZM10.1202 22.4277L23.1524 37.6517L23.912 37.0014L10.8798 21.7774L10.1202 22.4277ZM10.1216 22.4294L23.3411 37.7309L24.0978 37.0771L10.8784 21.7757L10.1216 22.4294ZM10.1229 22.4309L23.5302 37.8255L24.2843 37.1687L10.8771 21.7742L10.1229 22.4309ZM10.1241 22.4322L23.6961 37.9084L24.4479 37.2491L10.8759 21.7729L10.1241 22.4322ZM22.2626 44.8521L25.8244 57.1185L26.7848 56.8397L23.2229 44.5732L22.2626 44.8521ZM10.1252 22.4335L23.8656 37.9966L24.6153 37.3348L10.8748 21.7716L10.1252 22.4335ZM10.1259 22.4343L24.0463 38.1308L24.7945 37.4673L10.8741 21.7708L10.1259 22.4343ZM10.1265 22.4349L24.2211 38.2759L24.9682 37.6112L10.8735 21.7702L10.1265 22.4349ZM10.1268 22.4353L24.3882 38.4308L25.1346 37.7653L10.8732 21.7698L10.1268 22.4353ZM10.1273 22.4359L24.5492 38.5638L25.2946 37.8972L10.8727 21.7693L10.1273 22.4359ZM10.1272 22.4358L24.7097 38.7479L25.4552 38.0814L10.8728 21.7693L10.1272 22.4358ZM22.521 44.903L25.822 57.1096L26.7873 56.8486L23.4863 44.642L22.521 44.903ZM22.6989 44.918L25.8203 57.1032L26.789 56.855L23.6677 44.6698L22.6989 44.918ZM22.8812 44.924L25.8186 57.0964L26.7907 56.8618L23.8533 44.6894L22.8812 44.924ZM23.072 44.9297L25.8169 57.0892L26.7923 56.869L24.0474 44.7095L23.072 44.9297ZM23.2246 44.9195L25.8156 57.0833L26.7936 56.8749L24.2027 44.7111L23.2246 44.9195ZM23.4156 44.912L25.8141 57.0758L26.7952 56.8824L24.3967 44.7186L23.4156 44.912ZM23.6024 44.8961L25.8127 57.0684L26.7966 56.8898L24.5863 44.7174L23.6024 44.8961ZM23.8445 44.865L25.811 57.0587L26.7982 56.8995L24.8318 44.7057L23.8445 44.865ZM24.0826 44.8168L25.8095 57.049L26.7997 56.9092L25.0728 44.677L24.0826 44.8168ZM26.1988 57.4678L27.4425 57.737L27.6541 56.7597L26.4104 56.4904L26.1988 57.4678ZM24.2151 44.7714L25.8088 57.0435L26.8004 56.9147L25.2068 44.6426L24.2151 44.7714ZM24.3394 44.6927L25.8081 57.0382L26.8011 56.92L25.3324 44.5745L24.3394 44.6927ZM25.8027 25.1568L10.6135 21.6156L10.3865 22.5895L25.5757 26.1307L25.8027 25.1568ZM31.2782 56.3429L28.9717 56.8412L29.1829 57.8186L31.4893 57.3203L31.2782 56.3429ZM26.3191 57.4789L31.3983 57.3314L31.3692 56.3318L26.2901 56.4793L26.3191 57.4789ZM25.4996 26.1064L27.6162 26.974L27.9955 26.0487L25.8788 25.1811L25.4996 26.1064ZM27.9293 26.0268L10.6234 21.618L10.3766 22.5871L27.6824 26.9958L27.9293 26.0268ZM29.1356 57.8265L30.158 57.7065L30.0414 56.7133L29.019 56.8333L29.1356 57.8265ZM10.2565 22.5392L35.0828 36.3852L35.5699 35.5118L10.7435 21.6659L10.2565 22.5392ZM35.2093 35.4624L24.9654 37.9285L25.1995 38.9008L35.4434 36.4346L35.2093 35.4624ZM27.5183 26.9203L30.4789 29.0017L31.054 28.1836L28.0934 26.1023L27.5183 26.9203ZM30.9189 28.1165L10.6525 21.6264L10.3475 22.5787L30.614 29.0688L30.9189 28.1165ZM34.8669 35.7514L25.8451 56.782L26.7641 57.1762L35.7859 36.1456L34.8669 35.7514ZM25.1547 45.0187L35.6452 36.3336L35.0075 35.5634L24.517 44.2485L25.1547 45.0187ZM34.9357 52.1933L31.0142 56.4948L31.7532 57.1685L35.6747 52.867L34.9357 52.1933ZM26.5262 57.4273L35.5268 52.9783L35.0836 52.0819L26.0831 56.5309L26.5262 57.4273ZM25.3669 44.8959L35.6464 36.3327L35.0063 35.5643L24.7268 44.1276L25.3669 44.8959ZM25.5702 44.7356L35.6466 36.3325L35.0061 35.5645L24.9298 43.9676L25.5702 44.7356ZM31.6345 57.2642L32.7737 56.604L32.2722 55.7388L31.133 56.399L31.6345 57.2642ZM25.7645 44.5294L35.6456 36.3333L35.0072 35.5637L25.1261 43.7597L25.7645 44.5294ZM25.9113 44.3355L35.6439 36.3348L35.0089 35.5623L25.2762 43.563L25.9113 44.3355ZM26.0165 44.1691L35.642 36.3363L35.0108 35.5607L25.3853 43.3935L26.0165 44.1691ZM30.3415 28.8561L34.9014 36.2119L35.7513 35.6851L31.1914 28.3292L30.3415 28.8561ZM26.1159 43.9929L35.6396 36.3382L35.0131 35.5588L25.4894 43.2135L26.1159 43.9929ZM26.1784 43.8085L35.6362 36.3409L35.0165 35.5561L25.5587 43.0237L26.1784 43.8085ZM26.2299 43.5931L35.6317 36.3445L35.0211 35.5525L25.6193 42.8011L26.2299 43.5931ZM26.2721 43.3581L35.6262 36.3486L35.0265 35.5484L25.6724 42.5579L26.2721 43.3581ZM26.3041 43.103L35.6197 36.3534L35.033 35.5436L25.7173 42.2932L26.3041 43.103ZM26.325 42.827L35.6121 36.3588L35.0406 35.5382L25.7535 42.0064L26.325 42.827ZM35.1999 35.4648L25.0909 38.1085L25.3439 39.076L35.4529 36.4322L35.1999 35.4648ZM26.3342 42.5295L35.6033 36.3648L35.0495 35.5322L25.7804 41.6968L26.3342 42.5295ZM31.6828 57.2323L34.0273 55.4822L33.4291 54.6809L31.0847 56.4309L31.6828 57.2323ZM35.1902 35.4674L25.2024 38.294L25.4747 39.2562L35.4625 36.4296L35.1902 35.4674ZM35.1822 35.4698L25.2871 38.4502L25.5755 39.4077L35.4706 36.4273L35.1822 35.4698ZM26.3305 42.2097L35.593 36.3715L35.0598 35.5255L25.7973 41.3638L26.3305 42.2097ZM35.1733 35.4725L25.3821 38.6217L25.6882 39.5736L35.4795 36.4245L35.1733 35.4725ZM26.312 41.8708L35.5812 36.3787L35.0715 35.5183L25.8022 41.0105L26.312 41.8708ZM35.1635 35.4758L25.4699 38.8163L25.7957 39.7618L35.4893 36.4212L35.1635 35.4758ZM26.2788 41.5492L35.5693 36.3855L35.0835 35.5115L25.793 40.6751L26.2788 41.5492ZM35.1533 35.4794L25.5496 39.0231L25.8957 39.9613L35.4995 36.4176L35.1533 35.4794ZM26.2505 41.2403L35.5574 36.3919L35.0954 35.5051L25.7885 40.3534L26.2505 41.2403ZM35.1447 35.4827L25.6116 39.2014L25.975 40.1331L35.5081 36.4143L35.1447 35.4827ZM35.1313 35.4881L25.6916 39.4889L26.0818 40.4096L35.5215 36.4089L35.1313 35.4881ZM26.2153 40.9494L35.5456 36.3979L35.1072 35.4991L25.7769 40.0506L26.2153 40.9494ZM35.1175 35.4942L25.7464 39.8033L26.1642 40.7118L35.5353 36.4028L35.1175 35.4942ZM34.8799 52.2672L33.3029 54.8187L34.1535 55.3444L35.7305 52.793L34.8799 52.2672ZM34.8264 35.9479L34.8052 52.5295L35.8052 52.5307L35.8264 35.9491L34.8264 35.9479ZM34.8606 52.3013L34.1811 53.6219L35.0703 54.0795L35.7498 52.7589L34.8606 52.3013ZM29.081 27.8954L30.456 28.9846L31.0769 28.2007L29.7019 27.1116L29.081 27.8954ZM35.7899 52.653L36.7947 48.6887L35.8254 48.443L34.8205 52.4073L35.7899 52.653ZM32.3233 29.5196L31.1309 28.2503L30.402 28.935L31.5944 30.2043L32.3233 29.5196ZM35.7981 52.6142L37.1187 44.8701L36.1329 44.702L34.8123 52.4461L35.7981 52.6142ZM33.3897 30.8827L31.1459 28.2671L30.3869 28.9182L32.6307 31.5338L33.3897 30.8827ZM36.8069 48.6217L37.0161 46.7591L36.0224 46.6475L35.8132 48.5101L36.8069 48.6217ZM34.7647 33.2677L33.4441 30.9599L32.5762 31.4565L33.8968 33.7644L34.7647 33.2677ZM37.1255 44.7691L37.0533 42.6367L36.0539 42.6705L36.1261 44.8029L37.1255 44.7691ZM37.1242 44.7461L36.7645 40.2568L35.7677 40.3366L36.1274 44.8259L37.1242 44.7461ZM35.3687 38.0215L35.7733 40.3812L36.759 40.2122L36.3543 37.8525L35.3687 38.0215ZM34.8468 36.09L36.0204 40.0686L36.9796 39.7856L35.8059 35.807L34.8468 36.09ZM36.0002 39.94L36.126 44.799L37.1256 44.7731L36.9998 39.9142L36.0002 39.94ZM21.7723 36.555L21.7886 44.2006L22.7886 44.1985L22.7723 36.5529L21.7723 36.555ZM24.1903 36.5764L22.4083 36.0728L22.1363 37.0351L23.9183 37.5387L24.1903 36.5764ZM24.3951 36.643L24.2099 36.5824L23.8987 37.5327L24.0838 37.5933L24.3951 36.643ZM24.6177 36.7335L24.4305 36.6561L24.0484 37.5802L24.2357 37.6577L24.6177 36.7335ZM24.8366 36.8407L24.6488 36.7476L24.2046 37.6436L24.3924 37.7367L24.8366 36.8407ZM25.0509 36.9631L24.8642 36.8555L24.3648 37.7219L24.5516 37.8295L25.0509 36.9631ZM22.1392 44.6767L23.7869 45.1928L24.0858 44.2385L22.4381 43.7224L22.1392 44.6767ZM25.418 37.0957L24.9788 36.9289L24.6238 37.8637L25.0629 38.0305L25.418 37.0957ZM25.7181 37.2947L25.5381 37.1614L24.9428 37.9648L25.1228 38.0982L25.7181 37.2947ZM25.9139 37.4562L25.7397 37.3117L25.1012 38.0813L25.2754 38.2258L25.9139 37.4562ZM26.1012 37.6287L25.9344 37.4742L25.2548 38.2078L25.4216 38.3623L26.1012 37.6287ZM26.2789 37.8115L26.1211 37.6481L25.4018 38.3429L25.5596 38.5063L26.2789 37.8115ZM26.4454 38.0038L26.2982 37.8328L25.5402 38.485L25.6874 38.6561L26.4454 38.0038ZM23.7934 45.1948L23.9253 45.2341L24.2112 44.2758L24.0793 44.2365L23.7934 45.1948ZM23.9429 45.239L24.0939 45.2781L24.3446 44.31L24.1936 44.2709L23.9429 45.239ZM24.1183 45.2838L24.2856 45.3183L24.4875 44.3389L24.3202 44.3044L24.1183 45.2838ZM24.3167 45.3237L24.4974 45.3491L24.637 44.3589L24.4563 44.3335L24.3167 45.3237ZM24.5358 45.353L24.7269 45.3651L24.7897 44.3671L24.5986 44.355L24.5358 45.353ZM24.7729 45.3658L24.9716 45.36L24.9423 44.3605L24.7436 44.3663L24.7729 45.3658ZM25.0255 45.3555L25.2287 45.3274L25.0916 44.3368L24.8883 44.365L25.0255 45.3555ZM25.2896 45.315L25.4945 45.2601L25.2356 44.2942L25.0307 44.3491L25.2896 45.315ZM25.56 45.2376L25.7636 45.1514L25.3737 44.2305L25.1701 44.3167L25.56 45.2376ZM25.8297 45.1174L26.029 44.9954L25.507 44.1425L25.3077 44.2645L25.8297 45.1174ZM26.0908 44.9508L26.2828 44.7885L25.6373 44.0247L25.4452 44.1871L26.0908 44.9508ZM25.5717 25.4418L26.6454 25.7521L26.9231 24.7914L25.8494 24.4811L25.5717 25.4418ZM26.575 25.7259L28.5144 26.6194L28.9329 25.7111L26.9935 24.8176L26.575 25.7259ZM35.9485 35.3088L25.9436 37.8453L26.1893 38.8146L36.1943 36.2782L35.9485 35.3088ZM28.4072 26.5523L31.457 29.0459L32.0899 28.2717L29.0401 25.7782L28.4072 26.5523ZM26.2843 44.7872L36.3956 36.1741L35.7472 35.4129L25.6358 44.026L26.2843 44.7872ZM26.3359 44.7363L26.5177 44.5291L25.7659 43.8697L25.5842 44.0769L26.3359 44.7363ZM26.4649 44.581L36.3945 36.1751L35.7483 35.4119L25.8188 43.8178L26.4649 44.581ZM26.5314 44.5129L26.6225 44.3996L25.8434 43.7727L25.7523 43.886L26.5314 44.5129ZM26.5552 44.4684L36.3936 36.1758L35.7492 35.4112L25.9107 43.7038L26.5552 44.4684ZM26.6475 44.3658L26.7346 44.2366L25.9056 43.6774L25.8185 43.8065L26.6475 44.3658ZM26.641 44.3404L36.3924 36.1769L35.7504 35.4101L25.9991 43.5736L26.641 44.3404ZM26.7554 44.203L26.8377 44.0573L25.9671 43.5653L25.8848 43.711L26.7554 44.203ZM26.7216 44.1962L36.3906 36.1784L35.7522 35.4086L26.0833 43.4264L26.7216 44.1962ZM26.8547 44.0246L26.9315 43.8616L26.0271 43.4351L25.9502 43.598L26.8547 44.0246ZM26.7961 44.0352L36.3882 36.1804L35.7546 35.4067L26.1625 43.2615L26.7961 44.0352ZM31.3452 28.9168L35.6431 36.0515L36.4997 35.5355L32.2017 28.4008L31.3452 28.9168ZM26.9451 43.8302L27.0157 43.6492L26.0842 43.2856L26.0135 43.4665L26.9451 43.8302ZM26.8637 43.8567L36.3852 36.1828L35.7576 35.4042L26.2362 43.0781L26.8637 43.8567ZM27.0263 43.6194L27.09 43.4198L26.1373 43.1158L26.0736 43.3154L27.0263 43.6194ZM26.9236 43.6601L36.3814 36.1858L35.7614 35.4012L26.3036 42.8755L26.9236 43.6601ZM27.098 43.3917L27.154 43.1727L26.1852 42.9249L26.1292 43.1439L27.098 43.3917ZM26.9751 43.4446L36.3769 36.1894L35.7659 35.3977L26.3642 42.6529L26.9751 43.4446ZM27.16 43.1464L27.2076 42.9073L26.2269 42.712L26.1793 42.9511L27.16 43.1464ZM27.0173 43.2097L36.3714 36.1935L35.7714 35.3935L26.4172 42.4097L27.0173 43.2097ZM27.2119 42.8829L27.2503 42.623L26.2611 42.4766L26.2226 42.7365L27.2119 42.8829ZM27.0493 42.9546L36.365 36.1983L35.7778 35.3888L26.4622 42.145L27.0493 42.9546ZM27.2532 42.6004L27.2818 42.319L26.2869 42.2179L26.2583 42.4992L27.2532 42.6004ZM27.0703 42.6786L36.3574 36.2037L35.7854 35.3834L26.4984 41.8583L27.0703 42.6786ZM26.3162 38.7984L26.4362 38.6665L25.6967 37.9934L25.5767 38.1252L26.3162 38.7984ZM35.944 35.31L25.819 37.9783L26.0738 38.9453L36.1988 36.277L35.944 35.31ZM27.2834 42.298L27.3014 41.9944L26.3032 41.9353L26.2852 42.2388L27.2834 42.298ZM27.0794 42.3811L36.3485 36.2097L35.7943 35.3773L26.5252 41.5487L27.0794 42.3811ZM26.4844 38.3686L26.3633 38.1857L25.5295 38.7379L25.6506 38.9207L26.4844 38.3686ZM35.9344 35.3127L25.9305 38.1638L26.2046 39.1255L36.2084 36.2744L35.9344 35.3127ZM26.5885 38.5403L26.4957 38.3865L25.6394 38.9029L25.7321 39.0567L26.5885 38.5403ZM35.9263 35.315L26.0152 38.3201L26.3054 39.277L36.2165 36.272L35.9263 35.315ZM27.3022 41.9751L27.3089 41.6486L26.3091 41.6283L26.3024 41.9547L27.3022 41.9751ZM27.0758 42.0613L36.3382 36.2164L35.8046 35.3707L26.5421 41.2156L27.0758 42.0613ZM26.6927 38.7336L26.6011 38.5626L25.7195 39.0345L25.811 39.2055L26.6927 38.7336ZM35.9175 35.3178L26.0979 38.4938L26.4057 39.4453L36.2253 36.2692L35.9175 35.3178ZM27.3089 41.6286L27.302 41.2825L26.3022 41.3022L26.3091 41.6483L27.3089 41.6286ZM27.0572 41.7223L36.3265 36.2235L35.8163 35.3635L26.547 40.8623L27.0572 41.7223ZM26.7928 38.9441L26.7039 38.7559L25.7997 39.1831L25.8887 39.3713L26.7928 38.9441ZM35.908 35.321L26.1774 38.6852L26.5041 39.6303L36.2348 36.2661L35.908 35.321ZM27.3011 41.2602L27.2799 40.9317L26.282 40.996L26.3032 41.3245L27.3011 41.2602ZM27.0241 41.4008L36.3145 36.2304L35.8283 35.3566L26.5378 40.527L27.0241 41.4008ZM26.8878 39.1721L26.8028 38.9666L25.8787 39.3489L25.9638 39.5544L26.8878 39.1721ZM35.8979 35.3246L26.2522 38.8943L26.5993 39.8322L36.2449 36.2624L35.8979 35.3246ZM27.278 40.9092L27.2438 40.5984L26.2498 40.7078L26.284 41.0186L27.278 40.9092ZM26.9778 41.0965L36.3025 36.2369L35.8403 35.3501L26.5157 40.2097L26.9778 41.0965ZM26.9763 39.4176L26.8965 39.1946L25.955 39.5318L26.0349 39.7547L26.9763 39.4176ZM35.8871 35.3287L26.3213 39.1213L26.6899 40.0509L36.2557 36.2583L35.8871 35.3287ZM27.0572 39.6806L26.9838 39.4403L26.0274 39.732L26.1007 39.9724L27.0572 39.6806ZM35.8759 35.3333L26.3834 39.3663L26.7744 40.2867L36.2669 36.2537L35.8759 35.3333ZM27.2407 40.5756L27.1948 40.2825L26.2068 40.4374L26.2528 40.7305L27.2407 40.5756ZM26.9199 40.8094L36.2904 36.243L35.8524 35.344L26.4818 39.9105L26.9199 40.8094ZM27.129 39.9613L27.0635 39.7034L26.0943 39.9496L26.1598 40.2075L27.129 39.9613ZM35.8643 35.3384L26.4373 39.6294L26.8516 40.5395L36.2785 36.2486L35.8643 35.3384ZM27.1907 40.2597L27.1343 39.9842L26.1546 40.1847L26.211 40.4602L27.1907 40.2597ZM26.597 25.7354L27.6014 26.1411L27.9759 25.2139L26.9715 24.8081L26.597 25.7354ZM27.5574 26.1208L28.4924 26.6085L28.9549 25.722L28.0199 25.2342L27.5574 26.1208ZM28.4534 26.5859L29.319 27.142L29.8595 26.3007L28.9939 25.7446L28.4534 26.5859ZM29.2851 27.1182L30.0815 27.7287L30.6899 26.935L29.8934 26.3245L29.2851 27.1182ZM30.6729 26.9226L29.0109 25.756L28.4364 26.5745L30.0984 27.7411L30.6729 26.9226ZM30.0402 27.6933L31.4279 29.0202L32.119 28.2974L30.7312 26.9705L30.0402 27.6933ZM30.0525 27.7046L30.7803 28.3552L31.4467 27.6097L30.7189 26.9591L30.0525 27.7046ZM30.7557 28.3317L31.4156 29.008L32.1313 28.3096L31.4714 27.6333L30.7557 28.3317ZM31.3948 28.9853L31.9877 29.6728L32.745 29.0197L32.1521 28.3322L31.3948 28.9853ZM31.9702 29.6514L32.4972 30.3354L33.2894 29.7251L32.7624 29.0411L31.9702 29.6514ZM33.2806 29.714L32.1607 28.3425L31.3861 28.975L32.506 30.3465L33.2806 29.714ZM32.4765 30.3065L33.3377 31.6057L34.1712 31.0533L33.3101 29.754L32.4765 30.3065ZM34.156 31.0316L32.175 28.3609L31.3719 28.9566L33.3528 31.6274L34.156 31.0316ZM32.4825 30.3154L32.9448 30.9813L33.7663 30.4111L33.304 29.7452L32.4825 30.3154ZM32.9325 30.9627L33.3314 31.596L34.1775 31.063L33.7786 30.4297L32.9325 30.9627ZM33.3106 31.5598L35.6276 36.0239L36.5152 35.5632L34.1982 31.0992L33.3106 31.5598ZM33.321 31.5788L33.6581 32.1647L34.5249 31.6661L34.1878 31.0802L33.321 31.5788ZM33.6765 32.1943L34.7411 33.7788L35.5712 33.2211L34.5065 31.6366L33.6765 32.1943ZM35.5762 33.2287L34.1744 31.0582L33.3344 31.6007L34.7361 33.7713L35.5762 33.2287ZM34.6918 33.6853L35.607 35.9788L36.5358 35.6082L35.6205 33.3147L34.6918 33.6853ZM36.9061 42.5882L36.9693 43.63L37.9674 43.5694L37.9042 42.5277L36.9061 42.5882ZM36.9686 43.6147L36.9986 44.6154L37.9982 44.5854L37.9681 43.5847L36.9686 43.6147ZM37.9979 44.5776L37.9046 42.5351L36.9057 42.5807L36.9989 44.6232L37.9979 44.5776ZM36.6638 40.4313L36.9083 42.6136L37.902 42.5023L37.6576 40.32L36.6638 40.4313ZM37.9968 44.5605L37.6591 40.3358L36.6623 40.4155L37 44.6402L37.9968 44.5605ZM34.697 33.6979L35.189 34.8392L36.1073 34.4433L35.6153 33.3021L34.697 33.6979ZM35.1788 34.8137L35.6021 35.9659L36.5407 35.6211L36.1175 34.4689L35.1788 34.8137ZM35.585 35.9092L36.6743 40.4913L37.6472 40.26L36.5578 35.6779L35.585 35.9092ZM36.6649 40.4399L36.8083 41.5455L37.8 41.4169L37.6566 40.3113L36.6649 40.4399ZM36.8063 41.5279L36.9073 42.6046L37.903 42.5112L37.802 41.4345L36.8063 41.5279ZM35.5905 35.9302L36.2472 38.2401L37.2091 37.9667L36.5523 35.6568L35.5905 35.9302ZM36.2369 38.1969L36.6695 40.4691L37.6519 40.2821L37.2193 38.0099L36.2369 38.1969ZM35.5938 35.9416L35.9524 37.0979L36.9075 36.8017L36.549 35.6454L35.5938 35.9416ZM35.9459 37.0749L36.244 38.2285L37.2122 37.9783L36.9141 36.8247L35.9459 37.0749ZM36.239 38.2069L36.481 39.351L37.4594 39.144L37.2173 37.9999L36.239 38.2069ZM36.4772 39.3308L36.6677 40.4589L37.6537 40.2924L37.4632 39.1643L36.4772 39.3308ZM35.6001 35.9605L37.0287 39.9915L37.9713 39.6575L36.5427 35.6265L35.6001 35.9605ZM37 39.8244L36.9984 44.6002L37.9984 44.6006L38 39.8247L37 39.8244ZM34.8435 36.0784L35.3786 38.067L36.3443 37.8071L35.8092 35.8186L34.8435 36.0784ZM35.7785 40.4072L36.0869 41.7681L37.0621 41.5471L36.7538 40.1862L35.7785 40.4072ZM36.0746 41.6471L36.0537 42.6431L37.0535 42.6641L37.0744 41.6681L36.0746 41.6471ZM36.1258 44.7792L36.113 45.7151L37.1129 45.7288L37.1257 44.7929L36.1258 44.7792ZM36.1152 45.6744L36.0215 46.6557L37.017 46.7508L37.1107 45.7695L36.1152 45.6744ZM29.6356 27.0672L28.805 26.6022L28.3165 27.4748L29.1472 27.9398L29.6356 27.0672ZM28.847 26.6286L28.0921 26.1014L27.5196 26.9212L28.2744 27.4484L28.847 26.6286ZM34.1374 55.3689L34.5605 54.7663L33.7421 54.1916L33.319 54.7942L34.1374 55.3689ZM34.5503 54.7803L35.0247 54.152L34.2266 53.5494L33.7523 54.1776L34.5503 54.7803ZM29.1373 56.8335L28.2493 56.7263L28.1294 57.7191L29.0174 57.8263L29.1373 56.8335ZM28.1694 56.7231L27.5283 56.7488L27.5683 57.748L28.2093 57.7223L28.1694 56.7231ZM26.2247 57.4727L27.5022 57.6796L27.6621 56.6925L26.3846 56.4855L26.2247 57.4727ZM26.433 56.4959L23.5867 55.7394L23.3298 56.7059L26.1762 57.4623L26.433 56.4959ZM23.5746 55.7364L21.2154 55.1722L20.9829 56.1448L23.342 56.7089L23.5746 55.7364ZM36.1266 44.7568L36.0116 46.7237L37.0099 46.7821L37.1249 44.8152L36.1266 44.7568ZM36.0138 46.6979L35.8131 48.5109L36.807 48.6209L37.0077 46.8079L36.0138 46.6979ZM33.4039 54.7009L32.78 55.2324L33.4285 55.9936L34.0524 55.4622L33.4039 54.7009ZM32.7579 55.2524L32.1766 55.8108L32.8693 56.532L33.4506 55.9736L32.7579 55.2524ZM27.4458 57.6671L28.0157 57.8285L28.2882 56.8664L27.7184 56.705L27.4458 57.6671ZM28.1614 57.8474L29.0868 57.8298L29.0679 56.83L28.1425 56.8475L28.1614 57.8474ZM21.2723 69.1026L21.0462 70.0767L22.2886 70.365L22.2722 69.0897L21.2723 69.1026ZM10.5 66.6026L9.5 66.6026L9.5 67.3971L10.2739 67.5767L10.5 66.6026ZM10.5 22.1026L10.7213 21.1274L9.5 20.8502L9.5 22.1026L10.5 22.1026ZM21.0991 55.6585L21.3298 54.6855L20.0827 54.3899L20.0992 55.6714L21.0991 55.6585ZM26.3046 56.9791L26.0119 57.9353L26.0561 57.9489L26.1014 57.9582L26.3046 56.9791ZM21.1559 36.68L21.4142 35.714L20.1603 35.3787L20.1559 36.6766L21.1559 36.68ZM21.1302 44.2635L20.1302 44.2601L20.1277 45.0224L20.8619 45.2269L21.1302 44.2635ZM23.3471 37.266L23.6583 36.3156L23.6321 36.307L23.6054 36.2999L23.3471 37.266ZM25.0481 56.5945L25.3408 55.6383L25.3101 55.6289L25.2787 55.6214L25.0481 56.5945ZM23.5322 37.3266L23.9143 36.4025L23.8794 36.388L23.8434 36.3763L23.5322 37.3266ZM23.7195 37.404L24.1636 36.508L24.133 36.4929L24.1015 36.4799L23.7195 37.404ZM23.9073 37.4971L23.4631 38.3931L23.4632 38.3931L23.9073 37.4971ZM24.072 37.5787L24.5307 36.6901L24.5234 36.6864L24.516 36.6827L24.072 37.5787ZM22.7427 44.7126L22.4744 45.676L22.4966 45.6821L22.5191 45.6873L22.7427 44.7126ZM24.2404 37.6657L24.8358 36.8622L24.7709 36.8141L24.6991 36.7771L24.2404 37.6657ZM24.4204 37.799L25.0589 37.0294L25.0378 37.0119L25.0158 36.9956L24.4204 37.799ZM24.5946 37.9436L25.2742 37.21L25.2542 37.1914L25.2331 37.1739L24.5946 37.9436ZM24.7614 38.0981L24.0818 38.8317L24.1029 38.8512L24.125 38.8694L24.7614 38.0981ZM24.9219 38.2305L25.6756 37.5733L25.6216 37.5114L25.5583 37.4591L24.9219 38.2305ZM25.0825 38.4147L25.8786 37.8096L25.8583 37.7828L25.8362 37.7575L25.0825 38.4147ZM23.0037 44.7725L22.78 45.7472L22.8322 45.7592L22.8854 45.7655L23.0037 44.7725ZM23.1833 44.7939L23.0651 45.7869L23.0893 45.7898L23.1137 45.7915L23.1833 44.7939ZM23.3672 44.8067L23.2976 45.8043L23.3007 45.8045L23.3672 44.8067ZM23.5597 44.8196L23.4932 45.8174L23.5403 45.8205L23.5875 45.8192L23.5597 44.8196ZM23.7137 44.8153L23.7137 43.8153L23.6998 43.8153L23.6859 43.8157L23.7137 44.8153ZM23.9062 44.8153L23.9062 45.8153L23.9289 45.8153L23.9516 45.8143L23.9062 44.8153ZM24.0943 44.8067L24.1398 45.8057L24.1608 45.8047L24.1817 45.8029L24.0943 44.8067ZM24.3382 44.7854L24.4255 45.7815L24.4613 45.7784L24.4968 45.7727L24.3382 44.7854ZM24.5777 44.7469L24.7364 45.7342L24.8011 45.7238L24.864 45.705L24.5777 44.7469ZM27.5483 57.2484L27.3267 58.2235L27.3572 58.2304L27.3881 58.2354L27.5483 57.2484ZM26.9841 57.1201L27.2058 56.145L27.1966 56.1429L27.1874 56.141L26.9841 57.1201ZM24.7109 44.707L24.9973 45.6652L25.1133 45.6305L25.2177 45.5691L24.7109 44.707ZM24.8359 44.6336L24.3357 43.7676L24.3292 43.7715L24.8359 44.6336ZM29.0773 57.3299L29.0792 58.3299L29.1259 58.3298L29.1723 58.3254L29.0773 57.3299ZM28.0622 57.3318L27.902 58.3188L27.9824 58.3319L28.064 58.3318L28.0622 57.3318ZM24.5906 25.2998L24.8894 24.3455L24.851 24.3335L24.8119 24.3246L24.5906 25.2998ZM25.6892 25.6437L26.0087 24.6962L25.9984 24.6927L25.9879 24.6894L25.6892 25.6437ZM31.3837 56.8316L31.7 57.7803L31.7815 57.7531L31.8572 57.7124L31.3837 56.8316ZM27.8058 26.5113L28.3181 25.6525L28.2824 25.6312L28.2451 25.6129L27.8058 26.5113ZM30.0997 57.2099L30.226 58.2019L30.289 58.1939L30.3504 58.178L30.0997 57.2099ZM29.3946 57.2996L29.4896 58.2951L29.5052 58.2936L29.5208 58.2916L29.3946 57.2996ZM35.3264 35.9485L36.287 35.6706L36.2814 35.6513L36.2751 35.6323L35.3264 35.9485ZM30.7664 28.5927L31.4665 27.8786L31.4255 27.8384L31.3802 27.8032L30.7664 28.5927ZM30.7682 57.0368L31.0189 58.0049L31.052 57.9963L31.0844 57.9855L30.7682 57.0368ZM35.3052 52.5301L36.2146 52.946L36.2345 52.9025L36.2502 52.8572L35.3052 52.5301ZM25.0469 44.5117L25.5471 45.3776L25.6094 45.3416L25.666 45.297L25.0469 44.5117ZM25.25 44.3516L25.8692 45.1368L25.9269 45.0913L25.9774 45.0378L25.25 44.3516ZM32.523 56.1714L33.0481 57.0224L33.093 56.9947L33.1347 56.9624L32.523 56.1714ZM31.9204 56.5432L32.3938 57.424L32.4201 57.4099L32.4455 57.3942L31.9204 56.5432ZM25.4453 44.1445L26.1727 44.8308L26.2093 44.792L26.2415 44.7496L25.4453 44.1445ZM25.5938 43.9492L26.3899 44.5543L26.4147 44.5217L26.4367 44.4872L25.5938 43.9492ZM25.7009 43.7813L26.5439 44.3192L26.557 44.2986L26.5692 44.2774L25.7009 43.7813ZM25.8027 43.6032L26.6709 44.0993L26.7158 44.0208L26.7459 43.9354L25.8027 43.6032ZM25.8686 43.4161L26.8118 43.7483L26.8265 43.7067L26.8374 43.6639L25.8686 43.4161ZM25.9246 43.1971L26.8934 43.4449L26.9001 43.4188L26.9054 43.3924L25.9246 43.1971ZM25.9722 42.958L26.953 43.1533L26.9578 43.1289L26.9614 43.1044L25.9722 42.958ZM26.0107 42.6981L26.9999 42.8445L27.0033 42.8219L27.0056 42.7992L26.0107 42.6981ZM26.0393 42.4167L27.0342 42.5178L27.0363 42.4969L27.0375 42.4759L26.0393 42.4167ZM25.2174 38.5922L26.0512 38.0401L26.0333 38.013L26.0136 37.9871L25.2174 38.5922ZM26.0573 42.1132L27.0555 42.1723L27.0567 42.1529L27.0571 42.1335L26.0573 42.1132ZM33.7282 55.0816L34.4575 55.7657L34.4732 55.749L34.4881 55.7316L33.7282 55.0816ZM25.3385 38.7751L26.1949 38.2587L26.184 38.2406L26.1723 38.223L25.3385 38.7751ZM25.4313 38.929L24.5749 39.4454L24.5797 39.4532L25.4313 38.929ZM26.0639 41.7868L27.0637 41.8071L27.0641 41.7871L27.0637 41.767L26.0639 41.7868ZM25.5352 39.0977L26.4259 38.6432L26.4077 38.6075L26.3867 38.5734L25.5352 39.0977ZM26.0571 41.4406L27.0569 41.4209L27.0565 41.3986L27.055 41.3763L26.0571 41.4406ZM25.6328 39.2891L26.5473 38.8846L26.5362 38.8592L26.5236 38.8346L25.6328 39.2891ZM26.0359 41.1122L25.0372 41.1641L25.038 41.1764L26.0359 41.1122ZM25.7227 39.4922L26.65 39.118L26.6439 39.1028L26.6372 39.0877L25.7227 39.4922ZM26.0195 40.7969L27.0182 40.7449L27.0175 40.7315L27.0164 40.7182L26.0195 40.7969ZM25.7933 39.6672L26.7425 39.3527L26.7325 39.3226L26.7207 39.2931L25.7933 39.6672ZM25.8867 39.9492L26.8628 39.732L26.8519 39.6827L26.836 39.6347L25.8867 39.9492ZM25.9961 40.5L26.993 40.4213L26.9895 40.3775L26.9823 40.3342L25.9961 40.5ZM25.9553 40.2576L26.9415 40.0918L26.9372 40.0659L26.9315 40.0403L25.9553 40.2576ZM33.189 55.6563L33.8008 56.4474L33.8638 56.3986L33.9184 56.3404L33.189 55.6563ZM26.7918 26.0156L27.231 25.1172L27.1728 25.0887L27.1114 25.068L26.7918 26.0156ZM34.6257 53.8507L35.4798 54.3707L35.4876 54.358L35.4949 54.3451L34.6257 53.8507ZM34.2419 54.481L35.0018 55.131L35.0542 55.0698L35.0961 55.001L34.2419 54.481ZM28.5868 26.9772L29.1342 26.1403L29.1169 26.129L29.0991 26.1184L28.5868 26.9772ZM29.3914 27.5035L30.0186 26.7247L29.9802 26.6937L29.9388 26.6667L29.3914 27.5035ZM35.0117 53.1719L35.881 53.6662L35.9028 53.6279L35.9211 53.5878L35.0117 53.1719ZM30.1135 28.085L29.4863 28.8639L29.493 28.8693L29.4997 28.8745L30.1135 28.085ZM35.9463 50.4274L36.9123 50.6858L36.9205 50.6551L36.9268 50.624L35.9463 50.4274ZM35.6514 51.53L36.5964 51.8572L36.6081 51.8232L36.6174 51.7884L35.6514 51.53ZM36.3101 48.5659L37.2925 48.7527L37.2989 48.7191L37.3029 48.685L36.3101 48.5659ZM36.1359 49.4813L37.1165 49.6779L37.1183 49.6682L36.1359 49.4813ZM31.4203 29.2337L32.1796 28.5829L32.1514 28.55L32.1204 28.5197L31.4203 29.2337ZM31.9588 29.862L31.1996 30.5128L31.2055 30.5197L31.2116 30.5265L31.9588 29.862ZM36.6258 44.786L37.6248 44.8301L37.6266 44.7902L37.6252 44.7503L36.6258 44.786ZM33.0102 31.2082L33.8612 30.6831L33.8481 30.6619L33.834 30.6413L33.0102 31.2082ZM36.5192 46.7033L37.5139 46.8068L37.5159 46.7876L37.5171 46.7683L36.5192 46.7033ZM36.4255 47.6037L37.4184 47.7229L37.4193 47.7151L37.4202 47.7072L36.4255 47.6037ZM32.5112 30.483L33.335 29.9162L33.2997 29.8649L33.2584 29.8185L32.5112 30.483ZM36.5873 45.6579L37.5852 45.7229L37.5859 45.7124L37.5864 45.7019L36.5873 45.6579ZM33.6443 32.236L34.5256 31.7634L34.5113 31.7367L34.4954 31.7109L33.6443 32.236ZM34.3308 33.5161L35.2277 33.0738L35.2201 33.0585L35.212 33.0434L34.3308 33.5161ZM36.5536 42.6536L37.5531 42.6216L37.5519 42.5854L37.5482 42.5494L36.5536 42.6536ZM36.5873 43.709L35.5878 43.741L35.588 43.7447L36.5873 43.709ZM36.2661 40.2967L35.2743 40.4247L35.2752 40.4312L36.2661 40.2967ZM35.0038 34.9807L35.9524 34.6645L35.9394 34.6253L35.9231 34.5873L35.0038 34.9807ZM36.4436 41.6036L37.4381 41.4994L37.4365 41.4842L37.4345 41.4691L36.4436 41.6036ZM35.8615 37.937L36.8432 37.7468L36.8386 37.7228L36.8328 37.6991L35.8615 37.937ZM35.6394 37.0303L36.6107 36.7924L36.6057 36.7723L36.6 36.7524L35.6394 37.0303ZM36.1614 39.4844L37.1531 39.3565L37.1491 39.3252L37.1431 39.2942L36.1614 39.4844ZM34.6808 34.2258L35.6001 33.8324L35.5895 33.8077L35.5776 33.7835L34.6808 34.2258ZM21.4984 68.1285L10.7261 65.6285L10.2739 67.5767L21.0462 70.0767L21.4984 68.1285ZM11.5 66.6026L11.5 22.1026L9.5 22.1026L9.5 66.6026L11.5 66.6026ZM20.0992 55.6714L20.2724 69.1154L22.2722 69.0897L22.0991 55.6456L20.0992 55.6714ZM20.1559 36.6766L20.1302 44.2601L22.1302 44.2669L22.1559 36.6834L20.1559 36.6766ZM23.6054 36.2999L21.4142 35.714L20.8976 37.6461L23.0887 38.232L23.6054 36.2999ZM26.5973 56.0229L25.3408 55.6383L24.7554 57.5507L26.0119 57.9353L26.5973 56.0229ZM25.2787 55.6214L21.3298 54.6855L20.8685 56.6316L24.8175 57.5675L25.2787 55.6214ZM23.8434 36.3763L23.6583 36.3156L23.0358 38.2163L23.221 38.2769L23.8434 36.3763ZM24.1015 36.4799L23.9143 36.4025L23.1501 38.2507L23.3374 38.3281L24.1015 36.4799ZM24.3514 36.6011L24.1636 36.508L23.2753 38.3L23.4631 38.3931L24.3514 36.6011ZM24.516 36.6827L24.3513 36.6011L23.4632 38.3931L23.628 38.4748L24.516 36.6827ZM20.8619 45.2269L22.4744 45.676L23.0111 43.7493L21.3985 43.3002L20.8619 45.2269ZM24.6991 36.7771L24.5307 36.6901L23.6133 38.4673L23.7817 38.5543L24.6991 36.7771ZM25.0158 36.9956L24.8358 36.8622L23.6451 38.4692L23.8251 38.6025L25.0158 36.9956ZM25.2331 37.1739L25.0589 37.0294L23.7819 38.5687L23.9561 38.7132L25.2331 37.1739ZM25.441 37.3645L25.2742 37.21L23.915 38.6772L24.0818 38.8317L25.441 37.3645ZM25.5583 37.4591L25.3979 37.3267L24.125 38.8694L24.2855 39.0018L25.5583 37.4591ZM25.8362 37.7575L25.6756 37.5733L24.1681 38.8877L24.3287 39.0718L25.8362 37.7575ZM22.5191 45.6873L22.78 45.7472L23.2274 43.7979L22.9664 43.738L22.5191 45.6873ZM22.8854 45.7655L23.0651 45.7869L23.3015 43.8009L23.1219 43.7795L22.8854 45.7655ZM23.1137 45.7915L23.2976 45.8043L23.4368 43.8092L23.2529 43.7963L23.1137 45.7915ZM23.3007 45.8045L23.4932 45.8174L23.6262 43.8218L23.4337 43.809L23.3007 45.8045ZM23.5875 45.8192L23.7414 45.8149L23.6859 43.8157L23.5319 43.82L23.5875 45.8192ZM23.7137 45.8153L23.9062 45.8153L23.9062 43.8153L23.7137 43.8153L23.7137 45.8153ZM23.9516 45.8143L24.1398 45.8057L24.0489 43.8078L23.8607 43.8163L23.9516 45.8143ZM24.1817 45.8029L24.4255 45.7815L24.2508 43.7892L24.007 43.8106L24.1817 45.8029ZM24.4968 45.7727L24.7364 45.7342L24.419 43.7595L24.1795 43.798L24.4968 45.7727ZM27.7699 56.2732L27.2058 56.145L26.7625 58.0953L27.3267 58.2235L27.7699 56.2732ZM27.1874 56.141L26.5078 56L26.1014 57.9582L26.7809 58.0993L27.1874 56.141ZM24.864 45.705L24.9973 45.6652L24.4246 43.7489L24.2914 43.7887L24.864 45.705ZM25.2177 45.5691L25.3426 45.4957L24.3292 43.7715L24.2042 43.8449L25.2177 45.5691ZM29.0755 56.3299L28.0603 56.3318L28.064 58.3318L29.0792 58.3299L29.0755 56.3299ZM28.2224 56.3447L27.7085 56.2613L27.3881 58.2354L27.902 58.3188L28.2224 56.3447ZM10.2787 23.0778L24.3693 26.2751L24.8119 24.3246L10.7213 21.1274L10.2787 23.0778ZM24.2919 26.2542L25.3904 26.5981L25.9879 24.6894L24.8894 24.3455L24.2919 26.2542ZM29.9735 56.2179L29.2683 56.3077L29.5208 58.2916L30.226 58.2019L29.9735 56.2179ZM29.2996 56.3042L28.9823 56.3344L29.1723 58.3254L29.4896 58.2951L29.2996 56.3042ZM31.0675 55.8829L30.4519 56.0881L31.0844 57.9855L31.7 57.7803L31.0675 55.8829ZM30.5175 56.0687L29.849 56.2418L30.3504 58.178L31.0189 58.0049L30.5175 56.0687ZM25.3361 45.4995L25.5471 45.3776L24.5467 43.6458L24.3357 43.7677L25.3361 45.4995ZM25.666 45.297L25.8692 45.1368L24.6308 43.5663L24.4277 43.7264L25.666 45.297ZM31.9979 55.3203L31.3953 55.6922L32.4455 57.3942L33.0481 57.0224L31.9979 55.3203ZM31.4469 55.6624L30.9103 55.9508L31.8572 57.7124L32.3938 57.424L31.4469 55.6624ZM25.9774 45.0378L26.1727 44.8308L24.7179 43.4583L24.5226 43.6653L25.9774 45.0378ZM26.2415 44.7496L26.3899 44.5543L24.7976 43.3441L24.6492 43.5394L26.2415 44.7496ZM26.4367 44.4872L26.5439 44.3192L24.8579 43.2433L24.7508 43.4113L26.4367 44.4872ZM26.5692 44.2774L26.6709 44.0993L24.9344 43.107L24.8327 43.2851L26.5692 44.2774ZM26.7459 43.9354L26.8118 43.7483L24.9254 43.0838L24.8595 43.2709L26.7459 43.9354ZM26.8374 43.6639L26.8934 43.4449L24.9558 42.9493L24.8998 43.1683L26.8374 43.6639ZM26.9054 43.3924L26.953 43.1533L24.9915 42.7627L24.9439 43.0018L26.9054 43.3924ZM26.9614 43.1044L26.9999 42.8445L25.0215 42.5517L24.983 42.8116L26.9614 43.1044ZM27.0056 42.7992L27.0342 42.5178L25.0444 42.3156L25.0158 42.597L27.0056 42.7992ZM26.0136 37.9871L25.8786 37.8096L24.2863 39.0198L24.4213 39.1973L26.0136 37.9871ZM27.0375 42.4759L27.0555 42.1723L25.059 42.054L25.041 42.3576L27.0375 42.4759ZM26.1723 38.223L26.0512 38.0401L24.3837 39.1443L24.5048 39.3272L26.1723 38.223ZM26.2877 38.4126L26.1949 38.2587L24.4822 39.2915L24.575 39.4454L26.2877 38.4126ZM27.0571 42.1335L27.0637 41.8071L25.0641 41.7664L25.0575 42.0928L27.0571 42.1335ZM26.3867 38.5734L26.2829 38.4048L24.5797 39.4532L24.6836 39.6219L26.3867 38.5734ZM27.0637 41.767L27.0569 41.4209L25.0573 41.4603L25.0641 41.8065L27.0637 41.767ZM26.5236 38.8346L26.4259 38.6432L24.6444 39.5521L24.7421 39.7435L26.5236 38.8346ZM27.055 41.3763L27.0339 41.0479L25.038 41.1764L25.0592 41.5049L27.055 41.3763ZM26.6372 39.0877L26.5473 38.8846L24.7183 39.6936L24.8081 39.8967L26.6372 39.0877ZM27.0346 41.0602L27.0182 40.7449L25.0209 40.8489L25.0373 41.1641L27.0346 41.0602ZM26.7207 39.2931L26.65 39.118L24.7953 39.8663L24.8659 40.0414L26.7207 39.2931ZM26.836 39.6347L26.7425 39.3527L24.844 39.9818L24.9375 40.2638L26.836 39.6347ZM27.0164 40.7182L26.993 40.4213L24.9992 40.5787L25.0226 40.8756L27.0164 40.7182ZM26.9315 40.0403L26.8628 39.732L24.9106 40.1664L24.9792 40.4748L26.9315 40.0403ZM26.9823 40.3342L26.9415 40.0918L24.9692 40.4233L25.0099 40.6658L26.9823 40.3342ZM32.9988 54.3974L32.4597 54.9721L33.9184 56.3404L34.4575 55.7657L32.9988 54.3974ZM32.5773 54.8652L31.9112 55.3803L33.1347 56.9624L33.8008 56.4474L32.5773 54.8652ZM25.3697 26.5913L26.4723 26.9631L27.1114 25.068L26.0087 24.6962L25.3697 26.5913ZM26.3526 26.914L27.3666 27.4097L28.2451 25.6129L27.231 25.1172L26.3526 26.914ZM33.7715 53.3307L33.3878 53.9609L35.0961 55.001L35.4798 54.3707L33.7715 53.3307ZM33.482 53.8309L32.9683 54.4315L34.4881 55.7316L35.0018 55.131L33.482 53.8309ZM27.2936 27.3701L28.0745 27.836L29.0991 26.1184L28.3181 25.6525L27.2936 27.3701ZM28.0394 27.814L28.844 28.3404L29.9388 26.6667L29.1342 26.1403L28.0394 27.814ZM34.3958 52.1142L34.1023 52.756L35.9211 53.5878L36.2146 52.946L34.3958 52.1142ZM34.1425 52.6775L33.7564 53.3564L35.4949 54.3451L35.881 53.6662L34.1425 52.6775ZM28.7642 28.2824L29.4863 28.8639L30.7407 27.3062L30.0186 26.7247L28.7642 28.2824ZM29.4997 28.8745L30.1526 29.3821L31.3802 27.8032L30.7273 27.2956L29.4997 28.8745ZM34.9802 50.169L34.6853 51.2717L36.6174 51.7884L36.9123 50.6858L34.9802 50.169ZM34.7064 51.2029L34.3602 52.203L36.2502 52.8572L36.5964 51.8572L34.7064 51.2029ZM35.3277 48.379L35.1536 49.2945L37.1183 49.6682L37.2925 48.7527L35.3277 48.379ZM35.1555 49.2848L34.9658 50.2308L36.9268 50.624L37.1164 49.6779L35.1555 49.2848ZM30.0664 29.3067L30.7203 29.9478L32.1204 28.5197L31.4665 27.8786L30.0664 29.3067ZM30.6611 29.8845L31.1996 30.5128L32.7181 29.2112L32.1796 28.5829L30.6611 29.8845ZM35.5246 46.5998L35.4309 47.5002L37.4202 47.7072L37.5139 46.8068L35.5246 46.5998ZM35.4326 47.4846L35.3172 48.4467L37.3029 48.685L37.4184 47.7229L35.4326 47.4846ZM31.2116 30.5265L31.7639 31.1476L33.2584 29.8185L32.7061 29.1974L31.2116 30.5265ZM31.6874 31.0499L32.1864 31.7751L33.834 30.6413L33.335 29.9162L31.6874 31.0499ZM35.6268 44.7419L35.5883 45.6138L37.5864 45.7019L37.6248 44.8301L35.6268 44.7419ZM35.5894 45.5929L35.5214 46.6383L37.5171 46.7683L37.5852 45.7229L35.5894 45.5929ZM32.1591 31.7333L32.7933 32.7611L34.4954 31.7109L33.8612 30.6831L32.1591 31.7333ZM32.763 32.7086L33.4495 33.9887L35.212 33.0434L34.5256 31.7634L32.763 32.7086ZM35.5541 42.6855L35.5878 43.741L37.5868 43.6771L37.5531 42.6216L35.5541 42.6855ZM35.588 43.7447L35.6264 44.8217L37.6252 44.7503L37.5867 43.6733L35.588 43.7447ZM34.0551 35.2969L34.3777 36.2647L36.2751 35.6323L35.9524 34.6645L34.0551 35.2969ZM35.2752 40.4312L35.4527 41.7382L37.4345 41.4691L37.2571 40.1622L35.2752 40.4312ZM35.449 41.7078L35.559 42.7578L37.5482 42.5494L37.4381 41.4994L35.449 41.7078ZM34.3658 36.2264L34.6788 37.3082L36.6 36.7524L36.287 35.6706L34.3658 36.2264ZM34.6681 37.2682L34.8902 38.1749L36.8328 37.6991L36.6107 36.7924L34.6681 37.2682ZM34.8797 38.1273L35.1796 39.6747L37.1431 39.2942L36.8432 37.7468L34.8797 38.1273ZM35.1696 39.6124L35.2744 40.4247L37.2579 40.1687L37.1531 39.3565L35.1696 39.6124ZM33.4339 33.9583L33.7839 34.6681L35.5776 33.7835L35.2277 33.0738L33.4339 33.9583ZM33.7614 34.6192L34.0844 35.3741L35.9231 34.5873L35.6001 33.8324L33.7614 34.6192Z"}" fill="${"white"}" mask="${"url(#path-3-inside-1_1075_131)"}" class="${"svg-elem-7"}"></path></svg></div>`;
    });
    subscriber_queue2 = [];
    logoActive = writable2(0);
    REVISION = "142";
    MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
    TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
    PCFSoftShadowMap = 2;
    FrontSide = 0;
    BackSide = 1;
    DoubleSide = 2;
    FlatShading = 1;
    NormalBlending = 1;
    AddEquation = 100;
    SrcAlphaFactor = 204;
    OneMinusSrcAlphaFactor = 205;
    LessEqualDepth = 3;
    MultiplyOperation = 0;
    NoToneMapping = 0;
    ACESFilmicToneMapping = 4;
    UVMapping = 300;
    RepeatWrapping = 1e3;
    ClampToEdgeWrapping = 1001;
    MirroredRepeatWrapping = 1002;
    NearestFilter = 1003;
    LinearFilter = 1006;
    LinearMipmapLinearFilter = 1008;
    UnsignedByteType = 1009;
    FloatType = 1015;
    HalfFloatType = 1016;
    RGBAFormat = 1023;
    RedFormat = 1028;
    RGFormat = 1030;
    RGB_S3TC_DXT1_Format = 33776;
    RGBA_S3TC_DXT5_Format = 33779;
    RGB_PVRTC_4BPPV1_Format = 35840;
    RGBA_PVRTC_4BPPV1_Format = 35842;
    RGB_ETC1_Format = 36196;
    RGB_ETC2_Format = 37492;
    RGBA_ETC2_EAC_Format = 37496;
    RGBA_ASTC_4x4_Format = 37808;
    RGBA_BPTC_Format = 36492;
    InterpolateDiscrete = 2300;
    InterpolateLinear = 2301;
    InterpolateSmooth = 2302;
    ZeroCurvatureEnding = 2400;
    ZeroSlopeEnding = 2401;
    WrapAroundEnding = 2402;
    AdditiveAnimationBlendMode = 2501;
    LinearEncoding = 3e3;
    sRGBEncoding = 3001;
    TangentSpaceNormalMap = 0;
    SRGBColorSpace = "srgb";
    LinearSRGBColorSpace = "srgb-linear";
    KeepStencilOp = 7680;
    AlwaysStencilFunc = 519;
    StaticDrawUsage = 35044;
    EventDispatcher = class {
      addEventListener(type, listener) {
        if (this._listeners === void 0)
          this._listeners = {};
        const listeners = this._listeners;
        if (listeners[type] === void 0) {
          listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
          listeners[type].push(listener);
        }
      }
      hasEventListener(type, listener) {
        if (this._listeners === void 0)
          return false;
        const listeners = this._listeners;
        return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
      }
      removeEventListener(type, listener) {
        if (this._listeners === void 0)
          return;
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== void 0) {
          const index7 = listenerArray.indexOf(listener);
          if (index7 !== -1) {
            listenerArray.splice(index7, 1);
          }
        }
      }
      dispatchEvent(event) {
        if (this._listeners === void 0)
          return;
        const listeners = this._listeners;
        const listenerArray = listeners[event.type];
        if (listenerArray !== void 0) {
          event.target = this;
          const array2 = listenerArray.slice(0);
          for (let i22 = 0, l2 = array2.length; i22 < l2; i22++) {
            array2[i22].call(this, event);
          }
          event.target = null;
        }
      }
    };
    _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
    _seed = 1234567;
    DEG2RAD = Math.PI / 180;
    RAD2DEG = 180 / Math.PI;
    MathUtils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      DEG2RAD,
      RAD2DEG,
      generateUUID,
      clamp,
      euclideanModulo,
      mapLinear,
      inverseLerp,
      lerp,
      damp,
      pingpong,
      smoothstep,
      smootherstep,
      randInt,
      randFloat,
      randFloatSpread,
      seededRandom,
      degToRad,
      radToDeg,
      isPowerOfTwo,
      ceilPowerOfTwo,
      floorPowerOfTwo,
      setQuaternionFromProperEuler,
      normalize: normalize2,
      denormalize: denormalize$1
    });
    Vector2 = class {
      constructor(x22 = 0, y2 = 0) {
        Vector2.prototype.isVector2 = true;
        this.x = x22;
        this.y = y2;
      }
      get width() {
        return this.x;
      }
      set width(value) {
        this.x = value;
      }
      get height() {
        return this.y;
      }
      set height(value) {
        this.y = value;
      }
      set(x22, y2) {
        this.x = x22;
        this.y = y2;
        return this;
      }
      setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
      }
      setX(x22) {
        this.x = x22;
        return this;
      }
      setY(y2) {
        this.y = y2;
        return this;
      }
      setComponent(index7, value) {
        switch (index7) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          default:
            throw new Error("index is out of range: " + index7);
        }
        return this;
      }
      getComponent(index7) {
        switch (index7) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + index7);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      copy(v2) {
        this.x = v2.x;
        this.y = v2.y;
        return this;
      }
      add(v2, w2) {
        if (w2 !== void 0) {
          console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v2, w2);
        }
        this.x += v2.x;
        this.y += v2.y;
        return this;
      }
      addScalar(s22) {
        this.x += s22;
        this.y += s22;
        return this;
      }
      addVectors(a2, b2) {
        this.x = a2.x + b2.x;
        this.y = a2.y + b2.y;
        return this;
      }
      addScaledVector(v2, s22) {
        this.x += v2.x * s22;
        this.y += v2.y * s22;
        return this;
      }
      sub(v2, w2) {
        if (w2 !== void 0) {
          console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v2, w2);
        }
        this.x -= v2.x;
        this.y -= v2.y;
        return this;
      }
      subScalar(s22) {
        this.x -= s22;
        this.y -= s22;
        return this;
      }
      subVectors(a2, b2) {
        this.x = a2.x - b2.x;
        this.y = a2.y - b2.y;
        return this;
      }
      multiply(v2) {
        this.x *= v2.x;
        this.y *= v2.y;
        return this;
      }
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
      }
      divide(v2) {
        this.x /= v2.x;
        this.y /= v2.y;
        return this;
      }
      divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
      applyMatrix3(m22) {
        const x22 = this.x, y2 = this.y;
        const e22 = m22.elements;
        this.x = e22[0] * x22 + e22[3] * y2 + e22[6];
        this.y = e22[1] * x22 + e22[4] * y2 + e22[7];
        return this;
      }
      min(v2) {
        this.x = Math.min(this.x, v2.x);
        this.y = Math.min(this.y, v2.y);
        return this;
      }
      max(v2) {
        this.x = Math.max(this.x, v2.x);
        this.y = Math.max(this.y, v2.y);
        return this;
      }
      clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
      }
      clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
      }
      clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      }
      floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      }
      ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      }
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      }
      roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
      }
      negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      }
      dot(v2) {
        return this.x * v2.x + this.y * v2.y;
      }
      cross(v2) {
        return this.x * v2.y - this.y * v2.x;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      angle() {
        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
      }
      distanceTo(v2) {
        return Math.sqrt(this.distanceToSquared(v2));
      }
      distanceToSquared(v2) {
        const dx = this.x - v2.x, dy = this.y - v2.y;
        return dx * dx + dy * dy;
      }
      manhattanDistanceTo(v2) {
        return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
      }
      setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
      lerp(v2, alpha) {
        this.x += (v2.x - this.x) * alpha;
        this.y += (v2.y - this.y) * alpha;
        return this;
      }
      lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
      }
      equals(v2) {
        return v2.x === this.x && v2.y === this.y;
      }
      fromArray(array2, offset = 0) {
        this.x = array2[offset];
        this.y = array2[offset + 1];
        return this;
      }
      toArray(array2 = [], offset = 0) {
        array2[offset] = this.x;
        array2[offset + 1] = this.y;
        return array2;
      }
      fromBufferAttribute(attribute, index7, offset) {
        if (offset !== void 0) {
          console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index7);
        this.y = attribute.getY(index7);
        return this;
      }
      rotateAround(center, angle) {
        const c2 = Math.cos(angle), s22 = Math.sin(angle);
        const x22 = this.x - center.x;
        const y2 = this.y - center.y;
        this.x = x22 * c2 - y2 * s22 + center.x;
        this.y = x22 * s22 + y2 * c2 + center.y;
        return this;
      }
      random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
      }
      *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
      }
    };
    Matrix3 = class {
      constructor() {
        Matrix3.prototype.isMatrix3 = true;
        this.elements = [
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ];
        if (arguments.length > 0) {
          console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
        }
      }
      set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        const te2 = this.elements;
        te2[0] = n11;
        te2[1] = n21;
        te2[2] = n31;
        te2[3] = n12;
        te2[4] = n22;
        te2[5] = n32;
        te2[6] = n13;
        te2[7] = n23;
        te2[8] = n33;
        return this;
      }
      identity() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
      }
      copy(m22) {
        const te2 = this.elements;
        const me2 = m22.elements;
        te2[0] = me2[0];
        te2[1] = me2[1];
        te2[2] = me2[2];
        te2[3] = me2[3];
        te2[4] = me2[4];
        te2[5] = me2[5];
        te2[6] = me2[6];
        te2[7] = me2[7];
        te2[8] = me2[8];
        return this;
      }
      extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrix3Column(this, 0);
        yAxis.setFromMatrix3Column(this, 1);
        zAxis.setFromMatrix3Column(this, 2);
        return this;
      }
      setFromMatrix4(m22) {
        const me2 = m22.elements;
        this.set(me2[0], me2[4], me2[8], me2[1], me2[5], me2[9], me2[2], me2[6], me2[10]);
        return this;
      }
      multiply(m22) {
        return this.multiplyMatrices(this, m22);
      }
      premultiply(m22) {
        return this.multiplyMatrices(m22, this);
      }
      multiplyMatrices(a2, b2) {
        const ae2 = a2.elements;
        const be2 = b2.elements;
        const te2 = this.elements;
        const a11 = ae2[0], a12 = ae2[3], a13 = ae2[6];
        const a21 = ae2[1], a22 = ae2[4], a23 = ae2[7];
        const a31 = ae2[2], a32 = ae2[5], a33 = ae2[8];
        const b11 = be2[0], b12 = be2[3], b13 = be2[6];
        const b21 = be2[1], b22 = be2[4], b23 = be2[7];
        const b31 = be2[2], b32 = be2[5], b33 = be2[8];
        te2[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te2[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te2[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te2[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te2[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te2[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te2[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te2[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te2[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
      }
      multiplyScalar(s22) {
        const te2 = this.elements;
        te2[0] *= s22;
        te2[3] *= s22;
        te2[6] *= s22;
        te2[1] *= s22;
        te2[4] *= s22;
        te2[7] *= s22;
        te2[2] *= s22;
        te2[5] *= s22;
        te2[8] *= s22;
        return this;
      }
      determinant() {
        const te2 = this.elements;
        const a2 = te2[0], b2 = te2[1], c2 = te2[2], d2 = te2[3], e22 = te2[4], f22 = te2[5], g2 = te2[6], h22 = te2[7], i22 = te2[8];
        return a2 * e22 * i22 - a2 * f22 * h22 - b2 * d2 * i22 + b2 * f22 * g2 + c2 * d2 * h22 - c2 * e22 * g2;
      }
      invert() {
        const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n12 = te2[3], n22 = te2[4], n32 = te2[5], n13 = te2[6], n23 = te2[7], n33 = te2[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te2[0] = t11 * detInv;
        te2[1] = (n31 * n23 - n33 * n21) * detInv;
        te2[2] = (n32 * n21 - n31 * n22) * detInv;
        te2[3] = t12 * detInv;
        te2[4] = (n33 * n11 - n31 * n13) * detInv;
        te2[5] = (n31 * n12 - n32 * n11) * detInv;
        te2[6] = t13 * detInv;
        te2[7] = (n21 * n13 - n23 * n11) * detInv;
        te2[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
      }
      transpose() {
        let tmp;
        const m22 = this.elements;
        tmp = m22[1];
        m22[1] = m22[3];
        m22[3] = tmp;
        tmp = m22[2];
        m22[2] = m22[6];
        m22[6] = tmp;
        tmp = m22[5];
        m22[5] = m22[7];
        m22[7] = tmp;
        return this;
      }
      getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).invert().transpose();
      }
      transposeIntoArray(r22) {
        const m22 = this.elements;
        r22[0] = m22[0];
        r22[1] = m22[3];
        r22[2] = m22[6];
        r22[3] = m22[1];
        r22[4] = m22[4];
        r22[5] = m22[7];
        r22[6] = m22[2];
        r22[7] = m22[5];
        r22[8] = m22[8];
        return this;
      }
      setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
        const c2 = Math.cos(rotation);
        const s22 = Math.sin(rotation);
        this.set(sx * c2, sx * s22, -sx * (c2 * cx + s22 * cy) + cx + tx, -sy * s22, sy * c2, -sy * (-s22 * cx + c2 * cy) + cy + ty, 0, 0, 1);
        return this;
      }
      scale(sx, sy) {
        const te2 = this.elements;
        te2[0] *= sx;
        te2[3] *= sx;
        te2[6] *= sx;
        te2[1] *= sy;
        te2[4] *= sy;
        te2[7] *= sy;
        return this;
      }
      rotate(theta) {
        const c2 = Math.cos(theta);
        const s22 = Math.sin(theta);
        const te2 = this.elements;
        const a11 = te2[0], a12 = te2[3], a13 = te2[6];
        const a21 = te2[1], a22 = te2[4], a23 = te2[7];
        te2[0] = c2 * a11 + s22 * a21;
        te2[3] = c2 * a12 + s22 * a22;
        te2[6] = c2 * a13 + s22 * a23;
        te2[1] = -s22 * a11 + c2 * a21;
        te2[4] = -s22 * a12 + c2 * a22;
        te2[7] = -s22 * a13 + c2 * a23;
        return this;
      }
      translate(tx, ty) {
        const te2 = this.elements;
        te2[0] += tx * te2[2];
        te2[3] += tx * te2[5];
        te2[6] += tx * te2[8];
        te2[1] += ty * te2[2];
        te2[4] += ty * te2[5];
        te2[7] += ty * te2[8];
        return this;
      }
      equals(matrix) {
        const te2 = this.elements;
        const me2 = matrix.elements;
        for (let i22 = 0; i22 < 9; i22++) {
          if (te2[i22] !== me2[i22])
            return false;
        }
        return true;
      }
      fromArray(array2, offset = 0) {
        for (let i22 = 0; i22 < 9; i22++) {
          this.elements[i22] = array2[i22 + offset];
        }
        return this;
      }
      toArray(array2 = [], offset = 0) {
        const te2 = this.elements;
        array2[offset] = te2[0];
        array2[offset + 1] = te2[1];
        array2[offset + 2] = te2[2];
        array2[offset + 3] = te2[3];
        array2[offset + 4] = te2[4];
        array2[offset + 5] = te2[5];
        array2[offset + 6] = te2[6];
        array2[offset + 7] = te2[7];
        array2[offset + 8] = te2[8];
        return array2;
      }
      clone() {
        return new this.constructor().fromArray(this.elements);
      }
    };
    FN = {
      [SRGBColorSpace]: { [LinearSRGBColorSpace]: SRGBToLinear },
      [LinearSRGBColorSpace]: { [SRGBColorSpace]: LinearToSRGB }
    };
    ColorManagement = {
      legacyMode: true,
      get workingColorSpace() {
        return LinearSRGBColorSpace;
      },
      set workingColorSpace(colorSpace) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
      },
      convert: function(color, sourceColorSpace, targetColorSpace) {
        if (this.legacyMode || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
          return color;
        }
        if (FN[sourceColorSpace] && FN[sourceColorSpace][targetColorSpace] !== void 0) {
          const fn2 = FN[sourceColorSpace][targetColorSpace];
          color.r = fn2(color.r);
          color.g = fn2(color.g);
          color.b = fn2(color.b);
          return color;
        }
        throw new Error("Unsupported color space conversion.");
      },
      fromWorkingColorSpace: function(color, targetColorSpace) {
        return this.convert(color, this.workingColorSpace, targetColorSpace);
      },
      toWorkingColorSpace: function(color, sourceColorSpace) {
        return this.convert(color, sourceColorSpace, this.workingColorSpace);
      }
    };
    _colorKeywords = {
      "aliceblue": 15792383,
      "antiquewhite": 16444375,
      "aqua": 65535,
      "aquamarine": 8388564,
      "azure": 15794175,
      "beige": 16119260,
      "bisque": 16770244,
      "black": 0,
      "blanchedalmond": 16772045,
      "blue": 255,
      "blueviolet": 9055202,
      "brown": 10824234,
      "burlywood": 14596231,
      "cadetblue": 6266528,
      "chartreuse": 8388352,
      "chocolate": 13789470,
      "coral": 16744272,
      "cornflowerblue": 6591981,
      "cornsilk": 16775388,
      "crimson": 14423100,
      "cyan": 65535,
      "darkblue": 139,
      "darkcyan": 35723,
      "darkgoldenrod": 12092939,
      "darkgray": 11119017,
      "darkgreen": 25600,
      "darkgrey": 11119017,
      "darkkhaki": 12433259,
      "darkmagenta": 9109643,
      "darkolivegreen": 5597999,
      "darkorange": 16747520,
      "darkorchid": 10040012,
      "darkred": 9109504,
      "darksalmon": 15308410,
      "darkseagreen": 9419919,
      "darkslateblue": 4734347,
      "darkslategray": 3100495,
      "darkslategrey": 3100495,
      "darkturquoise": 52945,
      "darkviolet": 9699539,
      "deeppink": 16716947,
      "deepskyblue": 49151,
      "dimgray": 6908265,
      "dimgrey": 6908265,
      "dodgerblue": 2003199,
      "firebrick": 11674146,
      "floralwhite": 16775920,
      "forestgreen": 2263842,
      "fuchsia": 16711935,
      "gainsboro": 14474460,
      "ghostwhite": 16316671,
      "gold": 16766720,
      "goldenrod": 14329120,
      "gray": 8421504,
      "green": 32768,
      "greenyellow": 11403055,
      "grey": 8421504,
      "honeydew": 15794160,
      "hotpink": 16738740,
      "indianred": 13458524,
      "indigo": 4915330,
      "ivory": 16777200,
      "khaki": 15787660,
      "lavender": 15132410,
      "lavenderblush": 16773365,
      "lawngreen": 8190976,
      "lemonchiffon": 16775885,
      "lightblue": 11393254,
      "lightcoral": 15761536,
      "lightcyan": 14745599,
      "lightgoldenrodyellow": 16448210,
      "lightgray": 13882323,
      "lightgreen": 9498256,
      "lightgrey": 13882323,
      "lightpink": 16758465,
      "lightsalmon": 16752762,
      "lightseagreen": 2142890,
      "lightskyblue": 8900346,
      "lightslategray": 7833753,
      "lightslategrey": 7833753,
      "lightsteelblue": 11584734,
      "lightyellow": 16777184,
      "lime": 65280,
      "limegreen": 3329330,
      "linen": 16445670,
      "magenta": 16711935,
      "maroon": 8388608,
      "mediumaquamarine": 6737322,
      "mediumblue": 205,
      "mediumorchid": 12211667,
      "mediumpurple": 9662683,
      "mediumseagreen": 3978097,
      "mediumslateblue": 8087790,
      "mediumspringgreen": 64154,
      "mediumturquoise": 4772300,
      "mediumvioletred": 13047173,
      "midnightblue": 1644912,
      "mintcream": 16121850,
      "mistyrose": 16770273,
      "moccasin": 16770229,
      "navajowhite": 16768685,
      "navy": 128,
      "oldlace": 16643558,
      "olive": 8421376,
      "olivedrab": 7048739,
      "orange": 16753920,
      "orangered": 16729344,
      "orchid": 14315734,
      "palegoldenrod": 15657130,
      "palegreen": 10025880,
      "paleturquoise": 11529966,
      "palevioletred": 14381203,
      "papayawhip": 16773077,
      "peachpuff": 16767673,
      "peru": 13468991,
      "pink": 16761035,
      "plum": 14524637,
      "powderblue": 11591910,
      "purple": 8388736,
      "rebeccapurple": 6697881,
      "red": 16711680,
      "rosybrown": 12357519,
      "royalblue": 4286945,
      "saddlebrown": 9127187,
      "salmon": 16416882,
      "sandybrown": 16032864,
      "seagreen": 3050327,
      "seashell": 16774638,
      "sienna": 10506797,
      "silver": 12632256,
      "skyblue": 8900331,
      "slateblue": 6970061,
      "slategray": 7372944,
      "slategrey": 7372944,
      "snow": 16775930,
      "springgreen": 65407,
      "steelblue": 4620980,
      "tan": 13808780,
      "teal": 32896,
      "thistle": 14204888,
      "tomato": 16737095,
      "turquoise": 4251856,
      "violet": 15631086,
      "wheat": 16113331,
      "white": 16777215,
      "whitesmoke": 16119285,
      "yellow": 16776960,
      "yellowgreen": 10145074
    };
    _rgb = { r: 0, g: 0, b: 0 };
    _hslA = { h: 0, s: 0, l: 0 };
    _hslB = { h: 0, s: 0, l: 0 };
    Color = class {
      constructor(r22, g2, b2) {
        this.isColor = true;
        this.r = 1;
        this.g = 1;
        this.b = 1;
        if (g2 === void 0 && b2 === void 0) {
          return this.set(r22);
        }
        return this.setRGB(r22, g2, b2);
      }
      set(value) {
        if (value && value.isColor) {
          this.copy(value);
        } else if (typeof value === "number") {
          this.setHex(value);
        } else if (typeof value === "string") {
          this.setStyle(value);
        }
        return this;
      }
      setScalar(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
      }
      setHex(hex, colorSpace = SRGBColorSpace) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      }
      setRGB(r22, g2, b2, colorSpace = LinearSRGBColorSpace) {
        this.r = r22;
        this.g = g2;
        this.b = b2;
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      }
      setHSL(h22, s22, l2, colorSpace = LinearSRGBColorSpace) {
        h22 = euclideanModulo(h22, 1);
        s22 = clamp(s22, 0, 1);
        l2 = clamp(l2, 0, 1);
        if (s22 === 0) {
          this.r = this.g = this.b = l2;
        } else {
          const p2 = l2 <= 0.5 ? l2 * (1 + s22) : l2 + s22 - l2 * s22;
          const q2 = 2 * l2 - p2;
          this.r = hue2rgb(q2, p2, h22 + 1 / 3);
          this.g = hue2rgb(q2, p2, h22);
          this.b = hue2rgb(q2, p2, h22 - 1 / 3);
        }
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      }
      setStyle(style, colorSpace = SRGBColorSpace) {
        function handleAlpha(string) {
          if (string === void 0)
            return;
          if (parseFloat(string) < 1) {
            console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
          }
        }
        let m22;
        if (m22 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
          let color;
          const name = m22[1];
          const components = m22[2];
          switch (name) {
            case "rgb":
            case "rgba":
              if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                ColorManagement.toWorkingColorSpace(this, colorSpace);
                handleAlpha(color[4]);
                return this;
              }
              if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                ColorManagement.toWorkingColorSpace(this, colorSpace);
                handleAlpha(color[4]);
                return this;
              }
              break;
            case "hsl":
            case "hsla":
              if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                const h22 = parseFloat(color[1]) / 360;
                const s22 = parseInt(color[2], 10) / 100;
                const l2 = parseInt(color[3], 10) / 100;
                handleAlpha(color[4]);
                return this.setHSL(h22, s22, l2, colorSpace);
              }
              break;
          }
        } else if (m22 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
          const hex = m22[1];
          const size = hex.length;
          if (size === 3) {
            this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
            this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
            this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
            ColorManagement.toWorkingColorSpace(this, colorSpace);
            return this;
          } else if (size === 6) {
            this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
            this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
            this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
            ColorManagement.toWorkingColorSpace(this, colorSpace);
            return this;
          }
        }
        if (style && style.length > 0) {
          return this.setColorName(style, colorSpace);
        }
        return this;
      }
      setColorName(style, colorSpace = SRGBColorSpace) {
        const hex = _colorKeywords[style.toLowerCase()];
        if (hex !== void 0) {
          this.setHex(hex, colorSpace);
        } else {
          console.warn("THREE.Color: Unknown color " + style);
        }
        return this;
      }
      clone() {
        return new this.constructor(this.r, this.g, this.b);
      }
      copy(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
      }
      copySRGBToLinear(color) {
        this.r = SRGBToLinear(color.r);
        this.g = SRGBToLinear(color.g);
        this.b = SRGBToLinear(color.b);
        return this;
      }
      copyLinearToSRGB(color) {
        this.r = LinearToSRGB(color.r);
        this.g = LinearToSRGB(color.g);
        this.b = LinearToSRGB(color.b);
        return this;
      }
      convertSRGBToLinear() {
        this.copySRGBToLinear(this);
        return this;
      }
      convertLinearToSRGB() {
        this.copyLinearToSRGB(this);
        return this;
      }
      getHex(colorSpace = SRGBColorSpace) {
        ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
        return clamp(_rgb.r * 255, 0, 255) << 16 ^ clamp(_rgb.g * 255, 0, 255) << 8 ^ clamp(_rgb.b * 255, 0, 255) << 0;
      }
      getHexString(colorSpace = SRGBColorSpace) {
        return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
      }
      getHSL(target, colorSpace = LinearSRGBColorSpace) {
        ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
        const r22 = _rgb.r, g2 = _rgb.g, b2 = _rgb.b;
        const max = Math.max(r22, g2, b2);
        const min = Math.min(r22, g2, b2);
        let hue, saturation;
        const lightness = (min + max) / 2;
        if (min === max) {
          hue = 0;
          saturation = 0;
        } else {
          const delta = max - min;
          saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
          switch (max) {
            case r22:
              hue = (g2 - b2) / delta + (g2 < b2 ? 6 : 0);
              break;
            case g2:
              hue = (b2 - r22) / delta + 2;
              break;
            case b2:
              hue = (r22 - g2) / delta + 4;
              break;
          }
          hue /= 6;
        }
        target.h = hue;
        target.s = saturation;
        target.l = lightness;
        return target;
      }
      getRGB(target, colorSpace = LinearSRGBColorSpace) {
        ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
        target.r = _rgb.r;
        target.g = _rgb.g;
        target.b = _rgb.b;
        return target;
      }
      getStyle(colorSpace = SRGBColorSpace) {
        ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
        if (colorSpace !== SRGBColorSpace) {
          return `color(${colorSpace} ${_rgb.r} ${_rgb.g} ${_rgb.b})`;
        }
        return `rgb(${_rgb.r * 255 | 0},${_rgb.g * 255 | 0},${_rgb.b * 255 | 0})`;
      }
      offsetHSL(h22, s22, l2) {
        this.getHSL(_hslA);
        _hslA.h += h22;
        _hslA.s += s22;
        _hslA.l += l2;
        this.setHSL(_hslA.h, _hslA.s, _hslA.l);
        return this;
      }
      add(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
      }
      addColors(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
      }
      addScalar(s22) {
        this.r += s22;
        this.g += s22;
        this.b += s22;
        return this;
      }
      sub(color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
      }
      multiply(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
      }
      multiplyScalar(s22) {
        this.r *= s22;
        this.g *= s22;
        this.b *= s22;
        return this;
      }
      lerp(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
      }
      lerpColors(color1, color2, alpha) {
        this.r = color1.r + (color2.r - color1.r) * alpha;
        this.g = color1.g + (color2.g - color1.g) * alpha;
        this.b = color1.b + (color2.b - color1.b) * alpha;
        return this;
      }
      lerpHSL(color, alpha) {
        this.getHSL(_hslA);
        color.getHSL(_hslB);
        const h22 = lerp(_hslA.h, _hslB.h, alpha);
        const s22 = lerp(_hslA.s, _hslB.s, alpha);
        const l2 = lerp(_hslA.l, _hslB.l, alpha);
        this.setHSL(h22, s22, l2);
        return this;
      }
      equals(c2) {
        return c2.r === this.r && c2.g === this.g && c2.b === this.b;
      }
      fromArray(array2, offset = 0) {
        this.r = array2[offset];
        this.g = array2[offset + 1];
        this.b = array2[offset + 2];
        return this;
      }
      toArray(array2 = [], offset = 0) {
        array2[offset] = this.r;
        array2[offset + 1] = this.g;
        array2[offset + 2] = this.b;
        return array2;
      }
      fromBufferAttribute(attribute, index7) {
        this.r = attribute.getX(index7);
        this.g = attribute.getY(index7);
        this.b = attribute.getZ(index7);
        if (attribute.normalized === true) {
          this.r /= 255;
          this.g /= 255;
          this.b /= 255;
        }
        return this;
      }
      toJSON() {
        return this.getHex();
      }
      *[Symbol.iterator]() {
        yield this.r;
        yield this.g;
        yield this.b;
      }
    };
    Color.NAMES = _colorKeywords;
    ImageUtils = class {
      static getDataURL(image) {
        if (/^data:/i.test(image.src)) {
          return image.src;
        }
        if (typeof HTMLCanvasElement == "undefined") {
          return image.src;
        }
        let canvas;
        if (image instanceof HTMLCanvasElement) {
          canvas = image;
        } else {
          if (_canvas === void 0)
            _canvas = createElementNS("canvas");
          _canvas.width = image.width;
          _canvas.height = image.height;
          const context = _canvas.getContext("2d");
          if (image instanceof ImageData) {
            context.putImageData(image, 0, 0);
          } else {
            context.drawImage(image, 0, 0, image.width, image.height);
          }
          canvas = _canvas;
        }
        if (canvas.width > 2048 || canvas.height > 2048) {
          console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
          return canvas.toDataURL("image/jpeg", 0.6);
        } else {
          return canvas.toDataURL("image/png");
        }
      }
      static sRGBToLinear(image) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          const canvas = createElementNS("canvas");
          canvas.width = image.width;
          canvas.height = image.height;
          const context = canvas.getContext("2d");
          context.drawImage(image, 0, 0, image.width, image.height);
          const imageData = context.getImageData(0, 0, image.width, image.height);
          const data = imageData.data;
          for (let i22 = 0; i22 < data.length; i22++) {
            data[i22] = SRGBToLinear(data[i22] / 255) * 255;
          }
          context.putImageData(imageData, 0, 0);
          return canvas;
        } else if (image.data) {
          const data = image.data.slice(0);
          for (let i22 = 0; i22 < data.length; i22++) {
            if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
              data[i22] = Math.floor(SRGBToLinear(data[i22] / 255) * 255);
            } else {
              data[i22] = SRGBToLinear(data[i22]);
            }
          }
          return {
            data,
            width: image.width,
            height: image.height
          };
        } else {
          console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
          return image;
        }
      }
    };
    Source = class {
      constructor(data = null) {
        this.isSource = true;
        this.uuid = generateUUID();
        this.data = data;
        this.version = 0;
      }
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      }
      toJSON(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        if (!isRootObject && meta.images[this.uuid] !== void 0) {
          return meta.images[this.uuid];
        }
        const output = {
          uuid: this.uuid,
          url: ""
        };
        const data = this.data;
        if (data !== null) {
          let url;
          if (Array.isArray(data)) {
            url = [];
            for (let i22 = 0, l2 = data.length; i22 < l2; i22++) {
              if (data[i22].isDataTexture) {
                url.push(serializeImage(data[i22].image));
              } else {
                url.push(serializeImage(data[i22]));
              }
            }
          } else {
            url = serializeImage(data);
          }
          output.url = url;
        }
        if (!isRootObject) {
          meta.images[this.uuid] = output;
        }
        return output;
      }
    };
    textureId = 0;
    Texture = class extends EventDispatcher {
      constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format2 = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
        super();
        this.isTexture = true;
        Object.defineProperty(this, "id", { value: textureId++ });
        this.uuid = generateUUID();
        this.name = "";
        this.source = new Source(image);
        this.mipmaps = [];
        this.mapping = mapping;
        this.wrapS = wrapS;
        this.wrapT = wrapT;
        this.magFilter = magFilter;
        this.minFilter = minFilter;
        this.anisotropy = anisotropy;
        this.format = format2;
        this.internalFormat = null;
        this.type = type;
        this.offset = new Vector2(0, 0);
        this.repeat = new Vector2(1, 1);
        this.center = new Vector2(0, 0);
        this.rotation = 0;
        this.matrixAutoUpdate = true;
        this.matrix = new Matrix3();
        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4;
        this.encoding = encoding;
        this.userData = {};
        this.version = 0;
        this.onUpdate = null;
        this.isRenderTargetTexture = false;
        this.needsPMREMUpdate = false;
      }
      get image() {
        return this.source.data;
      }
      set image(value) {
        this.source.data = value;
      }
      updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.name = source.name;
        this.source = source.source;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        this.needsUpdate = true;
        return this;
      }
      toJSON(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        if (!isRootObject && meta.textures[this.uuid] !== void 0) {
          return meta.textures[this.uuid];
        }
        const output = {
          metadata: {
            version: 4.5,
            type: "Texture",
            generator: "Texture.toJSON"
          },
          uuid: this.uuid,
          name: this.name,
          image: this.source.toJSON(meta).uuid,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment
        };
        if (JSON.stringify(this.userData) !== "{}")
          output.userData = this.userData;
        if (!isRootObject) {
          meta.textures[this.uuid] = output;
        }
        return output;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      transformUv(uv) {
        if (this.mapping !== UVMapping)
          return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) {
          switch (this.wrapS) {
            case RepeatWrapping:
              uv.x = uv.x - Math.floor(uv.x);
              break;
            case ClampToEdgeWrapping:
              uv.x = uv.x < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                uv.x = Math.ceil(uv.x) - uv.x;
              } else {
                uv.x = uv.x - Math.floor(uv.x);
              }
              break;
          }
        }
        if (uv.y < 0 || uv.y > 1) {
          switch (this.wrapT) {
            case RepeatWrapping:
              uv.y = uv.y - Math.floor(uv.y);
              break;
            case ClampToEdgeWrapping:
              uv.y = uv.y < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                uv.y = Math.ceil(uv.y) - uv.y;
              } else {
                uv.y = uv.y - Math.floor(uv.y);
              }
              break;
          }
        }
        if (this.flipY) {
          uv.y = 1 - uv.y;
        }
        return uv;
      }
      set needsUpdate(value) {
        if (value === true) {
          this.version++;
          this.source.needsUpdate = true;
        }
      }
    };
    Texture.DEFAULT_IMAGE = null;
    Texture.DEFAULT_MAPPING = UVMapping;
    Vector4 = class {
      constructor(x22 = 0, y2 = 0, z2 = 0, w2 = 1) {
        Vector4.prototype.isVector4 = true;
        this.x = x22;
        this.y = y2;
        this.z = z2;
        this.w = w2;
      }
      get width() {
        return this.z;
      }
      set width(value) {
        this.z = value;
      }
      get height() {
        return this.w;
      }
      set height(value) {
        this.w = value;
      }
      set(x22, y2, z2, w2) {
        this.x = x22;
        this.y = y2;
        this.z = z2;
        this.w = w2;
        return this;
      }
      setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
      }
      setX(x22) {
        this.x = x22;
        return this;
      }
      setY(y2) {
        this.y = y2;
        return this;
      }
      setZ(z2) {
        this.z = z2;
        return this;
      }
      setW(w2) {
        this.w = w2;
        return this;
      }
      setComponent(index7, value) {
        switch (index7) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          case 3:
            this.w = value;
            break;
          default:
            throw new Error("index is out of range: " + index7);
        }
        return this;
      }
      getComponent(index7) {
        switch (index7) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + index7);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
      copy(v2) {
        this.x = v2.x;
        this.y = v2.y;
        this.z = v2.z;
        this.w = v2.w !== void 0 ? v2.w : 1;
        return this;
      }
      add(v2, w2) {
        if (w2 !== void 0) {
          console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v2, w2);
        }
        this.x += v2.x;
        this.y += v2.y;
        this.z += v2.z;
        this.w += v2.w;
        return this;
      }
      addScalar(s22) {
        this.x += s22;
        this.y += s22;
        this.z += s22;
        this.w += s22;
        return this;
      }
      addVectors(a2, b2) {
        this.x = a2.x + b2.x;
        this.y = a2.y + b2.y;
        this.z = a2.z + b2.z;
        this.w = a2.w + b2.w;
        return this;
      }
      addScaledVector(v2, s22) {
        this.x += v2.x * s22;
        this.y += v2.y * s22;
        this.z += v2.z * s22;
        this.w += v2.w * s22;
        return this;
      }
      sub(v2, w2) {
        if (w2 !== void 0) {
          console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v2, w2);
        }
        this.x -= v2.x;
        this.y -= v2.y;
        this.z -= v2.z;
        this.w -= v2.w;
        return this;
      }
      subScalar(s22) {
        this.x -= s22;
        this.y -= s22;
        this.z -= s22;
        this.w -= s22;
        return this;
      }
      subVectors(a2, b2) {
        this.x = a2.x - b2.x;
        this.y = a2.y - b2.y;
        this.z = a2.z - b2.z;
        this.w = a2.w - b2.w;
        return this;
      }
      multiply(v2) {
        this.x *= v2.x;
        this.y *= v2.y;
        this.z *= v2.z;
        this.w *= v2.w;
        return this;
      }
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
      }
      applyMatrix4(m22) {
        const x22 = this.x, y2 = this.y, z2 = this.z, w2 = this.w;
        const e22 = m22.elements;
        this.x = e22[0] * x22 + e22[4] * y2 + e22[8] * z2 + e22[12] * w2;
        this.y = e22[1] * x22 + e22[5] * y2 + e22[9] * z2 + e22[13] * w2;
        this.z = e22[2] * x22 + e22[6] * y2 + e22[10] * z2 + e22[14] * w2;
        this.w = e22[3] * x22 + e22[7] * y2 + e22[11] * z2 + e22[15] * w2;
        return this;
      }
      divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
      setAxisAngleFromQuaternion(q2) {
        this.w = 2 * Math.acos(q2.w);
        const s22 = Math.sqrt(1 - q2.w * q2.w);
        if (s22 < 1e-4) {
          this.x = 1;
          this.y = 0;
          this.z = 0;
        } else {
          this.x = q2.x / s22;
          this.y = q2.y / s22;
          this.z = q2.z / s22;
        }
        return this;
      }
      setAxisAngleFromRotationMatrix(m22) {
        let angle, x22, y2, z2;
        const epsilon = 0.01, epsilon2 = 0.1, te2 = m22.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m222 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
          if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m222 + m33 - 3) < epsilon2) {
            this.set(1, 0, 0, 0);
            return this;
          }
          angle = Math.PI;
          const xx = (m11 + 1) / 2;
          const yy = (m222 + 1) / 2;
          const zz = (m33 + 1) / 2;
          const xy = (m12 + m21) / 4;
          const xz = (m13 + m31) / 4;
          const yz = (m23 + m32) / 4;
          if (xx > yy && xx > zz) {
            if (xx < epsilon) {
              x22 = 0;
              y2 = 0.707106781;
              z2 = 0.707106781;
            } else {
              x22 = Math.sqrt(xx);
              y2 = xy / x22;
              z2 = xz / x22;
            }
          } else if (yy > zz) {
            if (yy < epsilon) {
              x22 = 0.707106781;
              y2 = 0;
              z2 = 0.707106781;
            } else {
              y2 = Math.sqrt(yy);
              x22 = xy / y2;
              z2 = yz / y2;
            }
          } else {
            if (zz < epsilon) {
              x22 = 0.707106781;
              y2 = 0.707106781;
              z2 = 0;
            } else {
              z2 = Math.sqrt(zz);
              x22 = xz / z2;
              y2 = yz / z2;
            }
          }
          this.set(x22, y2, z2, angle);
          return this;
        }
        let s22 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
        if (Math.abs(s22) < 1e-3)
          s22 = 1;
        this.x = (m32 - m23) / s22;
        this.y = (m13 - m31) / s22;
        this.z = (m21 - m12) / s22;
        this.w = Math.acos((m11 + m222 + m33 - 1) / 2);
        return this;
      }
      min(v2) {
        this.x = Math.min(this.x, v2.x);
        this.y = Math.min(this.y, v2.y);
        this.z = Math.min(this.z, v2.z);
        this.w = Math.min(this.w, v2.w);
        return this;
      }
      max(v2) {
        this.x = Math.max(this.x, v2.x);
        this.y = Math.max(this.y, v2.y);
        this.z = Math.max(this.z, v2.z);
        this.w = Math.max(this.w, v2.w);
        return this;
      }
      clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
      }
      clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        this.w = Math.max(minVal, Math.min(maxVal, this.w));
        return this;
      }
      clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      }
      floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
      }
      ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
      }
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
      }
      roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
      }
      negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
      }
      dot(v2) {
        return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
      lerp(v2, alpha) {
        this.x += (v2.x - this.x) * alpha;
        this.y += (v2.y - this.y) * alpha;
        this.z += (v2.z - this.z) * alpha;
        this.w += (v2.w - this.w) * alpha;
        return this;
      }
      lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
      }
      equals(v2) {
        return v2.x === this.x && v2.y === this.y && v2.z === this.z && v2.w === this.w;
      }
      fromArray(array2, offset = 0) {
        this.x = array2[offset];
        this.y = array2[offset + 1];
        this.z = array2[offset + 2];
        this.w = array2[offset + 3];
        return this;
      }
      toArray(array2 = [], offset = 0) {
        array2[offset] = this.x;
        array2[offset + 1] = this.y;
        array2[offset + 2] = this.z;
        array2[offset + 3] = this.w;
        return array2;
      }
      fromBufferAttribute(attribute, index7, offset) {
        if (offset !== void 0) {
          console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index7);
        this.y = attribute.getY(index7);
        this.z = attribute.getZ(index7);
        this.w = attribute.getW(index7);
        return this;
      }
      random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
      }
      *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
        yield this.z;
        yield this.w;
      }
    };
    Data3DTexture = class extends Texture {
      constructor(data = null, width = 1, height = 1, depth = 1) {
        super(null);
        this.isData3DTexture = true;
        this.image = { data, width, height, depth };
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
        this.wrapR = ClampToEdgeWrapping;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
      }
    };
    Quaternion = class {
      constructor(x22 = 0, y2 = 0, z2 = 0, w2 = 1) {
        this.isQuaternion = true;
        this._x = x22;
        this._y = y2;
        this._z = z2;
        this._w = w2;
      }
      static slerp(qa, qb, qm, t22) {
        console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
        return qm.slerpQuaternions(qa, qb, t22);
      }
      static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t22) {
        let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
        if (t22 === 0) {
          dst[dstOffset + 0] = x0;
          dst[dstOffset + 1] = y0;
          dst[dstOffset + 2] = z0;
          dst[dstOffset + 3] = w0;
          return;
        }
        if (t22 === 1) {
          dst[dstOffset + 0] = x1;
          dst[dstOffset + 1] = y1;
          dst[dstOffset + 2] = z1;
          dst[dstOffset + 3] = w1;
          return;
        }
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
          let s22 = 1 - t22;
          const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
          if (sqrSin > Number.EPSILON) {
            const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
            s22 = Math.sin(s22 * len) / sin;
            t22 = Math.sin(t22 * len) / sin;
          }
          const tDir = t22 * dir;
          x0 = x0 * s22 + x1 * tDir;
          y0 = y0 * s22 + y1 * tDir;
          z0 = z0 * s22 + z1 * tDir;
          w0 = w0 * s22 + w1 * tDir;
          if (s22 === 1 - t22) {
            const f22 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
            x0 *= f22;
            y0 *= f22;
            z0 *= f22;
            w0 *= f22;
          }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
      }
      static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
        const x0 = src0[srcOffset0];
        const y0 = src0[srcOffset0 + 1];
        const z0 = src0[srcOffset0 + 2];
        const w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1];
        const y1 = src1[srcOffset1 + 1];
        const z1 = src1[srcOffset1 + 2];
        const w1 = src1[srcOffset1 + 3];
        dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
        dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
        dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
        dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
        return dst;
      }
      get x() {
        return this._x;
      }
      set x(value) {
        this._x = value;
        this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(value) {
        this._y = value;
        this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(value) {
        this._z = value;
        this._onChangeCallback();
      }
      get w() {
        return this._w;
      }
      set w(value) {
        this._w = value;
        this._onChangeCallback();
      }
      set(x22, y2, z2, w2) {
        this._x = x22;
        this._y = y2;
        this._z = z2;
        this._w = w2;
        this._onChangeCallback();
        return this;
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
      copy(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this._onChangeCallback();
        return this;
      }
      setFromEuler(euler, update2) {
        if (!(euler && euler.isEuler)) {
          throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        }
        const x22 = euler._x, y2 = euler._y, z2 = euler._z, order = euler._order;
        const cos = Math.cos;
        const sin = Math.sin;
        const c1 = cos(x22 / 2);
        const c2 = cos(y2 / 2);
        const c3 = cos(z2 / 2);
        const s1 = sin(x22 / 2);
        const s22 = sin(y2 / 2);
        const s32 = sin(z2 / 2);
        switch (order) {
          case "XYZ":
            this._x = s1 * c2 * c3 + c1 * s22 * s32;
            this._y = c1 * s22 * c3 - s1 * c2 * s32;
            this._z = c1 * c2 * s32 + s1 * s22 * c3;
            this._w = c1 * c2 * c3 - s1 * s22 * s32;
            break;
          case "YXZ":
            this._x = s1 * c2 * c3 + c1 * s22 * s32;
            this._y = c1 * s22 * c3 - s1 * c2 * s32;
            this._z = c1 * c2 * s32 - s1 * s22 * c3;
            this._w = c1 * c2 * c3 + s1 * s22 * s32;
            break;
          case "ZXY":
            this._x = s1 * c2 * c3 - c1 * s22 * s32;
            this._y = c1 * s22 * c3 + s1 * c2 * s32;
            this._z = c1 * c2 * s32 + s1 * s22 * c3;
            this._w = c1 * c2 * c3 - s1 * s22 * s32;
            break;
          case "ZYX":
            this._x = s1 * c2 * c3 - c1 * s22 * s32;
            this._y = c1 * s22 * c3 + s1 * c2 * s32;
            this._z = c1 * c2 * s32 - s1 * s22 * c3;
            this._w = c1 * c2 * c3 + s1 * s22 * s32;
            break;
          case "YZX":
            this._x = s1 * c2 * c3 + c1 * s22 * s32;
            this._y = c1 * s22 * c3 + s1 * c2 * s32;
            this._z = c1 * c2 * s32 - s1 * s22 * c3;
            this._w = c1 * c2 * c3 - s1 * s22 * s32;
            break;
          case "XZY":
            this._x = s1 * c2 * c3 - c1 * s22 * s32;
            this._y = c1 * s22 * c3 - s1 * c2 * s32;
            this._z = c1 * c2 * s32 + s1 * s22 * c3;
            this._w = c1 * c2 * c3 + s1 * s22 * s32;
            break;
          default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
        }
        if (update2 !== false)
          this._onChangeCallback();
        return this;
      }
      setFromAxisAngle(axis, angle) {
        const halfAngle = angle / 2, s22 = Math.sin(halfAngle);
        this._x = axis.x * s22;
        this._y = axis.y * s22;
        this._z = axis.z * s22;
        this._w = Math.cos(halfAngle);
        this._onChangeCallback();
        return this;
      }
      setFromRotationMatrix(m22) {
        const te2 = m22.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m222 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10], trace = m11 + m222 + m33;
        if (trace > 0) {
          const s22 = 0.5 / Math.sqrt(trace + 1);
          this._w = 0.25 / s22;
          this._x = (m32 - m23) * s22;
          this._y = (m13 - m31) * s22;
          this._z = (m21 - m12) * s22;
        } else if (m11 > m222 && m11 > m33) {
          const s22 = 2 * Math.sqrt(1 + m11 - m222 - m33);
          this._w = (m32 - m23) / s22;
          this._x = 0.25 * s22;
          this._y = (m12 + m21) / s22;
          this._z = (m13 + m31) / s22;
        } else if (m222 > m33) {
          const s22 = 2 * Math.sqrt(1 + m222 - m11 - m33);
          this._w = (m13 - m31) / s22;
          this._x = (m12 + m21) / s22;
          this._y = 0.25 * s22;
          this._z = (m23 + m32) / s22;
        } else {
          const s22 = 2 * Math.sqrt(1 + m33 - m11 - m222);
          this._w = (m21 - m12) / s22;
          this._x = (m13 + m31) / s22;
          this._y = (m23 + m32) / s22;
          this._z = 0.25 * s22;
        }
        this._onChangeCallback();
        return this;
      }
      setFromUnitVectors(vFrom, vTo) {
        let r22 = vFrom.dot(vTo) + 1;
        if (r22 < Number.EPSILON) {
          r22 = 0;
          if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
            this._x = -vFrom.y;
            this._y = vFrom.x;
            this._z = 0;
            this._w = r22;
          } else {
            this._x = 0;
            this._y = -vFrom.z;
            this._z = vFrom.y;
            this._w = r22;
          }
        } else {
          this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
          this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
          this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
          this._w = r22;
        }
        return this.normalize();
      }
      angleTo(q2) {
        return 2 * Math.acos(Math.abs(clamp(this.dot(q2), -1, 1)));
      }
      rotateTowards(q2, step) {
        const angle = this.angleTo(q2);
        if (angle === 0)
          return this;
        const t22 = Math.min(1, step / angle);
        this.slerp(q2, t22);
        return this;
      }
      identity() {
        return this.set(0, 0, 0, 1);
      }
      invert() {
        return this.conjugate();
      }
      conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onChangeCallback();
        return this;
      }
      dot(v2) {
        return this._x * v2._x + this._y * v2._y + this._z * v2._z + this._w * v2._w;
      }
      lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      }
      length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      }
      normalize() {
        let l2 = this.length();
        if (l2 === 0) {
          this._x = 0;
          this._y = 0;
          this._z = 0;
          this._w = 1;
        } else {
          l2 = 1 / l2;
          this._x = this._x * l2;
          this._y = this._y * l2;
          this._z = this._z * l2;
          this._w = this._w * l2;
        }
        this._onChangeCallback();
        return this;
      }
      multiply(q2, p2) {
        if (p2 !== void 0) {
          console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
          return this.multiplyQuaternions(q2, p2);
        }
        return this.multiplyQuaternions(this, q2);
      }
      premultiply(q2) {
        return this.multiplyQuaternions(q2, this);
      }
      multiplyQuaternions(a2, b2) {
        const qax = a2._x, qay = a2._y, qaz = a2._z, qaw = a2._w;
        const qbx = b2._x, qby = b2._y, qbz = b2._z, qbw = b2._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this._onChangeCallback();
        return this;
      }
      slerp(qb, t22) {
        if (t22 === 0)
          return this;
        if (t22 === 1)
          return this.copy(qb);
        const x22 = this._x, y2 = this._y, z2 = this._z, w2 = this._w;
        let cosHalfTheta = w2 * qb._w + x22 * qb._x + y2 * qb._y + z2 * qb._z;
        if (cosHalfTheta < 0) {
          this._w = -qb._w;
          this._x = -qb._x;
          this._y = -qb._y;
          this._z = -qb._z;
          cosHalfTheta = -cosHalfTheta;
        } else {
          this.copy(qb);
        }
        if (cosHalfTheta >= 1) {
          this._w = w2;
          this._x = x22;
          this._y = y2;
          this._z = z2;
          return this;
        }
        const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
          const s22 = 1 - t22;
          this._w = s22 * w2 + t22 * this._w;
          this._x = s22 * x22 + t22 * this._x;
          this._y = s22 * y2 + t22 * this._y;
          this._z = s22 * z2 + t22 * this._z;
          this.normalize();
          this._onChangeCallback();
          return this;
        }
        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        const ratioA = Math.sin((1 - t22) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t22 * halfTheta) / sinHalfTheta;
        this._w = w2 * ratioA + this._w * ratioB;
        this._x = x22 * ratioA + this._x * ratioB;
        this._y = y2 * ratioA + this._y * ratioB;
        this._z = z2 * ratioA + this._z * ratioB;
        this._onChangeCallback();
        return this;
      }
      slerpQuaternions(qa, qb, t22) {
        return this.copy(qa).slerp(qb, t22);
      }
      random() {
        const u1 = Math.random();
        const sqrt1u1 = Math.sqrt(1 - u1);
        const sqrtu1 = Math.sqrt(u1);
        const u2 = 2 * Math.PI * Math.random();
        const u3 = 2 * Math.PI * Math.random();
        return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
      }
      equals(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
      }
      fromArray(array2, offset = 0) {
        this._x = array2[offset];
        this._y = array2[offset + 1];
        this._z = array2[offset + 2];
        this._w = array2[offset + 3];
        this._onChangeCallback();
        return this;
      }
      toArray(array2 = [], offset = 0) {
        array2[offset] = this._x;
        array2[offset + 1] = this._y;
        array2[offset + 2] = this._z;
        array2[offset + 3] = this._w;
        return array2;
      }
      fromBufferAttribute(attribute, index7) {
        this._x = attribute.getX(index7);
        this._y = attribute.getY(index7);
        this._z = attribute.getZ(index7);
        this._w = attribute.getW(index7);
        return this;
      }
      _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
      }
      _onChangeCallback() {
      }
      *[Symbol.iterator]() {
        yield this._x;
        yield this._y;
        yield this._z;
        yield this._w;
      }
    };
    Vector3 = class {
      constructor(x22 = 0, y2 = 0, z2 = 0) {
        Vector3.prototype.isVector3 = true;
        this.x = x22;
        this.y = y2;
        this.z = z2;
      }
      set(x22, y2, z2) {
        if (z2 === void 0)
          z2 = this.z;
        this.x = x22;
        this.y = y2;
        this.z = z2;
        return this;
      }
      setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
      }
      setX(x22) {
        this.x = x22;
        return this;
      }
      setY(y2) {
        this.y = y2;
        return this;
      }
      setZ(z2) {
        this.z = z2;
        return this;
      }
      setComponent(index7, value) {
        switch (index7) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          default:
            throw new Error("index is out of range: " + index7);
        }
        return this;
      }
      getComponent(index7) {
        switch (index7) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + index7);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
      copy(v2) {
        this.x = v2.x;
        this.y = v2.y;
        this.z = v2.z;
        return this;
      }
      add(v2, w2) {
        if (w2 !== void 0) {
          console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v2, w2);
        }
        this.x += v2.x;
        this.y += v2.y;
        this.z += v2.z;
        return this;
      }
      addScalar(s22) {
        this.x += s22;
        this.y += s22;
        this.z += s22;
        return this;
      }
      addVectors(a2, b2) {
        this.x = a2.x + b2.x;
        this.y = a2.y + b2.y;
        this.z = a2.z + b2.z;
        return this;
      }
      addScaledVector(v2, s22) {
        this.x += v2.x * s22;
        this.y += v2.y * s22;
        this.z += v2.z * s22;
        return this;
      }
      sub(v2, w2) {
        if (w2 !== void 0) {
          console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v2, w2);
        }
        this.x -= v2.x;
        this.y -= v2.y;
        this.z -= v2.z;
        return this;
      }
      subScalar(s22) {
        this.x -= s22;
        this.y -= s22;
        this.z -= s22;
        return this;
      }
      subVectors(a2, b2) {
        this.x = a2.x - b2.x;
        this.y = a2.y - b2.y;
        this.z = a2.z - b2.z;
        return this;
      }
      multiply(v2, w2) {
        if (w2 !== void 0) {
          console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
          return this.multiplyVectors(v2, w2);
        }
        this.x *= v2.x;
        this.y *= v2.y;
        this.z *= v2.z;
        return this;
      }
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
      }
      multiplyVectors(a2, b2) {
        this.x = a2.x * b2.x;
        this.y = a2.y * b2.y;
        this.z = a2.z * b2.z;
        return this;
      }
      applyEuler(euler) {
        if (!(euler && euler.isEuler)) {
          console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
        }
        return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
      }
      applyAxisAngle(axis, angle) {
        return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
      }
      applyMatrix3(m22) {
        const x22 = this.x, y2 = this.y, z2 = this.z;
        const e22 = m22.elements;
        this.x = e22[0] * x22 + e22[3] * y2 + e22[6] * z2;
        this.y = e22[1] * x22 + e22[4] * y2 + e22[7] * z2;
        this.z = e22[2] * x22 + e22[5] * y2 + e22[8] * z2;
        return this;
      }
      applyNormalMatrix(m22) {
        return this.applyMatrix3(m22).normalize();
      }
      applyMatrix4(m22) {
        const x22 = this.x, y2 = this.y, z2 = this.z;
        const e22 = m22.elements;
        const w2 = 1 / (e22[3] * x22 + e22[7] * y2 + e22[11] * z2 + e22[15]);
        this.x = (e22[0] * x22 + e22[4] * y2 + e22[8] * z2 + e22[12]) * w2;
        this.y = (e22[1] * x22 + e22[5] * y2 + e22[9] * z2 + e22[13]) * w2;
        this.z = (e22[2] * x22 + e22[6] * y2 + e22[10] * z2 + e22[14]) * w2;
        return this;
      }
      applyQuaternion(q2) {
        const x22 = this.x, y2 = this.y, z2 = this.z;
        const qx = q2.x, qy = q2.y, qz = q2.z, qw = q2.w;
        const ix = qw * x22 + qy * z2 - qz * y2;
        const iy = qw * y2 + qz * x22 - qx * z2;
        const iz = qw * z2 + qx * y2 - qy * x22;
        const iw = -qx * x22 - qy * y2 - qz * z2;
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
      }
      project(camera) {
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
      }
      unproject(camera) {
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
      }
      transformDirection(m22) {
        const x22 = this.x, y2 = this.y, z2 = this.z;
        const e22 = m22.elements;
        this.x = e22[0] * x22 + e22[4] * y2 + e22[8] * z2;
        this.y = e22[1] * x22 + e22[5] * y2 + e22[9] * z2;
        this.z = e22[2] * x22 + e22[6] * y2 + e22[10] * z2;
        return this.normalize();
      }
      divide(v2) {
        this.x /= v2.x;
        this.y /= v2.y;
        this.z /= v2.z;
        return this;
      }
      divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
      min(v2) {
        this.x = Math.min(this.x, v2.x);
        this.y = Math.min(this.y, v2.y);
        this.z = Math.min(this.z, v2.z);
        return this;
      }
      max(v2) {
        this.x = Math.max(this.x, v2.x);
        this.y = Math.max(this.y, v2.y);
        this.z = Math.max(this.z, v2.z);
        return this;
      }
      clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
      }
      clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        return this;
      }
      clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      }
      floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
      }
      ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
      }
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
      }
      roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
      }
      negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      }
      dot(v2) {
        return this.x * v2.x + this.y * v2.y + this.z * v2.z;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
      lerp(v2, alpha) {
        this.x += (v2.x - this.x) * alpha;
        this.y += (v2.y - this.y) * alpha;
        this.z += (v2.z - this.z) * alpha;
        return this;
      }
      lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
      }
      cross(v2, w2) {
        if (w2 !== void 0) {
          console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
          return this.crossVectors(v2, w2);
        }
        return this.crossVectors(this, v2);
      }
      crossVectors(a2, b2) {
        const ax = a2.x, ay = a2.y, az = a2.z;
        const bx = b2.x, by = b2.y, bz = b2.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
      }
      projectOnVector(v2) {
        const denominator = v2.lengthSq();
        if (denominator === 0)
          return this.set(0, 0, 0);
        const scalar = v2.dot(this) / denominator;
        return this.copy(v2).multiplyScalar(scalar);
      }
      projectOnPlane(planeNormal) {
        _vector$c.copy(this).projectOnVector(planeNormal);
        return this.sub(_vector$c);
      }
      reflect(normal) {
        return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
      }
      angleTo(v2) {
        const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
        if (denominator === 0)
          return Math.PI / 2;
        const theta = this.dot(v2) / denominator;
        return Math.acos(clamp(theta, -1, 1));
      }
      distanceTo(v2) {
        return Math.sqrt(this.distanceToSquared(v2));
      }
      distanceToSquared(v2) {
        const dx = this.x - v2.x, dy = this.y - v2.y, dz = this.z - v2.z;
        return dx * dx + dy * dy + dz * dz;
      }
      manhattanDistanceTo(v2) {
        return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y) + Math.abs(this.z - v2.z);
      }
      setFromSpherical(s22) {
        return this.setFromSphericalCoords(s22.radius, s22.phi, s22.theta);
      }
      setFromSphericalCoords(radius, phi, theta) {
        const sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
      }
      setFromCylindrical(c2) {
        return this.setFromCylindricalCoords(c2.radius, c2.theta, c2.y);
      }
      setFromCylindricalCoords(radius, theta, y2) {
        this.x = radius * Math.sin(theta);
        this.y = y2;
        this.z = radius * Math.cos(theta);
        return this;
      }
      setFromMatrixPosition(m22) {
        const e22 = m22.elements;
        this.x = e22[12];
        this.y = e22[13];
        this.z = e22[14];
        return this;
      }
      setFromMatrixScale(m22) {
        const sx = this.setFromMatrixColumn(m22, 0).length();
        const sy = this.setFromMatrixColumn(m22, 1).length();
        const sz = this.setFromMatrixColumn(m22, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
      }
      setFromMatrixColumn(m22, index7) {
        return this.fromArray(m22.elements, index7 * 4);
      }
      setFromMatrix3Column(m22, index7) {
        return this.fromArray(m22.elements, index7 * 3);
      }
      setFromEuler(e22) {
        this.x = e22._x;
        this.y = e22._y;
        this.z = e22._z;
        return this;
      }
      equals(v2) {
        return v2.x === this.x && v2.y === this.y && v2.z === this.z;
      }
      fromArray(array2, offset = 0) {
        this.x = array2[offset];
        this.y = array2[offset + 1];
        this.z = array2[offset + 2];
        return this;
      }
      toArray(array2 = [], offset = 0) {
        array2[offset] = this.x;
        array2[offset + 1] = this.y;
        array2[offset + 2] = this.z;
        return array2;
      }
      fromBufferAttribute(attribute, index7, offset) {
        if (offset !== void 0) {
          console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index7);
        this.y = attribute.getY(index7);
        this.z = attribute.getZ(index7);
        return this;
      }
      random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
      }
      randomDirection() {
        const u2 = (Math.random() - 0.5) * 2;
        const t22 = Math.random() * Math.PI * 2;
        const f22 = Math.sqrt(1 - u2 ** 2);
        this.x = f22 * Math.cos(t22);
        this.y = f22 * Math.sin(t22);
        this.z = u2;
        return this;
      }
      *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
        yield this.z;
      }
    };
    _vector$c = /* @__PURE__ */ new Vector3();
    _quaternion$4 = /* @__PURE__ */ new Quaternion();
    Box3 = class {
      constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
        this.isBox3 = true;
        this.min = min;
        this.max = max;
      }
      set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      }
      setFromArray(array2) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for (let i22 = 0, l2 = array2.length; i22 < l2; i22 += 3) {
          const x22 = array2[i22];
          const y2 = array2[i22 + 1];
          const z2 = array2[i22 + 2];
          if (x22 < minX)
            minX = x22;
          if (y2 < minY)
            minY = y2;
          if (z2 < minZ)
            minZ = z2;
          if (x22 > maxX)
            maxX = x22;
          if (y2 > maxY)
            maxY = y2;
          if (z2 > maxZ)
            maxZ = z2;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
      }
      setFromBufferAttribute(attribute) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for (let i22 = 0, l2 = attribute.count; i22 < l2; i22++) {
          const x22 = attribute.getX(i22);
          const y2 = attribute.getY(i22);
          const z2 = attribute.getZ(i22);
          if (x22 < minX)
            minX = x22;
          if (y2 < minY)
            minY = y2;
          if (z2 < minZ)
            minZ = z2;
          if (x22 > maxX)
            maxX = x22;
          if (y2 > maxY)
            maxY = y2;
          if (z2 > maxZ)
            maxZ = z2;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
      }
      setFromPoints(points) {
        this.makeEmpty();
        for (let i22 = 0, il = points.length; i22 < il; i22++) {
          this.expandByPoint(points[i22]);
        }
        return this;
      }
      setFromCenterAndSize(center, size) {
        const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      }
      setFromObject(object, precise = false) {
        this.makeEmpty();
        return this.expandByObject(object, precise);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      }
      makeEmpty() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
      }
      getCenter(target) {
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(target) {
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
      }
      expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      }
      expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      }
      expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      }
      expandByObject(object, precise = false) {
        object.updateWorldMatrix(false, false);
        const geometry = object.geometry;
        if (geometry !== void 0) {
          if (precise && geometry.attributes != void 0 && geometry.attributes.position !== void 0) {
            const position = geometry.attributes.position;
            for (let i22 = 0, l2 = position.count; i22 < l2; i22++) {
              _vector$b.fromBufferAttribute(position, i22).applyMatrix4(object.matrixWorld);
              this.expandByPoint(_vector$b);
            }
          } else {
            if (geometry.boundingBox === null) {
              geometry.computeBoundingBox();
            }
            _box$3.copy(geometry.boundingBox);
            _box$3.applyMatrix4(object.matrixWorld);
            this.union(_box$3);
          }
        }
        const children = object.children;
        for (let i22 = 0, l2 = children.length; i22 < l2; i22++) {
          this.expandByObject(children[i22], precise);
        }
        return this;
      }
      containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
      }
      containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
      }
      getParameter(point, target) {
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
      }
      intersectsBox(box) {
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
      }
      intersectsSphere(sphere) {
        this.clampPoint(sphere.center, _vector$b);
        return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
      }
      intersectsPlane(plane) {
        let min, max;
        if (plane.normal.x > 0) {
          min = plane.normal.x * this.min.x;
          max = plane.normal.x * this.max.x;
        } else {
          min = plane.normal.x * this.max.x;
          max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
          min += plane.normal.y * this.min.y;
          max += plane.normal.y * this.max.y;
        } else {
          min += plane.normal.y * this.max.y;
          max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
          min += plane.normal.z * this.min.z;
          max += plane.normal.z * this.max.z;
        } else {
          min += plane.normal.z * this.max.z;
          max += plane.normal.z * this.min.z;
        }
        return min <= -plane.constant && max >= -plane.constant;
      }
      intersectsTriangle(triangle) {
        if (this.isEmpty()) {
          return false;
        }
        this.getCenter(_center);
        _extents.subVectors(this.max, _center);
        _v0$2.subVectors(triangle.a, _center);
        _v1$7.subVectors(triangle.b, _center);
        _v2$3.subVectors(triangle.c, _center);
        _f0.subVectors(_v1$7, _v0$2);
        _f1.subVectors(_v2$3, _v1$7);
        _f2.subVectors(_v0$2, _v2$3);
        let axes = [
          0,
          -_f0.z,
          _f0.y,
          0,
          -_f1.z,
          _f1.y,
          0,
          -_f2.z,
          _f2.y,
          _f0.z,
          0,
          -_f0.x,
          _f1.z,
          0,
          -_f1.x,
          _f2.z,
          0,
          -_f2.x,
          -_f0.y,
          _f0.x,
          0,
          -_f1.y,
          _f1.x,
          0,
          -_f2.y,
          _f2.x,
          0
        ];
        if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
          return false;
        }
        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
          return false;
        }
        _triangleNormal.crossVectors(_f0, _f1);
        axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
        return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
      }
      clampPoint(point, target) {
        return target.copy(point).clamp(this.min, this.max);
      }
      distanceToPoint(point) {
        const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
      }
      getBoundingSphere(target) {
        this.getCenter(target.center);
        target.radius = this.getSize(_vector$b).length() * 0.5;
        return target;
      }
      intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        if (this.isEmpty())
          this.makeEmpty();
        return this;
      }
      union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      }
      applyMatrix4(matrix) {
        if (this.isEmpty())
          return this;
        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
        this.setFromPoints(_points);
        return this;
      }
      translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      }
      equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    };
    _points = [
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3()
    ];
    _vector$b = /* @__PURE__ */ new Vector3();
    _box$3 = /* @__PURE__ */ new Box3();
    _v0$2 = /* @__PURE__ */ new Vector3();
    _v1$7 = /* @__PURE__ */ new Vector3();
    _v2$3 = /* @__PURE__ */ new Vector3();
    _f0 = /* @__PURE__ */ new Vector3();
    _f1 = /* @__PURE__ */ new Vector3();
    _f2 = /* @__PURE__ */ new Vector3();
    _center = /* @__PURE__ */ new Vector3();
    _extents = /* @__PURE__ */ new Vector3();
    _triangleNormal = /* @__PURE__ */ new Vector3();
    _testAxis = /* @__PURE__ */ new Vector3();
    _box$2 = /* @__PURE__ */ new Box3();
    _v1$6 = /* @__PURE__ */ new Vector3();
    _toFarthestPoint = /* @__PURE__ */ new Vector3();
    _toPoint = /* @__PURE__ */ new Vector3();
    Sphere = class {
      constructor(center = new Vector3(), radius = -1) {
        this.center = center;
        this.radius = radius;
      }
      set(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
      }
      setFromPoints(points, optionalCenter) {
        const center = this.center;
        if (optionalCenter !== void 0) {
          center.copy(optionalCenter);
        } else {
          _box$2.setFromPoints(points).getCenter(center);
        }
        let maxRadiusSq = 0;
        for (let i22 = 0, il = points.length; i22 < il; i22++) {
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i22]));
        }
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
      }
      copy(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
      }
      isEmpty() {
        return this.radius < 0;
      }
      makeEmpty() {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
      }
      containsPoint(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
      }
      distanceToPoint(point) {
        return point.distanceTo(this.center) - this.radius;
      }
      intersectsSphere(sphere) {
        const radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
      }
      intersectsBox(box) {
        return box.intersectsSphere(this);
      }
      intersectsPlane(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
      }
      clampPoint(point, target) {
        const deltaLengthSq = this.center.distanceToSquared(point);
        target.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
          target.sub(this.center).normalize();
          target.multiplyScalar(this.radius).add(this.center);
        }
        return target;
      }
      getBoundingBox(target) {
        if (this.isEmpty()) {
          target.makeEmpty();
          return target;
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
      }
      applyMatrix4(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
      }
      translate(offset) {
        this.center.add(offset);
        return this;
      }
      expandByPoint(point) {
        _toPoint.subVectors(point, this.center);
        const lengthSq = _toPoint.lengthSq();
        if (lengthSq > this.radius * this.radius) {
          const length = Math.sqrt(lengthSq);
          const missingRadiusHalf = (length - this.radius) * 0.5;
          this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
          this.radius += missingRadiusHalf;
        }
        return this;
      }
      union(sphere) {
        if (this.center.equals(sphere.center) === true) {
          _toFarthestPoint.set(0, 0, 1).multiplyScalar(sphere.radius);
        } else {
          _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
        }
        this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
        this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
        return this;
      }
      equals(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    _vector$a = /* @__PURE__ */ new Vector3();
    _segCenter = /* @__PURE__ */ new Vector3();
    _segDir = /* @__PURE__ */ new Vector3();
    _diff = /* @__PURE__ */ new Vector3();
    _edge1 = /* @__PURE__ */ new Vector3();
    _edge2 = /* @__PURE__ */ new Vector3();
    _normal$1 = /* @__PURE__ */ new Vector3();
    Ray = class {
      constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
        this.origin = origin;
        this.direction = direction;
      }
      set(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
      }
      copy(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
      }
      at(t22, target) {
        return target.copy(this.direction).multiplyScalar(t22).add(this.origin);
      }
      lookAt(v2) {
        this.direction.copy(v2).sub(this.origin).normalize();
        return this;
      }
      recast(t22) {
        this.origin.copy(this.at(t22, _vector$a));
        return this;
      }
      closestPointToPoint(point, target) {
        target.subVectors(point, this.origin);
        const directionDistance = target.dot(this.direction);
        if (directionDistance < 0) {
          return target.copy(this.origin);
        }
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      }
      distanceToPoint(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
      }
      distanceSqToPoint(point) {
        const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
        if (directionDistance < 0) {
          return this.origin.distanceToSquared(point);
        }
        _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return _vector$a.distanceToSquared(point);
      }
      distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        _segDir.copy(v1).sub(v0).normalize();
        _diff.copy(this.origin).sub(_segCenter);
        const segExtent = v0.distanceTo(v1) * 0.5;
        const a01 = -this.direction.dot(_segDir);
        const b0 = _diff.dot(this.direction);
        const b1 = -_diff.dot(_segDir);
        const c2 = _diff.lengthSq();
        const det = Math.abs(1 - a01 * a01);
        let s0, s1, sqrDist, extDet;
        if (det > 0) {
          s0 = a01 * b1 - b0;
          s1 = a01 * b0 - b1;
          extDet = segExtent * det;
          if (s0 >= 0) {
            if (s1 >= -extDet) {
              if (s1 <= extDet) {
                const invDet = 1 / det;
                s0 *= invDet;
                s1 *= invDet;
                sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c2;
              } else {
                s1 = segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
              }
            } else {
              s1 = -segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
            }
          } else {
            if (s1 <= -extDet) {
              s0 = Math.max(0, -(-a01 * segExtent + b0));
              s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
            } else if (s1 <= extDet) {
              s0 = 0;
              s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = s1 * (s1 + 2 * b1) + c2;
            } else {
              s0 = Math.max(0, -(a01 * segExtent + b0));
              s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
            }
          }
        } else {
          s1 = a01 > 0 ? -segExtent : segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
        if (optionalPointOnRay) {
          optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        }
        if (optionalPointOnSegment) {
          optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
        }
        return sqrDist;
      }
      intersectSphere(sphere, target) {
        _vector$a.subVectors(sphere.center, this.origin);
        const tca = _vector$a.dot(this.direction);
        const d2 = _vector$a.dot(_vector$a) - tca * tca;
        const radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2)
          return null;
        const thc = Math.sqrt(radius2 - d2);
        const t0 = tca - thc;
        const t1 = tca + thc;
        if (t0 < 0 && t1 < 0)
          return null;
        if (t0 < 0)
          return this.at(t1, target);
        return this.at(t0, target);
      }
      intersectsSphere(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
      }
      distanceToPlane(plane) {
        const denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
          if (plane.distanceToPoint(this.origin) === 0) {
            return 0;
          }
          return null;
        }
        const t22 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t22 >= 0 ? t22 : null;
      }
      intersectPlane(plane, target) {
        const t22 = this.distanceToPlane(plane);
        if (t22 === null) {
          return null;
        }
        return this.at(t22, target);
      }
      intersectsPlane(plane) {
        const distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
          return true;
        }
        const denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
          return true;
        }
        return false;
      }
      intersectBox(box, target) {
        let tmin, tmax, tymin, tymax, tzmin, tzmax;
        const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        const origin = this.origin;
        if (invdirx >= 0) {
          tmin = (box.min.x - origin.x) * invdirx;
          tmax = (box.max.x - origin.x) * invdirx;
        } else {
          tmin = (box.max.x - origin.x) * invdirx;
          tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
          tymin = (box.min.y - origin.y) * invdiry;
          tymax = (box.max.y - origin.y) * invdiry;
        } else {
          tymin = (box.max.y - origin.y) * invdiry;
          tymax = (box.min.y - origin.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax)
          return null;
        if (tymin > tmin || tmin !== tmin)
          tmin = tymin;
        if (tymax < tmax || tmax !== tmax)
          tmax = tymax;
        if (invdirz >= 0) {
          tzmin = (box.min.z - origin.z) * invdirz;
          tzmax = (box.max.z - origin.z) * invdirz;
        } else {
          tzmin = (box.max.z - origin.z) * invdirz;
          tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax)
          return null;
        if (tzmin > tmin || tmin !== tmin)
          tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax)
          tmax = tzmax;
        if (tmax < 0)
          return null;
        return this.at(tmin >= 0 ? tmin : tmax, target);
      }
      intersectsBox(box) {
        return this.intersectBox(box, _vector$a) !== null;
      }
      intersectTriangle(a2, b2, c2, backfaceCulling, target) {
        _edge1.subVectors(b2, a2);
        _edge2.subVectors(c2, a2);
        _normal$1.crossVectors(_edge1, _edge2);
        let DdN = this.direction.dot(_normal$1);
        let sign;
        if (DdN > 0) {
          if (backfaceCulling)
            return null;
          sign = 1;
        } else if (DdN < 0) {
          sign = -1;
          DdN = -DdN;
        } else {
          return null;
        }
        _diff.subVectors(this.origin, a2);
        const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
        if (DdQxE2 < 0) {
          return null;
        }
        const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
        if (DdE1xQ < 0) {
          return null;
        }
        if (DdQxE2 + DdE1xQ > DdN) {
          return null;
        }
        const QdN = -sign * _diff.dot(_normal$1);
        if (QdN < 0) {
          return null;
        }
        return this.at(QdN / DdN, target);
      }
      applyMatrix4(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
      }
      equals(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    Matrix4 = class {
      constructor() {
        Matrix4.prototype.isMatrix4 = true;
        this.elements = [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ];
        if (arguments.length > 0) {
          console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
        }
      }
      set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        const te2 = this.elements;
        te2[0] = n11;
        te2[4] = n12;
        te2[8] = n13;
        te2[12] = n14;
        te2[1] = n21;
        te2[5] = n22;
        te2[9] = n23;
        te2[13] = n24;
        te2[2] = n31;
        te2[6] = n32;
        te2[10] = n33;
        te2[14] = n34;
        te2[3] = n41;
        te2[7] = n42;
        te2[11] = n43;
        te2[15] = n44;
        return this;
      }
      identity() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      }
      clone() {
        return new Matrix4().fromArray(this.elements);
      }
      copy(m22) {
        const te2 = this.elements;
        const me2 = m22.elements;
        te2[0] = me2[0];
        te2[1] = me2[1];
        te2[2] = me2[2];
        te2[3] = me2[3];
        te2[4] = me2[4];
        te2[5] = me2[5];
        te2[6] = me2[6];
        te2[7] = me2[7];
        te2[8] = me2[8];
        te2[9] = me2[9];
        te2[10] = me2[10];
        te2[11] = me2[11];
        te2[12] = me2[12];
        te2[13] = me2[13];
        te2[14] = me2[14];
        te2[15] = me2[15];
        return this;
      }
      copyPosition(m22) {
        const te2 = this.elements, me2 = m22.elements;
        te2[12] = me2[12];
        te2[13] = me2[13];
        te2[14] = me2[14];
        return this;
      }
      setFromMatrix3(m22) {
        const me2 = m22.elements;
        this.set(me2[0], me2[3], me2[6], 0, me2[1], me2[4], me2[7], 0, me2[2], me2[5], me2[8], 0, 0, 0, 0, 1);
        return this;
      }
      extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
      }
      makeBasis(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
      }
      extractRotation(m22) {
        const te2 = this.elements;
        const me2 = m22.elements;
        const scaleX = 1 / _v1$5.setFromMatrixColumn(m22, 0).length();
        const scaleY = 1 / _v1$5.setFromMatrixColumn(m22, 1).length();
        const scaleZ = 1 / _v1$5.setFromMatrixColumn(m22, 2).length();
        te2[0] = me2[0] * scaleX;
        te2[1] = me2[1] * scaleX;
        te2[2] = me2[2] * scaleX;
        te2[3] = 0;
        te2[4] = me2[4] * scaleY;
        te2[5] = me2[5] * scaleY;
        te2[6] = me2[6] * scaleY;
        te2[7] = 0;
        te2[8] = me2[8] * scaleZ;
        te2[9] = me2[9] * scaleZ;
        te2[10] = me2[10] * scaleZ;
        te2[11] = 0;
        te2[12] = 0;
        te2[13] = 0;
        te2[14] = 0;
        te2[15] = 1;
        return this;
      }
      makeRotationFromEuler(euler) {
        if (!(euler && euler.isEuler)) {
          console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        }
        const te2 = this.elements;
        const x22 = euler.x, y2 = euler.y, z2 = euler.z;
        const a2 = Math.cos(x22), b2 = Math.sin(x22);
        const c2 = Math.cos(y2), d2 = Math.sin(y2);
        const e22 = Math.cos(z2), f22 = Math.sin(z2);
        if (euler.order === "XYZ") {
          const ae2 = a2 * e22, af = a2 * f22, be2 = b2 * e22, bf = b2 * f22;
          te2[0] = c2 * e22;
          te2[4] = -c2 * f22;
          te2[8] = d2;
          te2[1] = af + be2 * d2;
          te2[5] = ae2 - bf * d2;
          te2[9] = -b2 * c2;
          te2[2] = bf - ae2 * d2;
          te2[6] = be2 + af * d2;
          te2[10] = a2 * c2;
        } else if (euler.order === "YXZ") {
          const ce2 = c2 * e22, cf = c2 * f22, de2 = d2 * e22, df = d2 * f22;
          te2[0] = ce2 + df * b2;
          te2[4] = de2 * b2 - cf;
          te2[8] = a2 * d2;
          te2[1] = a2 * f22;
          te2[5] = a2 * e22;
          te2[9] = -b2;
          te2[2] = cf * b2 - de2;
          te2[6] = df + ce2 * b2;
          te2[10] = a2 * c2;
        } else if (euler.order === "ZXY") {
          const ce2 = c2 * e22, cf = c2 * f22, de2 = d2 * e22, df = d2 * f22;
          te2[0] = ce2 - df * b2;
          te2[4] = -a2 * f22;
          te2[8] = de2 + cf * b2;
          te2[1] = cf + de2 * b2;
          te2[5] = a2 * e22;
          te2[9] = df - ce2 * b2;
          te2[2] = -a2 * d2;
          te2[6] = b2;
          te2[10] = a2 * c2;
        } else if (euler.order === "ZYX") {
          const ae2 = a2 * e22, af = a2 * f22, be2 = b2 * e22, bf = b2 * f22;
          te2[0] = c2 * e22;
          te2[4] = be2 * d2 - af;
          te2[8] = ae2 * d2 + bf;
          te2[1] = c2 * f22;
          te2[5] = bf * d2 + ae2;
          te2[9] = af * d2 - be2;
          te2[2] = -d2;
          te2[6] = b2 * c2;
          te2[10] = a2 * c2;
        } else if (euler.order === "YZX") {
          const ac = a2 * c2, ad = a2 * d2, bc = b2 * c2, bd = b2 * d2;
          te2[0] = c2 * e22;
          te2[4] = bd - ac * f22;
          te2[8] = bc * f22 + ad;
          te2[1] = f22;
          te2[5] = a2 * e22;
          te2[9] = -b2 * e22;
          te2[2] = -d2 * e22;
          te2[6] = ad * f22 + bc;
          te2[10] = ac - bd * f22;
        } else if (euler.order === "XZY") {
          const ac = a2 * c2, ad = a2 * d2, bc = b2 * c2, bd = b2 * d2;
          te2[0] = c2 * e22;
          te2[4] = -f22;
          te2[8] = d2 * e22;
          te2[1] = ac * f22 + bd;
          te2[5] = a2 * e22;
          te2[9] = ad * f22 - bc;
          te2[2] = bc * f22 - ad;
          te2[6] = b2 * e22;
          te2[10] = bd * f22 + ac;
        }
        te2[3] = 0;
        te2[7] = 0;
        te2[11] = 0;
        te2[12] = 0;
        te2[13] = 0;
        te2[14] = 0;
        te2[15] = 1;
        return this;
      }
      makeRotationFromQuaternion(q2) {
        return this.compose(_zero, q2, _one);
      }
      lookAt(eye, target, up) {
        const te2 = this.elements;
        _z.subVectors(eye, target);
        if (_z.lengthSq() === 0) {
          _z.z = 1;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
        if (_x.lengthSq() === 0) {
          if (Math.abs(up.z) === 1) {
            _z.x += 1e-4;
          } else {
            _z.z += 1e-4;
          }
          _z.normalize();
          _x.crossVectors(up, _z);
        }
        _x.normalize();
        _y.crossVectors(_z, _x);
        te2[0] = _x.x;
        te2[4] = _y.x;
        te2[8] = _z.x;
        te2[1] = _x.y;
        te2[5] = _y.y;
        te2[9] = _z.y;
        te2[2] = _x.z;
        te2[6] = _y.z;
        te2[10] = _z.z;
        return this;
      }
      multiply(m22, n2) {
        if (n2 !== void 0) {
          console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
          return this.multiplyMatrices(m22, n2);
        }
        return this.multiplyMatrices(this, m22);
      }
      premultiply(m22) {
        return this.multiplyMatrices(m22, this);
      }
      multiplyMatrices(a2, b2) {
        const ae2 = a2.elements;
        const be2 = b2.elements;
        const te2 = this.elements;
        const a11 = ae2[0], a12 = ae2[4], a13 = ae2[8], a14 = ae2[12];
        const a21 = ae2[1], a22 = ae2[5], a23 = ae2[9], a24 = ae2[13];
        const a31 = ae2[2], a32 = ae2[6], a33 = ae2[10], a34 = ae2[14];
        const a41 = ae2[3], a42 = ae2[7], a43 = ae2[11], a44 = ae2[15];
        const b11 = be2[0], b12 = be2[4], b13 = be2[8], b14 = be2[12];
        const b21 = be2[1], b22 = be2[5], b23 = be2[9], b24 = be2[13];
        const b31 = be2[2], b32 = be2[6], b33 = be2[10], b34 = be2[14];
        const b41 = be2[3], b42 = be2[7], b43 = be2[11], b44 = be2[15];
        te2[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te2[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te2[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te2[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te2[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te2[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te2[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te2[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te2[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te2[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te2[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te2[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te2[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te2[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te2[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te2[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
      }
      multiplyScalar(s22) {
        const te2 = this.elements;
        te2[0] *= s22;
        te2[4] *= s22;
        te2[8] *= s22;
        te2[12] *= s22;
        te2[1] *= s22;
        te2[5] *= s22;
        te2[9] *= s22;
        te2[13] *= s22;
        te2[2] *= s22;
        te2[6] *= s22;
        te2[10] *= s22;
        te2[14] *= s22;
        te2[3] *= s22;
        te2[7] *= s22;
        te2[11] *= s22;
        te2[15] *= s22;
        return this;
      }
      determinant() {
        const te2 = this.elements;
        const n11 = te2[0], n12 = te2[4], n13 = te2[8], n14 = te2[12];
        const n21 = te2[1], n22 = te2[5], n23 = te2[9], n24 = te2[13];
        const n31 = te2[2], n32 = te2[6], n33 = te2[10], n34 = te2[14];
        const n41 = te2[3], n42 = te2[7], n43 = te2[11], n44 = te2[15];
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
      }
      transpose() {
        const te2 = this.elements;
        let tmp;
        tmp = te2[1];
        te2[1] = te2[4];
        te2[4] = tmp;
        tmp = te2[2];
        te2[2] = te2[8];
        te2[8] = tmp;
        tmp = te2[6];
        te2[6] = te2[9];
        te2[9] = tmp;
        tmp = te2[3];
        te2[3] = te2[12];
        te2[12] = tmp;
        tmp = te2[7];
        te2[7] = te2[13];
        te2[13] = tmp;
        tmp = te2[11];
        te2[11] = te2[14];
        te2[14] = tmp;
        return this;
      }
      setPosition(x22, y2, z2) {
        const te2 = this.elements;
        if (x22.isVector3) {
          te2[12] = x22.x;
          te2[13] = x22.y;
          te2[14] = x22.z;
        } else {
          te2[12] = x22;
          te2[13] = y2;
          te2[14] = z2;
        }
        return this;
      }
      invert() {
        const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n41 = te2[3], n12 = te2[4], n22 = te2[5], n32 = te2[6], n42 = te2[7], n13 = te2[8], n23 = te2[9], n33 = te2[10], n43 = te2[11], n14 = te2[12], n24 = te2[13], n34 = te2[14], n44 = te2[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te2[0] = t11 * detInv;
        te2[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te2[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te2[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te2[4] = t12 * detInv;
        te2[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te2[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te2[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te2[8] = t13 * detInv;
        te2[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te2[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te2[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te2[12] = t14 * detInv;
        te2[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te2[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te2[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
      }
      scale(v2) {
        const te2 = this.elements;
        const x22 = v2.x, y2 = v2.y, z2 = v2.z;
        te2[0] *= x22;
        te2[4] *= y2;
        te2[8] *= z2;
        te2[1] *= x22;
        te2[5] *= y2;
        te2[9] *= z2;
        te2[2] *= x22;
        te2[6] *= y2;
        te2[10] *= z2;
        te2[3] *= x22;
        te2[7] *= y2;
        te2[11] *= z2;
        return this;
      }
      getMaxScaleOnAxis() {
        const te2 = this.elements;
        const scaleXSq = te2[0] * te2[0] + te2[1] * te2[1] + te2[2] * te2[2];
        const scaleYSq = te2[4] * te2[4] + te2[5] * te2[5] + te2[6] * te2[6];
        const scaleZSq = te2[8] * te2[8] + te2[9] * te2[9] + te2[10] * te2[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
      }
      makeTranslation(x22, y2, z2) {
        this.set(1, 0, 0, x22, 0, 1, 0, y2, 0, 0, 1, z2, 0, 0, 0, 1);
        return this;
      }
      makeRotationX(theta) {
        const c2 = Math.cos(theta), s22 = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c2, -s22, 0, 0, s22, c2, 0, 0, 0, 0, 1);
        return this;
      }
      makeRotationY(theta) {
        const c2 = Math.cos(theta), s22 = Math.sin(theta);
        this.set(c2, 0, s22, 0, 0, 1, 0, 0, -s22, 0, c2, 0, 0, 0, 0, 1);
        return this;
      }
      makeRotationZ(theta) {
        const c2 = Math.cos(theta), s22 = Math.sin(theta);
        this.set(c2, -s22, 0, 0, s22, c2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      }
      makeRotationAxis(axis, angle) {
        const c2 = Math.cos(angle);
        const s22 = Math.sin(angle);
        const t22 = 1 - c2;
        const x22 = axis.x, y2 = axis.y, z2 = axis.z;
        const tx = t22 * x22, ty = t22 * y2;
        this.set(tx * x22 + c2, tx * y2 - s22 * z2, tx * z2 + s22 * y2, 0, tx * y2 + s22 * z2, ty * y2 + c2, ty * z2 - s22 * x22, 0, tx * z2 - s22 * y2, ty * z2 + s22 * x22, t22 * z2 * z2 + c2, 0, 0, 0, 0, 1);
        return this;
      }
      makeScale(x22, y2, z2) {
        this.set(x22, 0, 0, 0, 0, y2, 0, 0, 0, 0, z2, 0, 0, 0, 0, 1);
        return this;
      }
      makeShear(xy, xz, yx, yz, zx, zy) {
        this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
        return this;
      }
      compose(position, quaternion, scale) {
        const te2 = this.elements;
        const x22 = quaternion._x, y2 = quaternion._y, z2 = quaternion._z, w2 = quaternion._w;
        const x222 = x22 + x22, y22 = y2 + y2, z22 = z2 + z2;
        const xx = x22 * x222, xy = x22 * y22, xz = x22 * z22;
        const yy = y2 * y22, yz = y2 * z22, zz = z2 * z22;
        const wx = w2 * x222, wy = w2 * y22, wz = w2 * z22;
        const sx = scale.x, sy = scale.y, sz = scale.z;
        te2[0] = (1 - (yy + zz)) * sx;
        te2[1] = (xy + wz) * sx;
        te2[2] = (xz - wy) * sx;
        te2[3] = 0;
        te2[4] = (xy - wz) * sy;
        te2[5] = (1 - (xx + zz)) * sy;
        te2[6] = (yz + wx) * sy;
        te2[7] = 0;
        te2[8] = (xz + wy) * sz;
        te2[9] = (yz - wx) * sz;
        te2[10] = (1 - (xx + yy)) * sz;
        te2[11] = 0;
        te2[12] = position.x;
        te2[13] = position.y;
        te2[14] = position.z;
        te2[15] = 1;
        return this;
      }
      decompose(position, quaternion, scale) {
        const te2 = this.elements;
        let sx = _v1$5.set(te2[0], te2[1], te2[2]).length();
        const sy = _v1$5.set(te2[4], te2[5], te2[6]).length();
        const sz = _v1$5.set(te2[8], te2[9], te2[10]).length();
        const det = this.determinant();
        if (det < 0)
          sx = -sx;
        position.x = te2[12];
        position.y = te2[13];
        position.z = te2[14];
        _m1$2.copy(this);
        const invSX = 1 / sx;
        const invSY = 1 / sy;
        const invSZ = 1 / sz;
        _m1$2.elements[0] *= invSX;
        _m1$2.elements[1] *= invSX;
        _m1$2.elements[2] *= invSX;
        _m1$2.elements[4] *= invSY;
        _m1$2.elements[5] *= invSY;
        _m1$2.elements[6] *= invSY;
        _m1$2.elements[8] *= invSZ;
        _m1$2.elements[9] *= invSZ;
        _m1$2.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(_m1$2);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
      }
      makePerspective(left, right, top, bottom, near, far) {
        if (far === void 0) {
          console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        }
        const te2 = this.elements;
        const x22 = 2 * near / (right - left);
        const y2 = 2 * near / (top - bottom);
        const a2 = (right + left) / (right - left);
        const b2 = (top + bottom) / (top - bottom);
        const c2 = -(far + near) / (far - near);
        const d2 = -2 * far * near / (far - near);
        te2[0] = x22;
        te2[4] = 0;
        te2[8] = a2;
        te2[12] = 0;
        te2[1] = 0;
        te2[5] = y2;
        te2[9] = b2;
        te2[13] = 0;
        te2[2] = 0;
        te2[6] = 0;
        te2[10] = c2;
        te2[14] = d2;
        te2[3] = 0;
        te2[7] = 0;
        te2[11] = -1;
        te2[15] = 0;
        return this;
      }
      makeOrthographic(left, right, top, bottom, near, far) {
        const te2 = this.elements;
        const w2 = 1 / (right - left);
        const h22 = 1 / (top - bottom);
        const p2 = 1 / (far - near);
        const x22 = (right + left) * w2;
        const y2 = (top + bottom) * h22;
        const z2 = (far + near) * p2;
        te2[0] = 2 * w2;
        te2[4] = 0;
        te2[8] = 0;
        te2[12] = -x22;
        te2[1] = 0;
        te2[5] = 2 * h22;
        te2[9] = 0;
        te2[13] = -y2;
        te2[2] = 0;
        te2[6] = 0;
        te2[10] = -2 * p2;
        te2[14] = -z2;
        te2[3] = 0;
        te2[7] = 0;
        te2[11] = 0;
        te2[15] = 1;
        return this;
      }
      equals(matrix) {
        const te2 = this.elements;
        const me2 = matrix.elements;
        for (let i22 = 0; i22 < 16; i22++) {
          if (te2[i22] !== me2[i22])
            return false;
        }
        return true;
      }
      fromArray(array2, offset = 0) {
        for (let i22 = 0; i22 < 16; i22++) {
          this.elements[i22] = array2[i22 + offset];
        }
        return this;
      }
      toArray(array2 = [], offset = 0) {
        const te2 = this.elements;
        array2[offset] = te2[0];
        array2[offset + 1] = te2[1];
        array2[offset + 2] = te2[2];
        array2[offset + 3] = te2[3];
        array2[offset + 4] = te2[4];
        array2[offset + 5] = te2[5];
        array2[offset + 6] = te2[6];
        array2[offset + 7] = te2[7];
        array2[offset + 8] = te2[8];
        array2[offset + 9] = te2[9];
        array2[offset + 10] = te2[10];
        array2[offset + 11] = te2[11];
        array2[offset + 12] = te2[12];
        array2[offset + 13] = te2[13];
        array2[offset + 14] = te2[14];
        array2[offset + 15] = te2[15];
        return array2;
      }
    };
    _v1$5 = /* @__PURE__ */ new Vector3();
    _m1$2 = /* @__PURE__ */ new Matrix4();
    _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
    _one = /* @__PURE__ */ new Vector3(1, 1, 1);
    _x = /* @__PURE__ */ new Vector3();
    _y = /* @__PURE__ */ new Vector3();
    _z = /* @__PURE__ */ new Vector3();
    _matrix$1 = /* @__PURE__ */ new Matrix4();
    _quaternion$3 = /* @__PURE__ */ new Quaternion();
    Euler = class {
      constructor(x22 = 0, y2 = 0, z2 = 0, order = Euler.DefaultOrder) {
        this.isEuler = true;
        this._x = x22;
        this._y = y2;
        this._z = z2;
        this._order = order;
      }
      get x() {
        return this._x;
      }
      set x(value) {
        this._x = value;
        this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(value) {
        this._y = value;
        this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(value) {
        this._z = value;
        this._onChangeCallback();
      }
      get order() {
        return this._order;
      }
      set order(value) {
        this._order = value;
        this._onChangeCallback();
      }
      set(x22, y2, z2, order = this._order) {
        this._x = x22;
        this._y = y2;
        this._z = z2;
        this._order = order;
        this._onChangeCallback();
        return this;
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }
      copy(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
      }
      setFromRotationMatrix(m22, order = this._order, update2 = true) {
        const te2 = m22.elements;
        const m11 = te2[0], m12 = te2[4], m13 = te2[8];
        const m21 = te2[1], m222 = te2[5], m23 = te2[9];
        const m31 = te2[2], m32 = te2[6], m33 = te2[10];
        switch (order) {
          case "XYZ":
            this._y = Math.asin(clamp(m13, -1, 1));
            if (Math.abs(m13) < 0.9999999) {
              this._x = Math.atan2(-m23, m33);
              this._z = Math.atan2(-m12, m11);
            } else {
              this._x = Math.atan2(m32, m222);
              this._z = 0;
            }
            break;
          case "YXZ":
            this._x = Math.asin(-clamp(m23, -1, 1));
            if (Math.abs(m23) < 0.9999999) {
              this._y = Math.atan2(m13, m33);
              this._z = Math.atan2(m21, m222);
            } else {
              this._y = Math.atan2(-m31, m11);
              this._z = 0;
            }
            break;
          case "ZXY":
            this._x = Math.asin(clamp(m32, -1, 1));
            if (Math.abs(m32) < 0.9999999) {
              this._y = Math.atan2(-m31, m33);
              this._z = Math.atan2(-m12, m222);
            } else {
              this._y = 0;
              this._z = Math.atan2(m21, m11);
            }
            break;
          case "ZYX":
            this._y = Math.asin(-clamp(m31, -1, 1));
            if (Math.abs(m31) < 0.9999999) {
              this._x = Math.atan2(m32, m33);
              this._z = Math.atan2(m21, m11);
            } else {
              this._x = 0;
              this._z = Math.atan2(-m12, m222);
            }
            break;
          case "YZX":
            this._z = Math.asin(clamp(m21, -1, 1));
            if (Math.abs(m21) < 0.9999999) {
              this._x = Math.atan2(-m23, m222);
              this._y = Math.atan2(-m31, m11);
            } else {
              this._x = 0;
              this._y = Math.atan2(m13, m33);
            }
            break;
          case "XZY":
            this._z = Math.asin(-clamp(m12, -1, 1));
            if (Math.abs(m12) < 0.9999999) {
              this._x = Math.atan2(m32, m222);
              this._y = Math.atan2(m13, m11);
            } else {
              this._x = Math.atan2(-m23, m33);
              this._y = 0;
            }
            break;
          default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
        }
        this._order = order;
        if (update2 === true)
          this._onChangeCallback();
        return this;
      }
      setFromQuaternion(q2, order, update2) {
        _matrix$1.makeRotationFromQuaternion(q2);
        return this.setFromRotationMatrix(_matrix$1, order, update2);
      }
      setFromVector3(v2, order = this._order) {
        return this.set(v2.x, v2.y, v2.z, order);
      }
      reorder(newOrder) {
        _quaternion$3.setFromEuler(this);
        return this.setFromQuaternion(_quaternion$3, newOrder);
      }
      equals(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
      }
      fromArray(array2) {
        this._x = array2[0];
        this._y = array2[1];
        this._z = array2[2];
        if (array2[3] !== void 0)
          this._order = array2[3];
        this._onChangeCallback();
        return this;
      }
      toArray(array2 = [], offset = 0) {
        array2[offset] = this._x;
        array2[offset + 1] = this._y;
        array2[offset + 2] = this._z;
        array2[offset + 3] = this._order;
        return array2;
      }
      _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
      }
      _onChangeCallback() {
      }
      *[Symbol.iterator]() {
        yield this._x;
        yield this._y;
        yield this._z;
        yield this._order;
      }
      toVector3() {
        console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
      }
    };
    Euler.DefaultOrder = "XYZ";
    Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
    Layers = class {
      constructor() {
        this.mask = 1 | 0;
      }
      set(channel) {
        this.mask = (1 << channel | 0) >>> 0;
      }
      enable(channel) {
        this.mask |= 1 << channel | 0;
      }
      enableAll() {
        this.mask = 4294967295 | 0;
      }
      toggle(channel) {
        this.mask ^= 1 << channel | 0;
      }
      disable(channel) {
        this.mask &= ~(1 << channel | 0);
      }
      disableAll() {
        this.mask = 0;
      }
      test(layers) {
        return (this.mask & layers.mask) !== 0;
      }
      isEnabled(channel) {
        return (this.mask & (1 << channel | 0)) !== 0;
      }
    };
    _object3DId = 0;
    _v1$4 = /* @__PURE__ */ new Vector3();
    _q1 = /* @__PURE__ */ new Quaternion();
    _m1$1 = /* @__PURE__ */ new Matrix4();
    _target = /* @__PURE__ */ new Vector3();
    _position$3 = /* @__PURE__ */ new Vector3();
    _scale$2 = /* @__PURE__ */ new Vector3();
    _quaternion$2 = /* @__PURE__ */ new Quaternion();
    _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
    _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
    _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
    _addedEvent = { type: "added" };
    _removedEvent = { type: "removed" };
    Object3D = class extends EventDispatcher {
      constructor() {
        super();
        this.isObject3D = true;
        Object.defineProperty(this, "id", { value: _object3DId++ });
        this.uuid = generateUUID();
        this.name = "";
        this.type = "Object3D";
        this.parent = null;
        this.children = [];
        this.up = Object3D.DefaultUp.clone();
        const position = new Vector3();
        const rotation = new Euler();
        const quaternion = new Quaternion();
        const scale = new Vector3(1, 1, 1);
        function onRotationChange() {
          quaternion.setFromEuler(rotation, false);
        }
        function onQuaternionChange() {
          rotation.setFromQuaternion(quaternion, void 0, false);
        }
        rotation._onChange(onRotationChange);
        quaternion._onChange(onQuaternionChange);
        Object.defineProperties(this, {
          position: {
            configurable: true,
            enumerable: true,
            value: position
          },
          rotation: {
            configurable: true,
            enumerable: true,
            value: rotation
          },
          quaternion: {
            configurable: true,
            enumerable: true,
            value: quaternion
          },
          scale: {
            configurable: true,
            enumerable: true,
            value: scale
          },
          modelViewMatrix: {
            value: new Matrix4()
          },
          normalMatrix: {
            value: new Matrix3()
          }
        });
        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();
        this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = false;
        this.layers = new Layers();
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.frustumCulled = true;
        this.renderOrder = 0;
        this.animations = [];
        this.userData = {};
      }
      onBeforeRender() {
      }
      onAfterRender() {
      }
      applyMatrix4(matrix) {
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      applyQuaternion(q2) {
        this.quaternion.premultiply(q2);
        return this;
      }
      setRotationFromAxisAngle(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
      }
      setRotationFromEuler(euler) {
        this.quaternion.setFromEuler(euler, true);
      }
      setRotationFromMatrix(m22) {
        this.quaternion.setFromRotationMatrix(m22);
      }
      setRotationFromQuaternion(q2) {
        this.quaternion.copy(q2);
      }
      rotateOnAxis(axis, angle) {
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(_q1);
        return this;
      }
      rotateOnWorldAxis(axis, angle) {
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply(_q1);
        return this;
      }
      rotateX(angle) {
        return this.rotateOnAxis(_xAxis, angle);
      }
      rotateY(angle) {
        return this.rotateOnAxis(_yAxis, angle);
      }
      rotateZ(angle) {
        return this.rotateOnAxis(_zAxis, angle);
      }
      translateOnAxis(axis, distance) {
        _v1$4.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(_v1$4.multiplyScalar(distance));
        return this;
      }
      translateX(distance) {
        return this.translateOnAxis(_xAxis, distance);
      }
      translateY(distance) {
        return this.translateOnAxis(_yAxis, distance);
      }
      translateZ(distance) {
        return this.translateOnAxis(_zAxis, distance);
      }
      localToWorld(vector) {
        return vector.applyMatrix4(this.matrixWorld);
      }
      worldToLocal(vector) {
        return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
      }
      lookAt(x22, y2, z2) {
        if (x22.isVector3) {
          _target.copy(x22);
        } else {
          _target.set(x22, y2, z2);
        }
        const parent = this.parent;
        this.updateWorldMatrix(true, false);
        _position$3.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) {
          _m1$1.lookAt(_position$3, _target, this.up);
        } else {
          _m1$1.lookAt(_target, _position$3, this.up);
        }
        this.quaternion.setFromRotationMatrix(_m1$1);
        if (parent) {
          _m1$1.extractRotation(parent.matrixWorld);
          _q1.setFromRotationMatrix(_m1$1);
          this.quaternion.premultiply(_q1.invert());
        }
      }
      add(object) {
        if (arguments.length > 1) {
          for (let i22 = 0; i22 < arguments.length; i22++) {
            this.add(arguments[i22]);
          }
          return this;
        }
        if (object === this) {
          console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
          return this;
        }
        if (object && object.isObject3D) {
          if (object.parent !== null) {
            object.parent.remove(object);
          }
          object.parent = this;
          this.children.push(object);
          object.dispatchEvent(_addedEvent);
        } else {
          console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        }
        return this;
      }
      remove(object) {
        if (arguments.length > 1) {
          for (let i22 = 0; i22 < arguments.length; i22++) {
            this.remove(arguments[i22]);
          }
          return this;
        }
        const index7 = this.children.indexOf(object);
        if (index7 !== -1) {
          object.parent = null;
          this.children.splice(index7, 1);
          object.dispatchEvent(_removedEvent);
        }
        return this;
      }
      removeFromParent() {
        const parent = this.parent;
        if (parent !== null) {
          parent.remove(this);
        }
        return this;
      }
      clear() {
        for (let i22 = 0; i22 < this.children.length; i22++) {
          const object = this.children[i22];
          object.parent = null;
          object.dispatchEvent(_removedEvent);
        }
        this.children.length = 0;
        return this;
      }
      attach(object) {
        this.updateWorldMatrix(true, false);
        _m1$1.copy(this.matrixWorld).invert();
        if (object.parent !== null) {
          object.parent.updateWorldMatrix(true, false);
          _m1$1.multiply(object.parent.matrixWorld);
        }
        object.applyMatrix4(_m1$1);
        this.add(object);
        object.updateWorldMatrix(false, true);
        return this;
      }
      getObjectById(id) {
        return this.getObjectByProperty("id", id);
      }
      getObjectByName(name) {
        return this.getObjectByProperty("name", name);
      }
      getObjectByProperty(name, value) {
        if (this[name] === value)
          return this;
        for (let i22 = 0, l2 = this.children.length; i22 < l2; i22++) {
          const child = this.children[i22];
          const object = child.getObjectByProperty(name, value);
          if (object !== void 0) {
            return object;
          }
        }
        return void 0;
      }
      getWorldPosition(target) {
        this.updateWorldMatrix(true, false);
        return target.setFromMatrixPosition(this.matrixWorld);
      }
      getWorldQuaternion(target) {
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position$3, target, _scale$2);
        return target;
      }
      getWorldScale(target) {
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position$3, _quaternion$2, target);
        return target;
      }
      getWorldDirection(target) {
        this.updateWorldMatrix(true, false);
        const e22 = this.matrixWorld.elements;
        return target.set(e22[8], e22[9], e22[10]).normalize();
      }
      raycast() {
      }
      traverse(callback) {
        callback(this);
        const children = this.children;
        for (let i22 = 0, l2 = children.length; i22 < l2; i22++) {
          children[i22].traverse(callback);
        }
      }
      traverseVisible(callback) {
        if (this.visible === false)
          return;
        callback(this);
        const children = this.children;
        for (let i22 = 0, l2 = children.length; i22 < l2; i22++) {
          children[i22].traverseVisible(callback);
        }
      }
      traverseAncestors(callback) {
        const parent = this.parent;
        if (parent !== null) {
          callback(parent);
          parent.traverseAncestors(callback);
        }
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
      }
      updateMatrixWorld(force) {
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          this.matrixWorldNeedsUpdate = false;
          force = true;
        }
        const children = this.children;
        for (let i22 = 0, l2 = children.length; i22 < l2; i22++) {
          children[i22].updateMatrixWorld(force);
        }
      }
      updateWorldMatrix(updateParents, updateChildren) {
        const parent = this.parent;
        if (updateParents === true && parent !== null) {
          parent.updateWorldMatrix(true, false);
        }
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
        if (updateChildren === true) {
          const children = this.children;
          for (let i22 = 0, l2 = children.length; i22 < l2; i22++) {
            children[i22].updateWorldMatrix(false, true);
          }
        }
      }
      toJSON(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        const output = {};
        if (isRootObject) {
          meta = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
          };
          output.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
          };
        }
        const object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== "")
          object.name = this.name;
        if (this.castShadow === true)
          object.castShadow = true;
        if (this.receiveShadow === true)
          object.receiveShadow = true;
        if (this.visible === false)
          object.visible = false;
        if (this.frustumCulled === false)
          object.frustumCulled = false;
        if (this.renderOrder !== 0)
          object.renderOrder = this.renderOrder;
        if (JSON.stringify(this.userData) !== "{}")
          object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        if (this.matrixAutoUpdate === false)
          object.matrixAutoUpdate = false;
        if (this.isInstancedMesh) {
          object.type = "InstancedMesh";
          object.count = this.count;
          object.instanceMatrix = this.instanceMatrix.toJSON();
          if (this.instanceColor !== null)
            object.instanceColor = this.instanceColor.toJSON();
        }
        function serialize2(library, element) {
          if (library[element.uuid] === void 0) {
            library[element.uuid] = element.toJSON(meta);
          }
          return element.uuid;
        }
        if (this.isScene) {
          if (this.background) {
            if (this.background.isColor) {
              object.background = this.background.toJSON();
            } else if (this.background.isTexture) {
              object.background = this.background.toJSON(meta).uuid;
            }
          }
          if (this.environment && this.environment.isTexture) {
            object.environment = this.environment.toJSON(meta).uuid;
          }
        } else if (this.isMesh || this.isLine || this.isPoints) {
          object.geometry = serialize2(meta.geometries, this.geometry);
          const parameters = this.geometry.parameters;
          if (parameters !== void 0 && parameters.shapes !== void 0) {
            const shapes = parameters.shapes;
            if (Array.isArray(shapes)) {
              for (let i22 = 0, l2 = shapes.length; i22 < l2; i22++) {
                const shape = shapes[i22];
                serialize2(meta.shapes, shape);
              }
            } else {
              serialize2(meta.shapes, shapes);
            }
          }
        }
        if (this.isSkinnedMesh) {
          object.bindMode = this.bindMode;
          object.bindMatrix = this.bindMatrix.toArray();
          if (this.skeleton !== void 0) {
            serialize2(meta.skeletons, this.skeleton);
            object.skeleton = this.skeleton.uuid;
          }
        }
        if (this.material !== void 0) {
          if (Array.isArray(this.material)) {
            const uuids = [];
            for (let i22 = 0, l2 = this.material.length; i22 < l2; i22++) {
              uuids.push(serialize2(meta.materials, this.material[i22]));
            }
            object.material = uuids;
          } else {
            object.material = serialize2(meta.materials, this.material);
          }
        }
        if (this.children.length > 0) {
          object.children = [];
          for (let i22 = 0; i22 < this.children.length; i22++) {
            object.children.push(this.children[i22].toJSON(meta).object);
          }
        }
        if (this.animations.length > 0) {
          object.animations = [];
          for (let i22 = 0; i22 < this.animations.length; i22++) {
            const animation = this.animations[i22];
            object.animations.push(serialize2(meta.animations, animation));
          }
        }
        if (isRootObject) {
          const geometries = extractFromCache(meta.geometries);
          const materials = extractFromCache(meta.materials);
          const textures = extractFromCache(meta.textures);
          const images = extractFromCache(meta.images);
          const shapes = extractFromCache(meta.shapes);
          const skeletons = extractFromCache(meta.skeletons);
          const animations = extractFromCache(meta.animations);
          const nodes = extractFromCache(meta.nodes);
          if (geometries.length > 0)
            output.geometries = geometries;
          if (materials.length > 0)
            output.materials = materials;
          if (textures.length > 0)
            output.textures = textures;
          if (images.length > 0)
            output.images = images;
          if (shapes.length > 0)
            output.shapes = shapes;
          if (skeletons.length > 0)
            output.skeletons = skeletons;
          if (animations.length > 0)
            output.animations = animations;
          if (nodes.length > 0)
            output.nodes = nodes;
        }
        output.object = object;
        return output;
        function extractFromCache(cache) {
          const values = [];
          for (const key2 in cache) {
            const data = cache[key2];
            delete data.metadata;
            values.push(data);
          }
          return values;
        }
      }
      clone(recursive) {
        return new this.constructor().copy(this, recursive);
      }
      copy(source, recursive = true) {
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) {
          for (let i22 = 0; i22 < source.children.length; i22++) {
            const child = source.children[i22];
            this.add(child.clone());
          }
        }
        return this;
      }
    };
    Object3D.DefaultUp = /* @__PURE__ */ new Vector3(0, 1, 0);
    Object3D.DefaultMatrixAutoUpdate = true;
    _v0$1 = /* @__PURE__ */ new Vector3();
    _v1$3 = /* @__PURE__ */ new Vector3();
    _v2$2 = /* @__PURE__ */ new Vector3();
    _v3$1 = /* @__PURE__ */ new Vector3();
    _vab = /* @__PURE__ */ new Vector3();
    _vac = /* @__PURE__ */ new Vector3();
    _vbc = /* @__PURE__ */ new Vector3();
    _vap = /* @__PURE__ */ new Vector3();
    _vbp = /* @__PURE__ */ new Vector3();
    _vcp = /* @__PURE__ */ new Vector3();
    Triangle = class {
      constructor(a2 = new Vector3(), b2 = new Vector3(), c2 = new Vector3()) {
        this.a = a2;
        this.b = b2;
        this.c = c2;
      }
      static getNormal(a2, b2, c2, target) {
        target.subVectors(c2, b2);
        _v0$1.subVectors(a2, b2);
        target.cross(_v0$1);
        const targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) {
          return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        }
        return target.set(0, 0, 0);
      }
      static getBarycoord(point, a2, b2, c2, target) {
        _v0$1.subVectors(c2, a2);
        _v1$3.subVectors(b2, a2);
        _v2$2.subVectors(point, a2);
        const dot00 = _v0$1.dot(_v0$1);
        const dot01 = _v0$1.dot(_v1$3);
        const dot02 = _v0$1.dot(_v2$2);
        const dot11 = _v1$3.dot(_v1$3);
        const dot12 = _v1$3.dot(_v2$2);
        const denom = dot00 * dot11 - dot01 * dot01;
        if (denom === 0) {
          return target.set(-2, -1, -1);
        }
        const invDenom = 1 / denom;
        const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
        const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return target.set(1 - u2 - v2, v2, u2);
      }
      static containsPoint(point, a2, b2, c2) {
        this.getBarycoord(point, a2, b2, c2, _v3$1);
        return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
      }
      static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
        this.getBarycoord(point, p1, p2, p3, _v3$1);
        target.set(0, 0);
        target.addScaledVector(uv1, _v3$1.x);
        target.addScaledVector(uv2, _v3$1.y);
        target.addScaledVector(uv3, _v3$1.z);
        return target;
      }
      static isFrontFacing(a2, b2, c2, direction) {
        _v0$1.subVectors(c2, b2);
        _v1$3.subVectors(a2, b2);
        return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
      }
      set(a2, b2, c2) {
        this.a.copy(a2);
        this.b.copy(b2);
        this.c.copy(c2);
        return this;
      }
      setFromPointsAndIndices(points, i0, i1, i22) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i22]);
        return this;
      }
      setFromAttributeAndIndices(attribute, i0, i1, i22) {
        this.a.fromBufferAttribute(attribute, i0);
        this.b.fromBufferAttribute(attribute, i1);
        this.c.fromBufferAttribute(attribute, i22);
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
      }
      getArea() {
        _v0$1.subVectors(this.c, this.b);
        _v1$3.subVectors(this.a, this.b);
        return _v0$1.cross(_v1$3).length() * 0.5;
      }
      getMidpoint(target) {
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
      }
      getNormal(target) {
        return Triangle.getNormal(this.a, this.b, this.c, target);
      }
      getPlane(target) {
        return target.setFromCoplanarPoints(this.a, this.b, this.c);
      }
      getBarycoord(point, target) {
        return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
      }
      getUV(point, uv1, uv2, uv3, target) {
        return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
      }
      containsPoint(point) {
        return Triangle.containsPoint(point, this.a, this.b, this.c);
      }
      isFrontFacing(direction) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
      }
      intersectsBox(box) {
        return box.intersectsTriangle(this);
      }
      closestPointToPoint(p2, target) {
        const a2 = this.a, b2 = this.b, c2 = this.c;
        let v2, w2;
        _vab.subVectors(b2, a2);
        _vac.subVectors(c2, a2);
        _vap.subVectors(p2, a2);
        const d1 = _vab.dot(_vap);
        const d2 = _vac.dot(_vap);
        if (d1 <= 0 && d2 <= 0) {
          return target.copy(a2);
        }
        _vbp.subVectors(p2, b2);
        const d3 = _vab.dot(_vbp);
        const d4 = _vac.dot(_vbp);
        if (d3 >= 0 && d4 <= d3) {
          return target.copy(b2);
        }
        const vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
          v2 = d1 / (d1 - d3);
          return target.copy(a2).addScaledVector(_vab, v2);
        }
        _vcp.subVectors(p2, c2);
        const d5 = _vab.dot(_vcp);
        const d6 = _vac.dot(_vcp);
        if (d6 >= 0 && d5 <= d6) {
          return target.copy(c2);
        }
        const vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
          w2 = d2 / (d2 - d6);
          return target.copy(a2).addScaledVector(_vac, w2);
        }
        const va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
          _vbc.subVectors(c2, b2);
          w2 = (d4 - d3) / (d4 - d3 + (d5 - d6));
          return target.copy(b2).addScaledVector(_vbc, w2);
        }
        const denom = 1 / (va + vb + vc);
        v2 = vb * denom;
        w2 = vc * denom;
        return target.copy(a2).addScaledVector(_vab, v2).addScaledVector(_vac, w2);
      }
      equals(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
      }
    };
    materialId = 0;
    Material = class extends EventDispatcher {
      constructor() {
        super();
        this.isMaterial = true;
        Object.defineProperty(this, "id", { value: materialId++ });
        this.uuid = generateUUID();
        this.name = "";
        this.type = "Material";
        this.blending = NormalBlending;
        this.side = FrontSide;
        this.vertexColors = false;
        this.opacity = 1;
        this.transparent = false;
        this.blendSrc = SrcAlphaFactor;
        this.blendDst = OneMinusSrcAlphaFactor;
        this.blendEquation = AddEquation;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;
        this.depthFunc = LessEqualDepth;
        this.depthTest = true;
        this.depthWrite = true;
        this.stencilWriteMask = 255;
        this.stencilFunc = AlwaysStencilFunc;
        this.stencilRef = 0;
        this.stencilFuncMask = 255;
        this.stencilFail = KeepStencilOp;
        this.stencilZFail = KeepStencilOp;
        this.stencilZPass = KeepStencilOp;
        this.stencilWrite = false;
        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;
        this.shadowSide = null;
        this.colorWrite = true;
        this.precision = null;
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.dithering = false;
        this.alphaToCoverage = false;
        this.premultipliedAlpha = false;
        this.visible = true;
        this.toneMapped = true;
        this.userData = {};
        this.version = 0;
        this._alphaTest = 0;
      }
      get alphaTest() {
        return this._alphaTest;
      }
      set alphaTest(value) {
        if (this._alphaTest > 0 !== value > 0) {
          this.version++;
        }
        this._alphaTest = value;
      }
      onBuild() {
      }
      onBeforeRender() {
      }
      onBeforeCompile() {
      }
      customProgramCacheKey() {
        return this.onBeforeCompile.toString();
      }
      setValues(values) {
        if (values === void 0)
          return;
        for (const key2 in values) {
          const newValue = values[key2];
          if (newValue === void 0) {
            console.warn("THREE.Material: '" + key2 + "' parameter is undefined.");
            continue;
          }
          if (key2 === "shading") {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            this.flatShading = newValue === FlatShading ? true : false;
            continue;
          }
          const currentValue = this[key2];
          if (currentValue === void 0) {
            console.warn("THREE." + this.type + ": '" + key2 + "' is not a property of this material.");
            continue;
          }
          if (currentValue && currentValue.isColor) {
            currentValue.set(newValue);
          } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
            currentValue.copy(newValue);
          } else {
            this[key2] = newValue;
          }
        }
      }
      toJSON(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        if (isRootObject) {
          meta = {
            textures: {},
            images: {}
          };
        }
        const data = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON"
          }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "")
          data.name = this.name;
        if (this.color && this.color.isColor)
          data.color = this.color.getHex();
        if (this.roughness !== void 0)
          data.roughness = this.roughness;
        if (this.metalness !== void 0)
          data.metalness = this.metalness;
        if (this.sheen !== void 0)
          data.sheen = this.sheen;
        if (this.sheenColor && this.sheenColor.isColor)
          data.sheenColor = this.sheenColor.getHex();
        if (this.sheenRoughness !== void 0)
          data.sheenRoughness = this.sheenRoughness;
        if (this.emissive && this.emissive.isColor)
          data.emissive = this.emissive.getHex();
        if (this.emissiveIntensity && this.emissiveIntensity !== 1)
          data.emissiveIntensity = this.emissiveIntensity;
        if (this.specular && this.specular.isColor)
          data.specular = this.specular.getHex();
        if (this.specularIntensity !== void 0)
          data.specularIntensity = this.specularIntensity;
        if (this.specularColor && this.specularColor.isColor)
          data.specularColor = this.specularColor.getHex();
        if (this.shininess !== void 0)
          data.shininess = this.shininess;
        if (this.clearcoat !== void 0)
          data.clearcoat = this.clearcoat;
        if (this.clearcoatRoughness !== void 0)
          data.clearcoatRoughness = this.clearcoatRoughness;
        if (this.clearcoatMap && this.clearcoatMap.isTexture) {
          data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
        }
        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
          data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
        }
        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
          data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
          data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
        }
        if (this.iridescence !== void 0)
          data.iridescence = this.iridescence;
        if (this.iridescenceIOR !== void 0)
          data.iridescenceIOR = this.iridescenceIOR;
        if (this.iridescenceThicknessRange !== void 0)
          data.iridescenceThicknessRange = this.iridescenceThicknessRange;
        if (this.iridescenceMap && this.iridescenceMap.isTexture) {
          data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
        }
        if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
          data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
        }
        if (this.map && this.map.isTexture)
          data.map = this.map.toJSON(meta).uuid;
        if (this.matcap && this.matcap.isTexture)
          data.matcap = this.matcap.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture)
          data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture) {
          data.lightMap = this.lightMap.toJSON(meta).uuid;
          data.lightMapIntensity = this.lightMapIntensity;
        }
        if (this.aoMap && this.aoMap.isTexture) {
          data.aoMap = this.aoMap.toJSON(meta).uuid;
          data.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
          data.bumpMap = this.bumpMap.toJSON(meta).uuid;
          data.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
          data.normalMap = this.normalMap.toJSON(meta).uuid;
          data.normalMapType = this.normalMapType;
          data.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
          data.displacementMap = this.displacementMap.toJSON(meta).uuid;
          data.displacementScale = this.displacementScale;
          data.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture)
          data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture)
          data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture)
          data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture)
          data.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
          data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
        if (this.specularColorMap && this.specularColorMap.isTexture)
          data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
          data.envMap = this.envMap.toJSON(meta).uuid;
          if (this.combine !== void 0)
            data.combine = this.combine;
        }
        if (this.envMapIntensity !== void 0)
          data.envMapIntensity = this.envMapIntensity;
        if (this.reflectivity !== void 0)
          data.reflectivity = this.reflectivity;
        if (this.refractionRatio !== void 0)
          data.refractionRatio = this.refractionRatio;
        if (this.gradientMap && this.gradientMap.isTexture) {
          data.gradientMap = this.gradientMap.toJSON(meta).uuid;
        }
        if (this.transmission !== void 0)
          data.transmission = this.transmission;
        if (this.transmissionMap && this.transmissionMap.isTexture)
          data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
        if (this.thickness !== void 0)
          data.thickness = this.thickness;
        if (this.thicknessMap && this.thicknessMap.isTexture)
          data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
        if (this.attenuationDistance !== void 0)
          data.attenuationDistance = this.attenuationDistance;
        if (this.attenuationColor !== void 0)
          data.attenuationColor = this.attenuationColor.getHex();
        if (this.size !== void 0)
          data.size = this.size;
        if (this.shadowSide !== null)
          data.shadowSide = this.shadowSide;
        if (this.sizeAttenuation !== void 0)
          data.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== NormalBlending)
          data.blending = this.blending;
        if (this.side !== FrontSide)
          data.side = this.side;
        if (this.vertexColors)
          data.vertexColors = true;
        if (this.opacity < 1)
          data.opacity = this.opacity;
        if (this.transparent === true)
          data.transparent = this.transparent;
        data.depthFunc = this.depthFunc;
        data.depthTest = this.depthTest;
        data.depthWrite = this.depthWrite;
        data.colorWrite = this.colorWrite;
        data.stencilWrite = this.stencilWrite;
        data.stencilWriteMask = this.stencilWriteMask;
        data.stencilFunc = this.stencilFunc;
        data.stencilRef = this.stencilRef;
        data.stencilFuncMask = this.stencilFuncMask;
        data.stencilFail = this.stencilFail;
        data.stencilZFail = this.stencilZFail;
        data.stencilZPass = this.stencilZPass;
        if (this.rotation !== void 0 && this.rotation !== 0)
          data.rotation = this.rotation;
        if (this.polygonOffset === true)
          data.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0)
          data.polygonOffsetFactor = this.polygonOffsetFactor;
        if (this.polygonOffsetUnits !== 0)
          data.polygonOffsetUnits = this.polygonOffsetUnits;
        if (this.linewidth !== void 0 && this.linewidth !== 1)
          data.linewidth = this.linewidth;
        if (this.dashSize !== void 0)
          data.dashSize = this.dashSize;
        if (this.gapSize !== void 0)
          data.gapSize = this.gapSize;
        if (this.scale !== void 0)
          data.scale = this.scale;
        if (this.dithering === true)
          data.dithering = true;
        if (this.alphaTest > 0)
          data.alphaTest = this.alphaTest;
        if (this.alphaToCoverage === true)
          data.alphaToCoverage = this.alphaToCoverage;
        if (this.premultipliedAlpha === true)
          data.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === true)
          data.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1)
          data.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== "round")
          data.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== "round")
          data.wireframeLinejoin = this.wireframeLinejoin;
        if (this.flatShading === true)
          data.flatShading = this.flatShading;
        if (this.visible === false)
          data.visible = false;
        if (this.toneMapped === false)
          data.toneMapped = false;
        if (this.fog === false)
          data.fog = false;
        if (JSON.stringify(this.userData) !== "{}")
          data.userData = this.userData;
        function extractFromCache(cache) {
          const values = [];
          for (const key2 in cache) {
            const data2 = cache[key2];
            delete data2.metadata;
            values.push(data2);
          }
          return values;
        }
        if (isRootObject) {
          const textures = extractFromCache(meta.textures);
          const images = extractFromCache(meta.images);
          if (textures.length > 0)
            data.textures = textures;
          if (images.length > 0)
            data.images = images;
        }
        return data;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.name = source.name;
        this.blending = source.blending;
        this.side = source.side;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.stencilWriteMask = source.stencilWriteMask;
        this.stencilFunc = source.stencilFunc;
        this.stencilRef = source.stencilRef;
        this.stencilFuncMask = source.stencilFuncMask;
        this.stencilFail = source.stencilFail;
        this.stencilZFail = source.stencilZFail;
        this.stencilZPass = source.stencilZPass;
        this.stencilWrite = source.stencilWrite;
        const srcPlanes = source.clippingPlanes;
        let dstPlanes = null;
        if (srcPlanes !== null) {
          const n2 = srcPlanes.length;
          dstPlanes = new Array(n2);
          for (let i22 = 0; i22 !== n2; ++i22) {
            dstPlanes[i22] = srcPlanes[i22].clone();
          }
        }
        this.clippingPlanes = dstPlanes;
        this.clipIntersection = source.clipIntersection;
        this.clipShadows = source.clipShadows;
        this.shadowSide = source.shadowSide;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.alphaToCoverage = source.alphaToCoverage;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.visible = source.visible;
        this.toneMapped = source.toneMapped;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      }
    };
    MeshBasicMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isMeshBasicMaterial = true;
        this.type = "MeshBasicMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.fog = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.fog = source.fog;
        return this;
      }
    };
    _vector$9 = /* @__PURE__ */ new Vector3();
    _vector2$1 = /* @__PURE__ */ new Vector2();
    BufferAttribute = class {
      constructor(array2, itemSize, normalized) {
        if (Array.isArray(array2)) {
          throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        }
        this.isBufferAttribute = true;
        this.name = "";
        this.array = array2;
        this.itemSize = itemSize;
        this.count = array2 !== void 0 ? array2.length / itemSize : 0;
        this.normalized = normalized === true;
        this.usage = StaticDrawUsage;
        this.updateRange = { offset: 0, count: -1 };
        this.version = 0;
      }
      onUploadCallback() {
      }
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      }
      setUsage(value) {
        this.usage = value;
        return this;
      }
      copy(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.usage = source.usage;
        return this;
      }
      copyAt(index1, attribute, index22) {
        index1 *= this.itemSize;
        index22 *= attribute.itemSize;
        for (let i22 = 0, l2 = this.itemSize; i22 < l2; i22++) {
          this.array[index1 + i22] = attribute.array[index22 + i22];
        }
        return this;
      }
      copyArray(array2) {
        this.array.set(array2);
        return this;
      }
      copyColorsArray(colors) {
        const array2 = this.array;
        let offset = 0;
        for (let i22 = 0, l2 = colors.length; i22 < l2; i22++) {
          let color = colors[i22];
          if (color === void 0) {
            console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i22);
            color = new Color();
          }
          array2[offset++] = color.r;
          array2[offset++] = color.g;
          array2[offset++] = color.b;
        }
        return this;
      }
      copyVector2sArray(vectors) {
        const array2 = this.array;
        let offset = 0;
        for (let i22 = 0, l2 = vectors.length; i22 < l2; i22++) {
          let vector = vectors[i22];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i22);
            vector = new Vector2();
          }
          array2[offset++] = vector.x;
          array2[offset++] = vector.y;
        }
        return this;
      }
      copyVector3sArray(vectors) {
        const array2 = this.array;
        let offset = 0;
        for (let i22 = 0, l2 = vectors.length; i22 < l2; i22++) {
          let vector = vectors[i22];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i22);
            vector = new Vector3();
          }
          array2[offset++] = vector.x;
          array2[offset++] = vector.y;
          array2[offset++] = vector.z;
        }
        return this;
      }
      copyVector4sArray(vectors) {
        const array2 = this.array;
        let offset = 0;
        for (let i22 = 0, l2 = vectors.length; i22 < l2; i22++) {
          let vector = vectors[i22];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i22);
            vector = new Vector4();
          }
          array2[offset++] = vector.x;
          array2[offset++] = vector.y;
          array2[offset++] = vector.z;
          array2[offset++] = vector.w;
        }
        return this;
      }
      applyMatrix3(m22) {
        if (this.itemSize === 2) {
          for (let i22 = 0, l2 = this.count; i22 < l2; i22++) {
            _vector2$1.fromBufferAttribute(this, i22);
            _vector2$1.applyMatrix3(m22);
            this.setXY(i22, _vector2$1.x, _vector2$1.y);
          }
        } else if (this.itemSize === 3) {
          for (let i22 = 0, l2 = this.count; i22 < l2; i22++) {
            _vector$9.fromBufferAttribute(this, i22);
            _vector$9.applyMatrix3(m22);
            this.setXYZ(i22, _vector$9.x, _vector$9.y, _vector$9.z);
          }
        }
        return this;
      }
      applyMatrix4(m22) {
        for (let i22 = 0, l2 = this.count; i22 < l2; i22++) {
          _vector$9.fromBufferAttribute(this, i22);
          _vector$9.applyMatrix4(m22);
          this.setXYZ(i22, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
      }
      applyNormalMatrix(m22) {
        for (let i22 = 0, l2 = this.count; i22 < l2; i22++) {
          _vector$9.fromBufferAttribute(this, i22);
          _vector$9.applyNormalMatrix(m22);
          this.setXYZ(i22, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
      }
      transformDirection(m22) {
        for (let i22 = 0, l2 = this.count; i22 < l2; i22++) {
          _vector$9.fromBufferAttribute(this, i22);
          _vector$9.transformDirection(m22);
          this.setXYZ(i22, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
      }
      set(value, offset = 0) {
        this.array.set(value, offset);
        return this;
      }
      getX(index7) {
        return this.array[index7 * this.itemSize];
      }
      setX(index7, x22) {
        this.array[index7 * this.itemSize] = x22;
        return this;
      }
      getY(index7) {
        return this.array[index7 * this.itemSize + 1];
      }
      setY(index7, y2) {
        this.array[index7 * this.itemSize + 1] = y2;
        return this;
      }
      getZ(index7) {
        return this.array[index7 * this.itemSize + 2];
      }
      setZ(index7, z2) {
        this.array[index7 * this.itemSize + 2] = z2;
        return this;
      }
      getW(index7) {
        return this.array[index7 * this.itemSize + 3];
      }
      setW(index7, w2) {
        this.array[index7 * this.itemSize + 3] = w2;
        return this;
      }
      setXY(index7, x22, y2) {
        index7 *= this.itemSize;
        this.array[index7 + 0] = x22;
        this.array[index7 + 1] = y2;
        return this;
      }
      setXYZ(index7, x22, y2, z2) {
        index7 *= this.itemSize;
        this.array[index7 + 0] = x22;
        this.array[index7 + 1] = y2;
        this.array[index7 + 2] = z2;
        return this;
      }
      setXYZW(index7, x22, y2, z2, w2) {
        index7 *= this.itemSize;
        this.array[index7 + 0] = x22;
        this.array[index7 + 1] = y2;
        this.array[index7 + 2] = z2;
        this.array[index7 + 3] = w2;
        return this;
      }
      onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
      }
      clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }
      toJSON() {
        const data = {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.from(this.array),
          normalized: this.normalized
        };
        if (this.name !== "")
          data.name = this.name;
        if (this.usage !== StaticDrawUsage)
          data.usage = this.usage;
        if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
          data.updateRange = this.updateRange;
        return data;
      }
    };
    Uint16BufferAttribute = class extends BufferAttribute {
      constructor(array2, itemSize, normalized) {
        super(new Uint16Array(array2), itemSize, normalized);
      }
    };
    Uint32BufferAttribute = class extends BufferAttribute {
      constructor(array2, itemSize, normalized) {
        super(new Uint32Array(array2), itemSize, normalized);
      }
    };
    Float32BufferAttribute = class extends BufferAttribute {
      constructor(array2, itemSize, normalized) {
        super(new Float32Array(array2), itemSize, normalized);
      }
    };
    _id$1 = 0;
    _m1 = /* @__PURE__ */ new Matrix4();
    _obj = /* @__PURE__ */ new Object3D();
    _offset = /* @__PURE__ */ new Vector3();
    _box$1$1 = /* @__PURE__ */ new Box3();
    _boxMorphTargets = /* @__PURE__ */ new Box3();
    _vector$8 = /* @__PURE__ */ new Vector3();
    BufferGeometry = class extends EventDispatcher {
      constructor() {
        super();
        this.isBufferGeometry = true;
        Object.defineProperty(this, "id", { value: _id$1++ });
        this.uuid = generateUUID();
        this.name = "";
        this.type = "BufferGeometry";
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.morphTargetsRelative = false;
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.drawRange = { start: 0, count: Infinity };
        this.userData = {};
      }
      getIndex() {
        return this.index;
      }
      setIndex(index7) {
        if (Array.isArray(index7)) {
          this.index = new (arrayNeedsUint32(index7) ? Uint32BufferAttribute : Uint16BufferAttribute)(index7, 1);
        } else {
          this.index = index7;
        }
        return this;
      }
      getAttribute(name) {
        return this.attributes[name];
      }
      setAttribute(name, attribute) {
        this.attributes[name] = attribute;
        return this;
      }
      deleteAttribute(name) {
        delete this.attributes[name];
        return this;
      }
      hasAttribute(name) {
        return this.attributes[name] !== void 0;
      }
      addGroup(start, count, materialIndex = 0) {
        this.groups.push({
          start,
          count,
          materialIndex
        });
      }
      clearGroups() {
        this.groups = [];
      }
      setDrawRange(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
      }
      applyMatrix4(matrix) {
        const position = this.attributes.position;
        if (position !== void 0) {
          position.applyMatrix4(matrix);
          position.needsUpdate = true;
        }
        const normal = this.attributes.normal;
        if (normal !== void 0) {
          const normalMatrix = new Matrix3().getNormalMatrix(matrix);
          normal.applyNormalMatrix(normalMatrix);
          normal.needsUpdate = true;
        }
        const tangent = this.attributes.tangent;
        if (tangent !== void 0) {
          tangent.transformDirection(matrix);
          tangent.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
        return this;
      }
      applyQuaternion(q2) {
        _m1.makeRotationFromQuaternion(q2);
        this.applyMatrix4(_m1);
        return this;
      }
      rotateX(angle) {
        _m1.makeRotationX(angle);
        this.applyMatrix4(_m1);
        return this;
      }
      rotateY(angle) {
        _m1.makeRotationY(angle);
        this.applyMatrix4(_m1);
        return this;
      }
      rotateZ(angle) {
        _m1.makeRotationZ(angle);
        this.applyMatrix4(_m1);
        return this;
      }
      translate(x22, y2, z2) {
        _m1.makeTranslation(x22, y2, z2);
        this.applyMatrix4(_m1);
        return this;
      }
      scale(x22, y2, z2) {
        _m1.makeScale(x22, y2, z2);
        this.applyMatrix4(_m1);
        return this;
      }
      lookAt(vector) {
        _obj.lookAt(vector);
        _obj.updateMatrix();
        this.applyMatrix4(_obj.matrix);
        return this;
      }
      center() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset).negate();
        this.translate(_offset.x, _offset.y, _offset.z);
        return this;
      }
      setFromPoints(points) {
        const position = [];
        for (let i22 = 0, l2 = points.length; i22 < l2; i22++) {
          const point = points[i22];
          position.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute("position", new Float32BufferAttribute(position, 3));
        return this;
      }
      computeBoundingBox() {
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
          console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
          this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
          return;
        }
        if (position !== void 0) {
          this.boundingBox.setFromBufferAttribute(position);
          if (morphAttributesPosition) {
            for (let i22 = 0, il = morphAttributesPosition.length; i22 < il; i22++) {
              const morphAttribute = morphAttributesPosition[i22];
              _box$1$1.setFromBufferAttribute(morphAttribute);
              if (this.morphTargetsRelative) {
                _vector$8.addVectors(this.boundingBox.min, _box$1$1.min);
                this.boundingBox.expandByPoint(_vector$8);
                _vector$8.addVectors(this.boundingBox.max, _box$1$1.max);
                this.boundingBox.expandByPoint(_vector$8);
              } else {
                this.boundingBox.expandByPoint(_box$1$1.min);
                this.boundingBox.expandByPoint(_box$1$1.max);
              }
            }
          }
        } else {
          this.boundingBox.makeEmpty();
        }
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
          console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
      }
      computeBoundingSphere() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
          this.boundingSphere.set(new Vector3(), Infinity);
          return;
        }
        if (position) {
          const center = this.boundingSphere.center;
          _box$1$1.setFromBufferAttribute(position);
          if (morphAttributesPosition) {
            for (let i22 = 0, il = morphAttributesPosition.length; i22 < il; i22++) {
              const morphAttribute = morphAttributesPosition[i22];
              _boxMorphTargets.setFromBufferAttribute(morphAttribute);
              if (this.morphTargetsRelative) {
                _vector$8.addVectors(_box$1$1.min, _boxMorphTargets.min);
                _box$1$1.expandByPoint(_vector$8);
                _vector$8.addVectors(_box$1$1.max, _boxMorphTargets.max);
                _box$1$1.expandByPoint(_vector$8);
              } else {
                _box$1$1.expandByPoint(_boxMorphTargets.min);
                _box$1$1.expandByPoint(_boxMorphTargets.max);
              }
            }
          }
          _box$1$1.getCenter(center);
          let maxRadiusSq = 0;
          for (let i22 = 0, il = position.count; i22 < il; i22++) {
            _vector$8.fromBufferAttribute(position, i22);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
          if (morphAttributesPosition) {
            for (let i22 = 0, il = morphAttributesPosition.length; i22 < il; i22++) {
              const morphAttribute = morphAttributesPosition[i22];
              const morphTargetsRelative = this.morphTargetsRelative;
              for (let j2 = 0, jl = morphAttribute.count; j2 < jl; j2++) {
                _vector$8.fromBufferAttribute(morphAttribute, j2);
                if (morphTargetsRelative) {
                  _offset.fromBufferAttribute(position, j2);
                  _vector$8.add(_offset);
                }
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
              }
            }
          }
          this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
          if (isNaN(this.boundingSphere.radius)) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
      }
      computeTangents() {
        const index7 = this.index;
        const attributes = this.attributes;
        if (index7 === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
          console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
          return;
        }
        const indices = index7.array;
        const positions = attributes.position.array;
        const normals = attributes.normal.array;
        const uvs = attributes.uv.array;
        const nVertices = positions.length / 3;
        if (this.hasAttribute("tangent") === false) {
          this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
        }
        const tangents = this.getAttribute("tangent").array;
        const tan1 = [], tan2 = [];
        for (let i22 = 0; i22 < nVertices; i22++) {
          tan1[i22] = new Vector3();
          tan2[i22] = new Vector3();
        }
        const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
        function handleTriangle(a2, b2, c2) {
          vA.fromArray(positions, a2 * 3);
          vB.fromArray(positions, b2 * 3);
          vC.fromArray(positions, c2 * 3);
          uvA.fromArray(uvs, a2 * 2);
          uvB.fromArray(uvs, b2 * 2);
          uvC.fromArray(uvs, c2 * 2);
          vB.sub(vA);
          vC.sub(vA);
          uvB.sub(uvA);
          uvC.sub(uvA);
          const r22 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
          if (!isFinite(r22))
            return;
          sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r22);
          tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r22);
          tan1[a2].add(sdir);
          tan1[b2].add(sdir);
          tan1[c2].add(sdir);
          tan2[a2].add(tdir);
          tan2[b2].add(tdir);
          tan2[c2].add(tdir);
        }
        let groups = this.groups;
        if (groups.length === 0) {
          groups = [{
            start: 0,
            count: indices.length
          }];
        }
        for (let i22 = 0, il = groups.length; i22 < il; ++i22) {
          const group = groups[i22];
          const start = group.start;
          const count = group.count;
          for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
            handleTriangle(indices[j2 + 0], indices[j2 + 1], indices[j2 + 2]);
          }
        }
        const tmp = new Vector3(), tmp2 = new Vector3();
        const n2 = new Vector3(), n22 = new Vector3();
        function handleVertex(v2) {
          n2.fromArray(normals, v2 * 3);
          n22.copy(n2);
          const t22 = tan1[v2];
          tmp.copy(t22);
          tmp.sub(n2.multiplyScalar(n2.dot(t22))).normalize();
          tmp2.crossVectors(n22, t22);
          const test = tmp2.dot(tan2[v2]);
          const w2 = test < 0 ? -1 : 1;
          tangents[v2 * 4] = tmp.x;
          tangents[v2 * 4 + 1] = tmp.y;
          tangents[v2 * 4 + 2] = tmp.z;
          tangents[v2 * 4 + 3] = w2;
        }
        for (let i22 = 0, il = groups.length; i22 < il; ++i22) {
          const group = groups[i22];
          const start = group.start;
          const count = group.count;
          for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
            handleVertex(indices[j2 + 0]);
            handleVertex(indices[j2 + 1]);
            handleVertex(indices[j2 + 2]);
          }
        }
      }
      computeVertexNormals() {
        const index7 = this.index;
        const positionAttribute = this.getAttribute("position");
        if (positionAttribute !== void 0) {
          let normalAttribute = this.getAttribute("normal");
          if (normalAttribute === void 0) {
            normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
            this.setAttribute("normal", normalAttribute);
          } else {
            for (let i22 = 0, il = normalAttribute.count; i22 < il; i22++) {
              normalAttribute.setXYZ(i22, 0, 0, 0);
            }
          }
          const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
          const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
          const cb = new Vector3(), ab = new Vector3();
          if (index7) {
            for (let i22 = 0, il = index7.count; i22 < il; i22 += 3) {
              const vA = index7.getX(i22 + 0);
              const vB = index7.getX(i22 + 1);
              const vC = index7.getX(i22 + 2);
              pA.fromBufferAttribute(positionAttribute, vA);
              pB.fromBufferAttribute(positionAttribute, vB);
              pC.fromBufferAttribute(positionAttribute, vC);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              nA.fromBufferAttribute(normalAttribute, vA);
              nB.fromBufferAttribute(normalAttribute, vB);
              nC.fromBufferAttribute(normalAttribute, vC);
              nA.add(cb);
              nB.add(cb);
              nC.add(cb);
              normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
              normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
              normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
            }
          } else {
            for (let i22 = 0, il = positionAttribute.count; i22 < il; i22 += 3) {
              pA.fromBufferAttribute(positionAttribute, i22 + 0);
              pB.fromBufferAttribute(positionAttribute, i22 + 1);
              pC.fromBufferAttribute(positionAttribute, i22 + 2);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              normalAttribute.setXYZ(i22 + 0, cb.x, cb.y, cb.z);
              normalAttribute.setXYZ(i22 + 1, cb.x, cb.y, cb.z);
              normalAttribute.setXYZ(i22 + 2, cb.x, cb.y, cb.z);
            }
          }
          this.normalizeNormals();
          normalAttribute.needsUpdate = true;
        }
      }
      merge(geometry, offset) {
        if (!(geometry && geometry.isBufferGeometry)) {
          console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
          return;
        }
        if (offset === void 0) {
          offset = 0;
          console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
        }
        const attributes = this.attributes;
        for (const key2 in attributes) {
          if (geometry.attributes[key2] === void 0)
            continue;
          const attribute1 = attributes[key2];
          const attributeArray1 = attribute1.array;
          const attribute2 = geometry.attributes[key2];
          const attributeArray2 = attribute2.array;
          const attributeOffset = attribute2.itemSize * offset;
          const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
          for (let i22 = 0, j2 = attributeOffset; i22 < length; i22++, j2++) {
            attributeArray1[j2] = attributeArray2[i22];
          }
        }
        return this;
      }
      normalizeNormals() {
        const normals = this.attributes.normal;
        for (let i22 = 0, il = normals.count; i22 < il; i22++) {
          _vector$8.fromBufferAttribute(normals, i22);
          _vector$8.normalize();
          normals.setXYZ(i22, _vector$8.x, _vector$8.y, _vector$8.z);
        }
      }
      toNonIndexed() {
        function convertBufferAttribute(attribute, indices2) {
          const array2 = attribute.array;
          const itemSize = attribute.itemSize;
          const normalized = attribute.normalized;
          const array22 = new array2.constructor(indices2.length * itemSize);
          let index7 = 0, index22 = 0;
          for (let i22 = 0, l2 = indices2.length; i22 < l2; i22++) {
            if (attribute.isInterleavedBufferAttribute) {
              index7 = indices2[i22] * attribute.data.stride + attribute.offset;
            } else {
              index7 = indices2[i22] * itemSize;
            }
            for (let j2 = 0; j2 < itemSize; j2++) {
              array22[index22++] = array2[index7++];
            }
          }
          return new BufferAttribute(array22, itemSize, normalized);
        }
        if (this.index === null) {
          console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
          return this;
        }
        const geometry2 = new BufferGeometry();
        const indices = this.index.array;
        const attributes = this.attributes;
        for (const name in attributes) {
          const attribute = attributes[name];
          const newAttribute = convertBufferAttribute(attribute, indices);
          geometry2.setAttribute(name, newAttribute);
        }
        const morphAttributes = this.morphAttributes;
        for (const name in morphAttributes) {
          const morphArray = [];
          const morphAttribute = morphAttributes[name];
          for (let i22 = 0, il = morphAttribute.length; i22 < il; i22++) {
            const attribute = morphAttribute[i22];
            const newAttribute = convertBufferAttribute(attribute, indices);
            morphArray.push(newAttribute);
          }
          geometry2.morphAttributes[name] = morphArray;
        }
        geometry2.morphTargetsRelative = this.morphTargetsRelative;
        const groups = this.groups;
        for (let i22 = 0, l2 = groups.length; i22 < l2; i22++) {
          const group = groups[i22];
          geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
      }
      toJSON() {
        const data = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON"
          }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "")
          data.name = this.name;
        if (Object.keys(this.userData).length > 0)
          data.userData = this.userData;
        if (this.parameters !== void 0) {
          const parameters = this.parameters;
          for (const key2 in parameters) {
            if (parameters[key2] !== void 0)
              data[key2] = parameters[key2];
          }
          return data;
        }
        data.data = { attributes: {} };
        const index7 = this.index;
        if (index7 !== null) {
          data.data.index = {
            type: index7.array.constructor.name,
            array: Array.prototype.slice.call(index7.array)
          };
        }
        const attributes = this.attributes;
        for (const key2 in attributes) {
          const attribute = attributes[key2];
          data.data.attributes[key2] = attribute.toJSON(data.data);
        }
        const morphAttributes = {};
        let hasMorphAttributes = false;
        for (const key2 in this.morphAttributes) {
          const attributeArray = this.morphAttributes[key2];
          const array2 = [];
          for (let i22 = 0, il = attributeArray.length; i22 < il; i22++) {
            const attribute = attributeArray[i22];
            array2.push(attribute.toJSON(data.data));
          }
          if (array2.length > 0) {
            morphAttributes[key2] = array2;
            hasMorphAttributes = true;
          }
        }
        if (hasMorphAttributes) {
          data.data.morphAttributes = morphAttributes;
          data.data.morphTargetsRelative = this.morphTargetsRelative;
        }
        const groups = this.groups;
        if (groups.length > 0) {
          data.data.groups = JSON.parse(JSON.stringify(groups));
        }
        const boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) {
          data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
          };
        }
        return data;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        const data = {};
        this.name = source.name;
        const index7 = source.index;
        if (index7 !== null) {
          this.setIndex(index7.clone(data));
        }
        const attributes = source.attributes;
        for (const name in attributes) {
          const attribute = attributes[name];
          this.setAttribute(name, attribute.clone(data));
        }
        const morphAttributes = source.morphAttributes;
        for (const name in morphAttributes) {
          const array2 = [];
          const morphAttribute = morphAttributes[name];
          for (let i22 = 0, l2 = morphAttribute.length; i22 < l2; i22++) {
            array2.push(morphAttribute[i22].clone(data));
          }
          this.morphAttributes[name] = array2;
        }
        this.morphTargetsRelative = source.morphTargetsRelative;
        const groups = source.groups;
        for (let i22 = 0, l2 = groups.length; i22 < l2; i22++) {
          const group = groups[i22];
          this.addGroup(group.start, group.count, group.materialIndex);
        }
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) {
          this.boundingBox = boundingBox.clone();
        }
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) {
          this.boundingSphere = boundingSphere.clone();
        }
        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;
        this.userData = source.userData;
        if (source.parameters !== void 0)
          this.parameters = Object.assign({}, source.parameters);
        return this;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    };
    _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
    _ray$2 = /* @__PURE__ */ new Ray();
    _sphere$3 = /* @__PURE__ */ new Sphere();
    _vA$1 = /* @__PURE__ */ new Vector3();
    _vB$1 = /* @__PURE__ */ new Vector3();
    _vC$1 = /* @__PURE__ */ new Vector3();
    _tempA = /* @__PURE__ */ new Vector3();
    _tempB = /* @__PURE__ */ new Vector3();
    _tempC = /* @__PURE__ */ new Vector3();
    _morphA = /* @__PURE__ */ new Vector3();
    _morphB = /* @__PURE__ */ new Vector3();
    _morphC = /* @__PURE__ */ new Vector3();
    _uvA$1 = /* @__PURE__ */ new Vector2();
    _uvB$1 = /* @__PURE__ */ new Vector2();
    _uvC$1 = /* @__PURE__ */ new Vector2();
    _intersectionPoint = /* @__PURE__ */ new Vector3();
    _intersectionPointWorld = /* @__PURE__ */ new Vector3();
    Mesh$1 = class extends Object3D {
      constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
        super();
        this.isMesh = true;
        this.type = "Mesh";
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        if (source.morphTargetInfluences !== void 0) {
          this.morphTargetInfluences = source.morphTargetInfluences.slice();
        }
        if (source.morphTargetDictionary !== void 0) {
          this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
        }
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
      }
      updateMorphTargets() {
        const geometry = this.geometry;
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          const morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (let m22 = 0, ml = morphAttribute.length; m22 < ml; m22++) {
              const name = morphAttribute[m22].name || String(m22);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m22;
            }
          }
        }
      }
      raycast(raycaster, intersects) {
        const geometry = this.geometry;
        const material = this.material;
        const matrixWorld = this.matrixWorld;
        if (material === void 0)
          return;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$3.copy(geometry.boundingSphere);
        _sphere$3.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(_sphere$3) === false)
          return;
        _inverseMatrix$2.copy(matrixWorld).invert();
        _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
        if (geometry.boundingBox !== null) {
          if (_ray$2.intersectsBox(geometry.boundingBox) === false)
            return;
        }
        let intersection;
        const index7 = geometry.index;
        const position = geometry.attributes.position;
        const morphPosition = geometry.morphAttributes.position;
        const morphTargetsRelative = geometry.morphTargetsRelative;
        const uv = geometry.attributes.uv;
        const uv2 = geometry.attributes.uv2;
        const groups = geometry.groups;
        const drawRange = geometry.drawRange;
        if (index7 !== null) {
          if (Array.isArray(material)) {
            for (let i22 = 0, il = groups.length; i22 < il; i22++) {
              const group = groups[i22];
              const groupMaterial = material[group.materialIndex];
              const start = Math.max(group.start, drawRange.start);
              const end = Math.min(index7.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
              for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
                const a2 = index7.getX(j2);
                const b2 = index7.getX(j2 + 1);
                const c2 = index7.getX(j2 + 2);
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j2 / 3);
                  intersection.face.materialIndex = group.materialIndex;
                  intersects.push(intersection);
                }
              }
            }
          } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(index7.count, drawRange.start + drawRange.count);
            for (let i22 = start, il = end; i22 < il; i22 += 3) {
              const a2 = index7.getX(i22);
              const b2 = index7.getX(i22 + 1);
              const c2 = index7.getX(i22 + 2);
              intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(i22 / 3);
                intersects.push(intersection);
              }
            }
          }
        } else if (position !== void 0) {
          if (Array.isArray(material)) {
            for (let i22 = 0, il = groups.length; i22 < il; i22++) {
              const group = groups[i22];
              const groupMaterial = material[group.materialIndex];
              const start = Math.max(group.start, drawRange.start);
              const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
              for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
                const a2 = j2;
                const b2 = j2 + 1;
                const c2 = j2 + 2;
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j2 / 3);
                  intersection.face.materialIndex = group.materialIndex;
                  intersects.push(intersection);
                }
              }
            }
          } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(position.count, drawRange.start + drawRange.count);
            for (let i22 = start, il = end; i22 < il; i22 += 3) {
              const a2 = i22;
              const b2 = i22 + 1;
              const c2 = i22 + 2;
              intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(i22 / 3);
                intersects.push(intersection);
              }
            }
          }
        }
      }
    };
    BoxGeometry = class extends BufferGeometry {
      constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
        super();
        this.type = "BoxGeometry";
        this.parameters = {
          width,
          height,
          depth,
          widthSegments,
          heightSegments,
          depthSegments
        };
        const scope = this;
        widthSegments = Math.floor(widthSegments);
        heightSegments = Math.floor(heightSegments);
        depthSegments = Math.floor(depthSegments);
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        let numberOfVertices = 0;
        let groupStart = 0;
        buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
        buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
        buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
        buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
        buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
        buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function buildPlane(u2, v2, w2, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
          const segmentWidth = width2 / gridX;
          const segmentHeight = height2 / gridY;
          const widthHalf = width2 / 2;
          const heightHalf = height2 / 2;
          const depthHalf = depth2 / 2;
          const gridX1 = gridX + 1;
          const gridY1 = gridY + 1;
          let vertexCounter = 0;
          let groupCount = 0;
          const vector = new Vector3();
          for (let iy = 0; iy < gridY1; iy++) {
            const y2 = iy * segmentHeight - heightHalf;
            for (let ix = 0; ix < gridX1; ix++) {
              const x22 = ix * segmentWidth - widthHalf;
              vector[u2] = x22 * udir;
              vector[v2] = y2 * vdir;
              vector[w2] = depthHalf;
              vertices.push(vector.x, vector.y, vector.z);
              vector[u2] = 0;
              vector[v2] = 0;
              vector[w2] = depth2 > 0 ? 1 : -1;
              normals.push(vector.x, vector.y, vector.z);
              uvs.push(ix / gridX);
              uvs.push(1 - iy / gridY);
              vertexCounter += 1;
            }
          }
          for (let iy = 0; iy < gridY; iy++) {
            for (let ix = 0; ix < gridX; ix++) {
              const a2 = numberOfVertices + ix + gridX1 * iy;
              const b2 = numberOfVertices + ix + gridX1 * (iy + 1);
              const c2 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
              const d2 = numberOfVertices + (ix + 1) + gridX1 * iy;
              indices.push(a2, b2, d2);
              indices.push(b2, c2, d2);
              groupCount += 6;
            }
          }
          scope.addGroup(groupStart, groupCount, materialIndex);
          groupStart += groupCount;
          numberOfVertices += vertexCounter;
        }
      }
      static fromJSON(data) {
        return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
      }
    };
    UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
    default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    ShaderMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isShaderMaterial = true;
        this.type = "ShaderMaterial";
        this.defines = {};
        this.uniforms = {};
        this.vertexShader = default_vertex;
        this.fragmentShader = default_fragment;
        this.linewidth = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.clipping = false;
        this.extensions = {
          derivatives: false,
          fragDepth: false,
          drawBuffers: false,
          shaderTextureLOD: false
        };
        this.defaultAttributeValues = {
          "color": [1, 1, 1],
          "uv": [0, 0],
          "uv2": [0, 0]
        };
        this.index0AttributeName = void 0;
        this.uniformsNeedUpdate = false;
        this.glslVersion = null;
        if (parameters !== void 0) {
          if (parameters.attributes !== void 0) {
            console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
          }
          this.setValues(parameters);
        }
      }
      copy(source) {
        super.copy(source);
        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
        this.uniforms = cloneUniforms(source.uniforms);
        this.defines = Object.assign({}, source.defines);
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.fog = source.fog;
        this.lights = source.lights;
        this.clipping = source.clipping;
        this.extensions = Object.assign({}, source.extensions);
        this.glslVersion = source.glslVersion;
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.glslVersion = this.glslVersion;
        data.uniforms = {};
        for (const name in this.uniforms) {
          const uniform = this.uniforms[name];
          const value = uniform.value;
          if (value && value.isTexture) {
            data.uniforms[name] = {
              type: "t",
              value: value.toJSON(meta).uuid
            };
          } else if (value && value.isColor) {
            data.uniforms[name] = {
              type: "c",
              value: value.getHex()
            };
          } else if (value && value.isVector2) {
            data.uniforms[name] = {
              type: "v2",
              value: value.toArray()
            };
          } else if (value && value.isVector3) {
            data.uniforms[name] = {
              type: "v3",
              value: value.toArray()
            };
          } else if (value && value.isVector4) {
            data.uniforms[name] = {
              type: "v4",
              value: value.toArray()
            };
          } else if (value && value.isMatrix3) {
            data.uniforms[name] = {
              type: "m3",
              value: value.toArray()
            };
          } else if (value && value.isMatrix4) {
            data.uniforms[name] = {
              type: "m4",
              value: value.toArray()
            };
          } else {
            data.uniforms[name] = {
              value
            };
          }
        }
        if (Object.keys(this.defines).length > 0)
          data.defines = this.defines;
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;
        const extensions = {};
        for (const key2 in this.extensions) {
          if (this.extensions[key2] === true)
            extensions[key2] = true;
        }
        if (Object.keys(extensions).length > 0)
          data.extensions = extensions;
        return data;
      }
    };
    Camera = class extends Object3D {
      constructor() {
        super();
        this.isCamera = true;
        this.type = "Camera";
        this.matrixWorldInverse = new Matrix4();
        this.projectionMatrix = new Matrix4();
        this.projectionMatrixInverse = new Matrix4();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        return this;
      }
      getWorldDirection(target) {
        this.updateWorldMatrix(true, false);
        const e22 = this.matrixWorld.elements;
        return target.set(-e22[8], -e22[9], -e22[10]).normalize();
      }
      updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      updateWorldMatrix(updateParents, updateChildren) {
        super.updateWorldMatrix(updateParents, updateChildren);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    PerspectiveCamera$1 = class extends Camera {
      constructor(fov = 50, aspect = 1, near = 0.1, far = 2e3) {
        super();
        this.isPerspectiveCamera = true;
        this.type = "PerspectiveCamera";
        this.fov = fov;
        this.zoom = 1;
        this.near = near;
        this.far = far;
        this.focus = 10;
        this.aspect = aspect;
        this.view = null;
        this.filmGauge = 35;
        this.filmOffset = 0;
        this.updateProjectionMatrix();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
      }
      setFocalLength(focalLength) {
        const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
      }
      getFocalLength() {
        const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
      }
      getEffectiveFOV() {
        return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
      }
      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
      setViewOffset(fullWidth, fullHeight, x22, y2, width, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x22;
        this.view.offsetY = y2;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
      }
      clearViewOffset() {
        if (this.view !== null) {
          this.view.enabled = false;
        }
        this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const near = this.near;
        let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
        let height = 2 * top;
        let width = this.aspect * height;
        let left = -0.5 * width;
        const view = this.view;
        if (this.view !== null && this.view.enabled) {
          const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
          left += view.offsetX * width / fullWidth;
          top -= view.offsetY * height / fullHeight;
          width *= view.width / fullWidth;
          height *= view.height / fullHeight;
        }
        const skew = this.filmOffset;
        if (skew !== 0)
          left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null)
          data.object.view = Object.assign({}, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
      }
    };
    _vector1 = /* @__PURE__ */ new Vector3();
    _vector2 = /* @__PURE__ */ new Vector3();
    _normalMatrix = /* @__PURE__ */ new Matrix3();
    Plane = class {
      constructor(normal = new Vector3(1, 0, 0), constant = 0) {
        this.isPlane = true;
        this.normal = normal;
        this.constant = constant;
      }
      set(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
      }
      setComponents(x22, y2, z2, w2) {
        this.normal.set(x22, y2, z2);
        this.constant = w2;
        return this;
      }
      setFromNormalAndCoplanarPoint(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
      }
      setFromCoplanarPoints(a2, b2, c2) {
        const normal = _vector1.subVectors(c2, b2).cross(_vector2.subVectors(a2, b2)).normalize();
        this.setFromNormalAndCoplanarPoint(normal, a2);
        return this;
      }
      copy(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
      }
      normalize() {
        const inverseNormalLength = 1 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
      }
      negate() {
        this.constant *= -1;
        this.normal.negate();
        return this;
      }
      distanceToPoint(point) {
        return this.normal.dot(point) + this.constant;
      }
      distanceToSphere(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
      }
      projectPoint(point, target) {
        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
      }
      intersectLine(line, target) {
        const direction = line.delta(_vector1);
        const denominator = this.normal.dot(direction);
        if (denominator === 0) {
          if (this.distanceToPoint(line.start) === 0) {
            return target.copy(line.start);
          }
          return null;
        }
        const t22 = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t22 < 0 || t22 > 1) {
          return null;
        }
        return target.copy(direction).multiplyScalar(t22).add(line.start);
      }
      intersectsLine(line) {
        const startSign = this.distanceToPoint(line.start);
        const endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
      }
      intersectsBox(box) {
        return box.intersectsPlane(this);
      }
      intersectsSphere(sphere) {
        return sphere.intersectsPlane(this);
      }
      coplanarPoint(target) {
        return target.copy(this.normal).multiplyScalar(-this.constant);
      }
      applyMatrix4(matrix, optionalNormalMatrix) {
        const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
        const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
        const normal = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal);
        return this;
      }
      translate(offset) {
        this.constant -= offset.dot(this.normal);
        return this;
      }
      equals(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    _sphere$2 = /* @__PURE__ */ new Sphere();
    _vector$7 = /* @__PURE__ */ new Vector3();
    Frustum = class {
      constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
        this.planes = [p0, p1, p2, p3, p4, p5];
      }
      set(p0, p1, p2, p3, p4, p5) {
        const planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
      }
      copy(frustum) {
        const planes = this.planes;
        for (let i22 = 0; i22 < 6; i22++) {
          planes[i22].copy(frustum.planes[i22]);
        }
        return this;
      }
      setFromProjectionMatrix(m22) {
        const planes = this.planes;
        const me2 = m22.elements;
        const me0 = me2[0], me1 = me2[1], me22 = me2[2], me3 = me2[3];
        const me4 = me2[4], me5 = me2[5], me6 = me2[6], me7 = me2[7];
        const me8 = me2[8], me9 = me2[9], me10 = me2[10], me11 = me2[11];
        const me12 = me2[12], me13 = me2[13], me14 = me2[14], me15 = me2[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me22, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me22, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
      }
      intersectsObject(object) {
        const geometry = object.geometry;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
        return this.intersectsSphere(_sphere$2);
      }
      intersectsSprite(sprite) {
        _sphere$2.center.set(0, 0, 0);
        _sphere$2.radius = 0.7071067811865476;
        _sphere$2.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere(_sphere$2);
      }
      intersectsSphere(sphere) {
        const planes = this.planes;
        const center = sphere.center;
        const negRadius = -sphere.radius;
        for (let i22 = 0; i22 < 6; i22++) {
          const distance = planes[i22].distanceToPoint(center);
          if (distance < negRadius) {
            return false;
          }
        }
        return true;
      }
      intersectsBox(box) {
        const planes = this.planes;
        for (let i22 = 0; i22 < 6; i22++) {
          const plane = planes[i22];
          _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
          _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
          _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
          if (plane.distanceToPoint(_vector$7) < 0) {
            return false;
          }
        }
        return true;
      }
      containsPoint(point) {
        const planes = this.planes;
        for (let i22 = 0; i22 < 6; i22++) {
          if (planes[i22].distanceToPoint(point) < 0) {
            return false;
          }
        }
        return true;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    PlaneGeometry = class extends BufferGeometry {
      constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
        super();
        this.type = "PlaneGeometry";
        this.parameters = {
          width,
          height,
          widthSegments,
          heightSegments
        };
        const width_half = width / 2;
        const height_half = height / 2;
        const gridX = Math.floor(widthSegments);
        const gridY = Math.floor(heightSegments);
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        const segment_width = width / gridX;
        const segment_height = height / gridY;
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        for (let iy = 0; iy < gridY1; iy++) {
          const y2 = iy * segment_height - height_half;
          for (let ix = 0; ix < gridX1; ix++) {
            const x22 = ix * segment_width - width_half;
            vertices.push(x22, -y2, 0);
            normals.push(0, 0, 1);
            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);
          }
        }
        for (let iy = 0; iy < gridY; iy++) {
          for (let ix = 0; ix < gridX; ix++) {
            const a2 = ix + gridX1 * iy;
            const b2 = ix + gridX1 * (iy + 1);
            const c2 = ix + 1 + gridX1 * (iy + 1);
            const d2 = ix + 1 + gridX1 * iy;
            indices.push(a2, b2, d2);
            indices.push(b2, c2, d2);
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      }
      static fromJSON(data) {
        return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
      }
    };
    alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
    alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
    alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
    alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
    aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
    aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
    begin_vertex = "vec3 transformed = vec3( position );";
    beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
    bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
    iridescence_fragment = "#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n    3.2404542, -0.9692660,  0.0556434,\n   -1.5371385,  1.8760108, -0.2040259,\n   -0.4985314,  0.0415560,  1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n   vec3 sqrtF0 = sqrt( fresnel0 );\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n   float phase = 2.0 * PI * OPD * 1.0e-9;\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n   xyz /= 1.0685e-7;\n   vec3 srgb = XYZ_TO_REC709 * xyz;\n   return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n   vec3 I;\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\n   if ( cosTheta2Sq < 0.0 ) {\n       return vec3( 1.0 );\n   }\n   float cosTheta2 = sqrt( cosTheta2Sq );\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n   float R21 = R12;\n   float T121 = 1.0 - R12;\n   float phi12 = 0.0;\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n   float phi21 = PI - phi12;\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n   vec3 phi23 = vec3( 0.0 );\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n   vec3 phi = vec3( phi21 ) + phi23;\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n   vec3 r123 = sqrt( R123 );\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n   vec3 C0 = R12 + Rs;\n   I = C0;\n   vec3 Cm = Rs - T121;\n   for ( int m = 1; m <= 2; ++m ) {\n       Cm *= r123;\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n       I += Cm * Sm;\n   }\n   return max( I, vec3( 0.0 ) );\n}\n#endif";
    bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
    clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
    clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
    clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
    clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
    color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
    color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
    color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
    color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
    common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
    cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
    defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
    displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
    displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
    emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
    emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
    encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
    encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
    envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
    envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
    envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
    envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
    envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
    fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
    fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
    fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
    fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
    gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
    lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
    lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
    lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
    lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
    envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
    lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
    lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
    lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
    lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
    lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
    lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	#ifdef USE_IRIDESCENCE\n		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n	#else\n		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
    lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n	material.iridescence = 0.0;\n} else {\n	material.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n	material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n	material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
    lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
    lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
    logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
    logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
    logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
    logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
    map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
    map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
    map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
    map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
    metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
    metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
    morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
    morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
    morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
    morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
    normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
    normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
    normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
    normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
    normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
    normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
    clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
    clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
    clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
    iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
    output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
    packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
    premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
    project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
    dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
    dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
    roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
    roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
    shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
    shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
    shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
    shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
    skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
    skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif";
    skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
    skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
    specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
    specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
    tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
    tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
    transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
    transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
    uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
    uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
    uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
    uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
    uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
    uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
    worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
    vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
    fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n	#endif\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
    vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
    fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
    vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
    fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
    vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
    fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
    vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
    fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
    vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
    fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
    vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
    fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
    fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
    fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
    vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
    fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
    fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
    vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
    vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
    fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
    ShaderChunk = {
      alphamap_fragment,
      alphamap_pars_fragment,
      alphatest_fragment,
      alphatest_pars_fragment,
      aomap_fragment,
      aomap_pars_fragment,
      begin_vertex,
      beginnormal_vertex,
      bsdfs,
      iridescence_fragment,
      bumpmap_pars_fragment,
      clipping_planes_fragment,
      clipping_planes_pars_fragment,
      clipping_planes_pars_vertex,
      clipping_planes_vertex,
      color_fragment,
      color_pars_fragment,
      color_pars_vertex,
      color_vertex,
      common,
      cube_uv_reflection_fragment,
      defaultnormal_vertex,
      displacementmap_pars_vertex,
      displacementmap_vertex,
      emissivemap_fragment,
      emissivemap_pars_fragment,
      encodings_fragment,
      encodings_pars_fragment,
      envmap_fragment,
      envmap_common_pars_fragment,
      envmap_pars_fragment,
      envmap_pars_vertex,
      envmap_physical_pars_fragment,
      envmap_vertex,
      fog_vertex,
      fog_pars_vertex,
      fog_fragment,
      fog_pars_fragment,
      gradientmap_pars_fragment,
      lightmap_fragment,
      lightmap_pars_fragment,
      lights_lambert_vertex,
      lights_pars_begin,
      lights_toon_fragment,
      lights_toon_pars_fragment,
      lights_phong_fragment,
      lights_phong_pars_fragment,
      lights_physical_fragment,
      lights_physical_pars_fragment,
      lights_fragment_begin,
      lights_fragment_maps,
      lights_fragment_end,
      logdepthbuf_fragment,
      logdepthbuf_pars_fragment,
      logdepthbuf_pars_vertex,
      logdepthbuf_vertex,
      map_fragment,
      map_pars_fragment,
      map_particle_fragment,
      map_particle_pars_fragment,
      metalnessmap_fragment,
      metalnessmap_pars_fragment,
      morphcolor_vertex,
      morphnormal_vertex,
      morphtarget_pars_vertex,
      morphtarget_vertex,
      normal_fragment_begin,
      normal_fragment_maps,
      normal_pars_fragment,
      normal_pars_vertex,
      normal_vertex,
      normalmap_pars_fragment,
      clearcoat_normal_fragment_begin,
      clearcoat_normal_fragment_maps,
      clearcoat_pars_fragment,
      iridescence_pars_fragment,
      output_fragment,
      packing,
      premultiplied_alpha_fragment,
      project_vertex,
      dithering_fragment,
      dithering_pars_fragment,
      roughnessmap_fragment,
      roughnessmap_pars_fragment,
      shadowmap_pars_fragment,
      shadowmap_pars_vertex,
      shadowmap_vertex,
      shadowmask_pars_fragment,
      skinbase_vertex,
      skinning_pars_vertex,
      skinning_vertex,
      skinnormal_vertex,
      specularmap_fragment,
      specularmap_pars_fragment,
      tonemapping_fragment,
      tonemapping_pars_fragment,
      transmission_fragment,
      transmission_pars_fragment,
      uv_pars_fragment,
      uv_pars_vertex,
      uv_vertex,
      uv2_pars_fragment,
      uv2_pars_vertex,
      uv2_vertex,
      worldpos_vertex,
      background_vert: vertex$g,
      background_frag: fragment$g,
      cube_vert: vertex$f,
      cube_frag: fragment$f,
      depth_vert: vertex$e,
      depth_frag: fragment$e,
      distanceRGBA_vert: vertex$d,
      distanceRGBA_frag: fragment$d,
      equirect_vert: vertex$c,
      equirect_frag: fragment$c,
      linedashed_vert: vertex$b,
      linedashed_frag: fragment$b,
      meshbasic_vert: vertex$a,
      meshbasic_frag: fragment$a,
      meshlambert_vert: vertex$9,
      meshlambert_frag: fragment$9,
      meshmatcap_vert: vertex$8,
      meshmatcap_frag: fragment$8,
      meshnormal_vert: vertex$7,
      meshnormal_frag: fragment$7,
      meshphong_vert: vertex$6,
      meshphong_frag: fragment$6,
      meshphysical_vert: vertex$5,
      meshphysical_frag: fragment$5,
      meshtoon_vert: vertex$4,
      meshtoon_frag: fragment$4,
      points_vert: vertex$3,
      points_frag: fragment$3,
      shadow_vert: vertex$2,
      shadow_frag: fragment$2,
      sprite_vert: vertex$1,
      sprite_frag: fragment$1
    };
    UniformsLib = {
      common: {
        diffuse: { value: /* @__PURE__ */ new Color(16777215) },
        opacity: { value: 1 },
        map: { value: null },
        uvTransform: { value: /* @__PURE__ */ new Matrix3() },
        uv2Transform: { value: /* @__PURE__ */ new Matrix3() },
        alphaMap: { value: null },
        alphaTest: { value: 0 }
      },
      specularmap: {
        specularMap: { value: null }
      },
      envmap: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        ior: { value: 1.5 },
        refractionRatio: { value: 0.98 }
      },
      aomap: {
        aoMap: { value: null },
        aoMapIntensity: { value: 1 }
      },
      lightmap: {
        lightMap: { value: null },
        lightMapIntensity: { value: 1 }
      },
      emissivemap: {
        emissiveMap: { value: null }
      },
      bumpmap: {
        bumpMap: { value: null },
        bumpScale: { value: 1 }
      },
      normalmap: {
        normalMap: { value: null },
        normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) }
      },
      displacementmap: {
        displacementMap: { value: null },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 }
      },
      roughnessmap: {
        roughnessMap: { value: null }
      },
      metalnessmap: {
        metalnessMap: { value: null }
      },
      gradientmap: {
        gradientMap: { value: null }
      },
      fog: {
        fogDensity: { value: 25e-5 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: /* @__PURE__ */ new Color(16777215) }
      },
      lights: {
        ambientLightColor: { value: [] },
        lightProbe: { value: [] },
        directionalLights: { value: [], properties: {
          direction: {},
          color: {}
        } },
        directionalLightShadows: { value: [], properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        } },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: { value: [], properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {}
        } },
        spotLightShadows: { value: [], properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        } },
        spotShadowMap: { value: [] },
        spotShadowMatrix: { value: [] },
        pointLights: { value: [], properties: {
          color: {},
          position: {},
          decay: {},
          distance: {}
        } },
        pointLightShadows: { value: [], properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        } },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: { value: [], properties: {
          direction: {},
          skyColor: {},
          groundColor: {}
        } },
        rectAreaLights: { value: [], properties: {
          color: {},
          position: {},
          width: {},
          height: {}
        } },
        ltc_1: { value: null },
        ltc_2: { value: null }
      },
      points: {
        diffuse: { value: /* @__PURE__ */ new Color(16777215) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        alphaMap: { value: null },
        alphaTest: { value: 0 },
        uvTransform: { value: /* @__PURE__ */ new Matrix3() }
      },
      sprite: {
        diffuse: { value: /* @__PURE__ */ new Color(16777215) },
        opacity: { value: 1 },
        center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },
        rotation: { value: 0 },
        map: { value: null },
        alphaMap: { value: null },
        alphaTest: { value: 0 },
        uvTransform: { value: /* @__PURE__ */ new Matrix3() }
      }
    };
    ShaderLib = {
      basic: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.specularmap,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
      },
      lambert: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.specularmap,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: /* @__PURE__ */ new Color(0) }
          }
        ]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
      },
      phong: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.specularmap,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: /* @__PURE__ */ new Color(0) },
            specular: { value: /* @__PURE__ */ new Color(1118481) },
            shininess: { value: 30 }
          }
        ]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
      },
      standard: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.roughnessmap,
          UniformsLib.metalnessmap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: /* @__PURE__ */ new Color(0) },
            roughness: { value: 1 },
            metalness: { value: 0 },
            envMapIntensity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
      },
      toon: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.gradientmap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: /* @__PURE__ */ new Color(0) }
          }
        ]),
        vertexShader: ShaderChunk.meshtoon_vert,
        fragmentShader: ShaderChunk.meshtoon_frag
      },
      matcap: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.fog,
          {
            matcap: { value: null }
          }
        ]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
      },
      points: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.points,
          UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
      },
      dashed: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.fog,
          {
            scale: { value: 1 },
            dashSize: { value: 1 },
            totalSize: { value: 2 }
          }
        ]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
      },
      depth: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.displacementmap
        ]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
      },
      normal: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          {
            opacity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.meshnormal_vert,
        fragmentShader: ShaderChunk.meshnormal_frag
      },
      sprite: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.sprite,
          UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
      },
      background: {
        uniforms: {
          uvTransform: { value: /* @__PURE__ */ new Matrix3() },
          t2D: { value: null }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
      },
      cube: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.envmap,
          {
            opacity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
      },
      equirect: {
        uniforms: {
          tEquirect: { value: null }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
      },
      distanceRGBA: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.common,
          UniformsLib.displacementmap,
          {
            referencePosition: { value: /* @__PURE__ */ new Vector3() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 }
          }
        ]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
      },
      shadow: {
        uniforms: /* @__PURE__ */ mergeUniforms([
          UniformsLib.lights,
          UniformsLib.fog,
          {
            color: { value: /* @__PURE__ */ new Color(0) },
            opacity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
      }
    };
    ShaderLib.physical = {
      uniforms: /* @__PURE__ */ mergeUniforms([
        ShaderLib.standard.uniforms,
        {
          clearcoat: { value: 0 },
          clearcoatMap: { value: null },
          clearcoatRoughness: { value: 0 },
          clearcoatRoughnessMap: { value: null },
          clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
          clearcoatNormalMap: { value: null },
          iridescence: { value: 0 },
          iridescenceMap: { value: null },
          iridescenceIOR: { value: 1.3 },
          iridescenceThicknessMinimum: { value: 100 },
          iridescenceThicknessMaximum: { value: 400 },
          iridescenceThicknessMap: { value: null },
          sheen: { value: 0 },
          sheenColor: { value: /* @__PURE__ */ new Color(0) },
          sheenColorMap: { value: null },
          sheenRoughness: { value: 1 },
          sheenRoughnessMap: { value: null },
          transmission: { value: 0 },
          transmissionMap: { value: null },
          transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() },
          transmissionSamplerMap: { value: null },
          thickness: { value: 0 },
          thicknessMap: { value: null },
          attenuationDistance: { value: 0 },
          attenuationColor: { value: /* @__PURE__ */ new Color(0) },
          specularIntensity: { value: 1 },
          specularIntensityMap: { value: null },
          specularColor: { value: /* @__PURE__ */ new Color(1, 1, 1) },
          specularColorMap: { value: null }
        }
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag
    };
    OrthographicCamera = class extends Camera {
      constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
        super();
        this.isOrthographicCamera = true;
        this.type = "OrthographicCamera";
        this.zoom = 1;
        this.view = null;
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
        this.near = near;
        this.far = far;
        this.updateProjectionMatrix();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        return this;
      }
      setViewOffset(fullWidth, fullHeight, x22, y2, width, height) {
        if (this.view === null) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x22;
        this.view.offsetY = y2;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
      }
      clearViewOffset() {
        if (this.view !== null) {
          this.view.enabled = false;
        }
        this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const dx = (this.right - this.left) / (2 * this.zoom);
        const dy = (this.top - this.bottom) / (2 * this.zoom);
        const cx = (this.right + this.left) / 2;
        const cy = (this.top + this.bottom) / 2;
        let left = cx - dx;
        let right = cx + dx;
        let top = cy + dy;
        let bottom = cy - dy;
        if (this.view !== null && this.view.enabled) {
          const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
          const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          left += scaleW * this.view.offsetX;
          right = left + scaleW * this.view.width;
          top -= scaleH * this.view.offsetY;
          bottom = top - scaleH * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null)
          data.object.view = Object.assign({}, this.view);
        return data;
      }
    };
    Group$1 = class extends Object3D {
      constructor() {
        super();
        this.isGroup = true;
        this.type = "Group";
      }
    };
    Scene = class extends Object3D {
      constructor() {
        super();
        this.isScene = true;
        this.type = "Scene";
        this.background = null;
        this.environment = null;
        this.fog = null;
        this.overrideMaterial = null;
        this.autoUpdate = true;
        if (typeof __THREE_DEVTOOLS__ !== "undefined") {
          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
        }
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        if (source.background !== null)
          this.background = source.background.clone();
        if (source.environment !== null)
          this.environment = source.environment.clone();
        if (source.fog !== null)
          this.fog = source.fog.clone();
        if (source.overrideMaterial !== null)
          this.overrideMaterial = source.overrideMaterial.clone();
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        if (this.fog !== null)
          data.object.fog = this.fog.toJSON();
        return data;
      }
    };
    InterleavedBuffer = class {
      constructor(array2, stride) {
        this.isInterleavedBuffer = true;
        this.array = array2;
        this.stride = stride;
        this.count = array2 !== void 0 ? array2.length / stride : 0;
        this.usage = StaticDrawUsage;
        this.updateRange = { offset: 0, count: -1 };
        this.version = 0;
        this.uuid = generateUUID();
      }
      onUploadCallback() {
      }
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      }
      setUsage(value) {
        this.usage = value;
        return this;
      }
      copy(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.usage = source.usage;
        return this;
      }
      copyAt(index1, attribute, index22) {
        index1 *= this.stride;
        index22 *= attribute.stride;
        for (let i22 = 0, l2 = this.stride; i22 < l2; i22++) {
          this.array[index1 + i22] = attribute.array[index22 + i22];
        }
        return this;
      }
      set(value, offset = 0) {
        this.array.set(value, offset);
        return this;
      }
      clone(data) {
        if (data.arrayBuffers === void 0) {
          data.arrayBuffers = {};
        }
        if (this.array.buffer._uuid === void 0) {
          this.array.buffer._uuid = generateUUID();
        }
        if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
          data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
        }
        const array2 = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
        const ib = new this.constructor(array2, this.stride);
        ib.setUsage(this.usage);
        return ib;
      }
      onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
      }
      toJSON(data) {
        if (data.arrayBuffers === void 0) {
          data.arrayBuffers = {};
        }
        if (this.array.buffer._uuid === void 0) {
          this.array.buffer._uuid = generateUUID();
        }
        if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
          data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
        }
        return {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride
        };
      }
    };
    _vector$6 = /* @__PURE__ */ new Vector3();
    InterleavedBufferAttribute = class {
      constructor(interleavedBuffer, itemSize, offset, normalized = false) {
        this.isInterleavedBufferAttribute = true;
        this.name = "";
        this.data = interleavedBuffer;
        this.itemSize = itemSize;
        this.offset = offset;
        this.normalized = normalized === true;
      }
      get count() {
        return this.data.count;
      }
      get array() {
        return this.data.array;
      }
      set needsUpdate(value) {
        this.data.needsUpdate = value;
      }
      applyMatrix4(m22) {
        for (let i22 = 0, l2 = this.data.count; i22 < l2; i22++) {
          _vector$6.fromBufferAttribute(this, i22);
          _vector$6.applyMatrix4(m22);
          this.setXYZ(i22, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
      }
      applyNormalMatrix(m22) {
        for (let i22 = 0, l2 = this.count; i22 < l2; i22++) {
          _vector$6.fromBufferAttribute(this, i22);
          _vector$6.applyNormalMatrix(m22);
          this.setXYZ(i22, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
      }
      transformDirection(m22) {
        for (let i22 = 0, l2 = this.count; i22 < l2; i22++) {
          _vector$6.fromBufferAttribute(this, i22);
          _vector$6.transformDirection(m22);
          this.setXYZ(i22, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
      }
      setX(index7, x22) {
        this.data.array[index7 * this.data.stride + this.offset] = x22;
        return this;
      }
      setY(index7, y2) {
        this.data.array[index7 * this.data.stride + this.offset + 1] = y2;
        return this;
      }
      setZ(index7, z2) {
        this.data.array[index7 * this.data.stride + this.offset + 2] = z2;
        return this;
      }
      setW(index7, w2) {
        this.data.array[index7 * this.data.stride + this.offset + 3] = w2;
        return this;
      }
      getX(index7) {
        return this.data.array[index7 * this.data.stride + this.offset];
      }
      getY(index7) {
        return this.data.array[index7 * this.data.stride + this.offset + 1];
      }
      getZ(index7) {
        return this.data.array[index7 * this.data.stride + this.offset + 2];
      }
      getW(index7) {
        return this.data.array[index7 * this.data.stride + this.offset + 3];
      }
      setXY(index7, x22, y2) {
        index7 = index7 * this.data.stride + this.offset;
        this.data.array[index7 + 0] = x22;
        this.data.array[index7 + 1] = y2;
        return this;
      }
      setXYZ(index7, x22, y2, z2) {
        index7 = index7 * this.data.stride + this.offset;
        this.data.array[index7 + 0] = x22;
        this.data.array[index7 + 1] = y2;
        this.data.array[index7 + 2] = z2;
        return this;
      }
      setXYZW(index7, x22, y2, z2, w2) {
        index7 = index7 * this.data.stride + this.offset;
        this.data.array[index7 + 0] = x22;
        this.data.array[index7 + 1] = y2;
        this.data.array[index7 + 2] = z2;
        this.data.array[index7 + 3] = w2;
        return this;
      }
      clone(data) {
        if (data === void 0) {
          console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");
          const array2 = [];
          for (let i22 = 0; i22 < this.count; i22++) {
            const index7 = i22 * this.data.stride + this.offset;
            for (let j2 = 0; j2 < this.itemSize; j2++) {
              array2.push(this.data.array[index7 + j2]);
            }
          }
          return new BufferAttribute(new this.array.constructor(array2), this.itemSize, this.normalized);
        } else {
          if (data.interleavedBuffers === void 0) {
            data.interleavedBuffers = {};
          }
          if (data.interleavedBuffers[this.data.uuid] === void 0) {
            data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
          }
          return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
      }
      toJSON(data) {
        if (data === void 0) {
          console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");
          const array2 = [];
          for (let i22 = 0; i22 < this.count; i22++) {
            const index7 = i22 * this.data.stride + this.offset;
            for (let j2 = 0; j2 < this.itemSize; j2++) {
              array2.push(this.data.array[index7 + j2]);
            }
          }
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: array2,
            normalized: this.normalized
          };
        } else {
          if (data.interleavedBuffers === void 0) {
            data.interleavedBuffers = {};
          }
          if (data.interleavedBuffers[this.data.uuid] === void 0) {
            data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
          }
          return {
            isInterleavedBufferAttribute: true,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
          };
        }
      }
    };
    DataTexture = class extends Texture {
      constructor(data = null, width = 1, height = 1, format2, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
        this.isDataTexture = true;
        this.image = { data, width, height };
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
      }
    };
    CompressedTexture = class extends Texture {
      constructor(mipmaps, width, height, format2, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
        this.isCompressedTexture = true;
        this.image = { width, height };
        this.mipmaps = mipmaps;
        this.flipY = false;
        this.generateMipmaps = false;
      }
    };
    WireframeGeometry = class extends BufferGeometry {
      constructor(geometry = null) {
        super();
        this.type = "WireframeGeometry";
        this.parameters = {
          geometry
        };
        if (geometry !== null) {
          const vertices = [];
          const edges = /* @__PURE__ */ new Set();
          const start = new Vector3();
          const end = new Vector3();
          if (geometry.index !== null) {
            const position = geometry.attributes.position;
            const indices = geometry.index;
            let groups = geometry.groups;
            if (groups.length === 0) {
              groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
            }
            for (let o2 = 0, ol = groups.length; o2 < ol; ++o2) {
              const group = groups[o2];
              const groupStart = group.start;
              const groupCount = group.count;
              for (let i22 = groupStart, l2 = groupStart + groupCount; i22 < l2; i22 += 3) {
                for (let j2 = 0; j2 < 3; j2++) {
                  const index1 = indices.getX(i22 + j2);
                  const index22 = indices.getX(i22 + (j2 + 1) % 3);
                  start.fromBufferAttribute(position, index1);
                  end.fromBufferAttribute(position, index22);
                  if (isUniqueEdge(start, end, edges) === true) {
                    vertices.push(start.x, start.y, start.z);
                    vertices.push(end.x, end.y, end.z);
                  }
                }
              }
            }
          } else {
            const position = geometry.attributes.position;
            for (let i22 = 0, l2 = position.count / 3; i22 < l2; i22++) {
              for (let j2 = 0; j2 < 3; j2++) {
                const index1 = 3 * i22 + j2;
                const index22 = 3 * i22 + (j2 + 1) % 3;
                start.fromBufferAttribute(position, index1);
                end.fromBufferAttribute(position, index22);
                if (isUniqueEdge(start, end, edges) === true) {
                  vertices.push(start.x, start.y, start.z);
                  vertices.push(end.x, end.y, end.z);
                }
              }
            }
          }
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        }
      }
    };
    MeshPhongMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.isMeshPhongMaterial = true;
        this.type = "MeshPhongMaterial";
        this.color = new Color(16777215);
        this.specular = new Color(1118481);
        this.shininess = 30;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.flatShading = false;
        this.fog = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.flatShading = source.flatShading;
        this.fog = source.fog;
        return this;
      }
    };
    AnimationUtils = {
      arraySlice: function(array2, from, to) {
        if (AnimationUtils.isTypedArray(array2)) {
          return new array2.constructor(array2.subarray(from, to !== void 0 ? to : array2.length));
        }
        return array2.slice(from, to);
      },
      convertArray: function(array2, type, forceClone) {
        if (!array2 || !forceClone && array2.constructor === type)
          return array2;
        if (typeof type.BYTES_PER_ELEMENT === "number") {
          return new type(array2);
        }
        return Array.prototype.slice.call(array2);
      },
      isTypedArray: function(object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
      },
      getKeyframeOrder: function(times) {
        function compareTime(i22, j2) {
          return times[i22] - times[j2];
        }
        const n2 = times.length;
        const result = new Array(n2);
        for (let i22 = 0; i22 !== n2; ++i22)
          result[i22] = i22;
        result.sort(compareTime);
        return result;
      },
      sortedArray: function(values, stride, order) {
        const nValues = values.length;
        const result = new values.constructor(nValues);
        for (let i22 = 0, dstOffset = 0; dstOffset !== nValues; ++i22) {
          const srcOffset = order[i22] * stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            result[dstOffset++] = values[srcOffset + j2];
          }
        }
        return result;
      },
      flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
        let i22 = 1, key2 = jsonKeys[0];
        while (key2 !== void 0 && key2[valuePropertyName] === void 0) {
          key2 = jsonKeys[i22++];
        }
        if (key2 === void 0)
          return;
        let value = key2[valuePropertyName];
        if (value === void 0)
          return;
        if (Array.isArray(value)) {
          do {
            value = key2[valuePropertyName];
            if (value !== void 0) {
              times.push(key2.time);
              values.push.apply(values, value);
            }
            key2 = jsonKeys[i22++];
          } while (key2 !== void 0);
        } else if (value.toArray !== void 0) {
          do {
            value = key2[valuePropertyName];
            if (value !== void 0) {
              times.push(key2.time);
              value.toArray(values, values.length);
            }
            key2 = jsonKeys[i22++];
          } while (key2 !== void 0);
        } else {
          do {
            value = key2[valuePropertyName];
            if (value !== void 0) {
              times.push(key2.time);
              values.push(value);
            }
            key2 = jsonKeys[i22++];
          } while (key2 !== void 0);
        }
      },
      subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
        const clip = sourceClip.clone();
        clip.name = name;
        const tracks = [];
        for (let i22 = 0; i22 < clip.tracks.length; ++i22) {
          const track = clip.tracks[i22];
          const valueSize = track.getValueSize();
          const times = [];
          const values = [];
          for (let j2 = 0; j2 < track.times.length; ++j2) {
            const frame = track.times[j2] * fps;
            if (frame < startFrame || frame >= endFrame)
              continue;
            times.push(track.times[j2]);
            for (let k2 = 0; k2 < valueSize; ++k2) {
              values.push(track.values[j2 * valueSize + k2]);
            }
          }
          if (times.length === 0)
            continue;
          track.times = AnimationUtils.convertArray(times, track.times.constructor);
          track.values = AnimationUtils.convertArray(values, track.values.constructor);
          tracks.push(track);
        }
        clip.tracks = tracks;
        let minStartTime = Infinity;
        for (let i22 = 0; i22 < clip.tracks.length; ++i22) {
          if (minStartTime > clip.tracks[i22].times[0]) {
            minStartTime = clip.tracks[i22].times[0];
          }
        }
        for (let i22 = 0; i22 < clip.tracks.length; ++i22) {
          clip.tracks[i22].shift(-1 * minStartTime);
        }
        clip.resetDuration();
        return clip;
      },
      makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
        if (fps <= 0)
          fps = 30;
        const numTracks = referenceClip.tracks.length;
        const referenceTime = referenceFrame / fps;
        for (let i22 = 0; i22 < numTracks; ++i22) {
          const referenceTrack = referenceClip.tracks[i22];
          const referenceTrackType = referenceTrack.ValueTypeName;
          if (referenceTrackType === "bool" || referenceTrackType === "string")
            continue;
          const targetTrack = targetClip.tracks.find(function(track) {
            return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
          });
          if (targetTrack === void 0)
            continue;
          let referenceOffset = 0;
          const referenceValueSize = referenceTrack.getValueSize();
          if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
            referenceOffset = referenceValueSize / 3;
          }
          let targetOffset = 0;
          const targetValueSize = targetTrack.getValueSize();
          if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
            targetOffset = targetValueSize / 3;
          }
          const lastIndex = referenceTrack.times.length - 1;
          let referenceValue;
          if (referenceTime <= referenceTrack.times[0]) {
            const startIndex = referenceOffset;
            const endIndex = referenceValueSize - referenceOffset;
            referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
          } else if (referenceTime >= referenceTrack.times[lastIndex]) {
            const startIndex = lastIndex * referenceValueSize + referenceOffset;
            const endIndex = startIndex + referenceValueSize - referenceOffset;
            referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
          } else {
            const interpolant = referenceTrack.createInterpolant();
            const startIndex = referenceOffset;
            const endIndex = referenceValueSize - referenceOffset;
            interpolant.evaluate(referenceTime);
            referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
          }
          if (referenceTrackType === "quaternion") {
            const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
            referenceQuat.toArray(referenceValue);
          }
          const numTimes = targetTrack.times.length;
          for (let j2 = 0; j2 < numTimes; ++j2) {
            const valueStart = j2 * targetValueSize + targetOffset;
            if (referenceTrackType === "quaternion") {
              Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
            } else {
              const valueEnd = targetValueSize - targetOffset * 2;
              for (let k2 = 0; k2 < valueEnd; ++k2) {
                targetTrack.values[valueStart + k2] -= referenceValue[k2];
              }
            }
          }
        }
        targetClip.blendMode = AdditiveAnimationBlendMode;
        return targetClip;
      }
    };
    Interpolant = class {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        this.parameterPositions = parameterPositions;
        this._cachedIndex = 0;
        this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
        this.sampleValues = sampleValues;
        this.valueSize = sampleSize;
        this.settings = null;
        this.DefaultSettings_ = {};
      }
      evaluate(t22) {
        const pp = this.parameterPositions;
        let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
        validate_interval: {
          seek: {
            let right;
            linear_scan: {
              forward_scan:
                if (!(t22 < t1)) {
                  for (let giveUpAt = i1 + 2; ; ) {
                    if (t1 === void 0) {
                      if (t22 < t0)
                        break forward_scan;
                      i1 = pp.length;
                      this._cachedIndex = i1;
                      return this.copySampleValue_(i1 - 1);
                    }
                    if (i1 === giveUpAt)
                      break;
                    t0 = t1;
                    t1 = pp[++i1];
                    if (t22 < t1) {
                      break seek;
                    }
                  }
                  right = pp.length;
                  break linear_scan;
                }
              if (!(t22 >= t0)) {
                const t1global = pp[1];
                if (t22 < t1global) {
                  i1 = 2;
                  t0 = t1global;
                }
                for (let giveUpAt = i1 - 2; ; ) {
                  if (t0 === void 0) {
                    this._cachedIndex = 0;
                    return this.copySampleValue_(0);
                  }
                  if (i1 === giveUpAt)
                    break;
                  t1 = t0;
                  t0 = pp[--i1 - 1];
                  if (t22 >= t0) {
                    break seek;
                  }
                }
                right = i1;
                i1 = 0;
                break linear_scan;
              }
              break validate_interval;
            }
            while (i1 < right) {
              const mid = i1 + right >>> 1;
              if (t22 < pp[mid]) {
                right = mid;
              } else {
                i1 = mid + 1;
              }
            }
            t1 = pp[i1];
            t0 = pp[i1 - 1];
            if (t0 === void 0) {
              this._cachedIndex = 0;
              return this.copySampleValue_(0);
            }
            if (t1 === void 0) {
              i1 = pp.length;
              this._cachedIndex = i1;
              return this.copySampleValue_(i1 - 1);
            }
          }
          this._cachedIndex = i1;
          this.intervalChanged_(i1, t0, t1);
        }
        return this.interpolate_(i1, t0, t22, t1);
      }
      getSettings_() {
        return this.settings || this.DefaultSettings_;
      }
      copySampleValue_(index7) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index7 * stride;
        for (let i22 = 0; i22 !== stride; ++i22) {
          result[i22] = values[offset + i22];
        }
        return result;
      }
      interpolate_() {
        throw new Error("call to abstract method");
      }
      intervalChanged_() {
      }
    };
    CubicInterpolant = class extends Interpolant {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        this._weightPrev = -0;
        this._offsetPrev = -0;
        this._weightNext = -0;
        this._offsetNext = -0;
        this.DefaultSettings_ = {
          endingStart: ZeroCurvatureEnding,
          endingEnd: ZeroCurvatureEnding
        };
      }
      intervalChanged_(i1, t0, t1) {
        const pp = this.parameterPositions;
        let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === void 0) {
          switch (this.getSettings_().endingStart) {
            case ZeroSlopeEnding:
              iPrev = i1;
              tPrev = 2 * t0 - t1;
              break;
            case WrapAroundEnding:
              iPrev = pp.length - 2;
              tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
              break;
            default:
              iPrev = i1;
              tPrev = t1;
          }
        }
        if (tNext === void 0) {
          switch (this.getSettings_().endingEnd) {
            case ZeroSlopeEnding:
              iNext = i1;
              tNext = 2 * t1 - t0;
              break;
            case WrapAroundEnding:
              iNext = 1;
              tNext = t1 + pp[1] - pp[0];
              break;
            default:
              iNext = i1 - 1;
              tNext = t0;
          }
        }
        const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t1);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
      }
      interpolate_(i1, t0, t22, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p2 = (t22 - t0) / (t1 - t0), pp = p2 * p2, ppp = pp * p2;
        const sP = -wP * ppp + 2 * wP * pp - wP * p2;
        const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p2 + 1;
        const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p2;
        const sN = wN * ppp - wN * pp;
        for (let i22 = 0; i22 !== stride; ++i22) {
          result[i22] = sP * values[oP + i22] + s0 * values[o0 + i22] + s1 * values[o1 + i22] + sN * values[oN + i22];
        }
        return result;
      }
    };
    LinearInterpolant = class extends Interpolant {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      }
      interpolate_(i1, t0, t22, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t22 - t0) / (t1 - t0), weight0 = 1 - weight1;
        for (let i22 = 0; i22 !== stride; ++i22) {
          result[i22] = values[offset0 + i22] * weight0 + values[offset1 + i22] * weight1;
        }
        return result;
      }
    };
    DiscreteInterpolant = class extends Interpolant {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      }
      interpolate_(i1) {
        return this.copySampleValue_(i1 - 1);
      }
    };
    KeyframeTrack = class {
      constructor(name, times, values, interpolation) {
        if (name === void 0)
          throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (times === void 0 || times.length === 0)
          throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
        this.name = name;
        this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
        this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
        this.setInterpolation(interpolation || this.DefaultInterpolation);
      }
      static toJSON(track) {
        const trackType = track.constructor;
        let json;
        if (trackType.toJSON !== this.toJSON) {
          json = trackType.toJSON(track);
        } else {
          json = {
            "name": track.name,
            "times": AnimationUtils.convertArray(track.times, Array),
            "values": AnimationUtils.convertArray(track.values, Array)
          };
          const interpolation = track.getInterpolation();
          if (interpolation !== track.DefaultInterpolation) {
            json.interpolation = interpolation;
          }
        }
        json.type = track.ValueTypeName;
        return json;
      }
      InterpolantFactoryMethodDiscrete(result) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
      }
      InterpolantFactoryMethodLinear(result) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
      }
      InterpolantFactoryMethodSmooth(result) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
      }
      setInterpolation(interpolation) {
        let factoryMethod;
        switch (interpolation) {
          case InterpolateDiscrete:
            factoryMethod = this.InterpolantFactoryMethodDiscrete;
            break;
          case InterpolateLinear:
            factoryMethod = this.InterpolantFactoryMethodLinear;
            break;
          case InterpolateSmooth:
            factoryMethod = this.InterpolantFactoryMethodSmooth;
            break;
        }
        if (factoryMethod === void 0) {
          const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
          if (this.createInterpolant === void 0) {
            if (interpolation !== this.DefaultInterpolation) {
              this.setInterpolation(this.DefaultInterpolation);
            } else {
              throw new Error(message);
            }
          }
          console.warn("THREE.KeyframeTrack:", message);
          return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
      }
      getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return InterpolateDiscrete;
          case this.InterpolantFactoryMethodLinear:
            return InterpolateLinear;
          case this.InterpolantFactoryMethodSmooth:
            return InterpolateSmooth;
        }
      }
      getValueSize() {
        return this.values.length / this.times.length;
      }
      shift(timeOffset) {
        if (timeOffset !== 0) {
          const times = this.times;
          for (let i22 = 0, n2 = times.length; i22 !== n2; ++i22) {
            times[i22] += timeOffset;
          }
        }
        return this;
      }
      scale(timeScale) {
        if (timeScale !== 1) {
          const times = this.times;
          for (let i22 = 0, n2 = times.length; i22 !== n2; ++i22) {
            times[i22] *= timeScale;
          }
        }
        return this;
      }
      trim(startTime, endTime) {
        const times = this.times, nKeys = times.length;
        let from = 0, to = nKeys - 1;
        while (from !== nKeys && times[from] < startTime) {
          ++from;
        }
        while (to !== -1 && times[to] > endTime) {
          --to;
        }
        ++to;
        if (from !== 0 || to !== nKeys) {
          if (from >= to) {
            to = Math.max(to, 1);
            from = to - 1;
          }
          const stride = this.getValueSize();
          this.times = AnimationUtils.arraySlice(times, from, to);
          this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
        }
        return this;
      }
      validate() {
        let valid = true;
        const valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
          console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
          valid = false;
        }
        const times = this.times, values = this.values, nKeys = times.length;
        if (nKeys === 0) {
          console.error("THREE.KeyframeTrack: Track is empty.", this);
          valid = false;
        }
        let prevTime = null;
        for (let i22 = 0; i22 !== nKeys; i22++) {
          const currTime = times[i22];
          if (typeof currTime === "number" && isNaN(currTime)) {
            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i22, currTime);
            valid = false;
            break;
          }
          if (prevTime !== null && prevTime > currTime) {
            console.error("THREE.KeyframeTrack: Out of order keys.", this, i22, currTime, prevTime);
            valid = false;
            break;
          }
          prevTime = currTime;
        }
        if (values !== void 0) {
          if (AnimationUtils.isTypedArray(values)) {
            for (let i22 = 0, n2 = values.length; i22 !== n2; ++i22) {
              const value = values[i22];
              if (isNaN(value)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i22, value);
                valid = false;
                break;
              }
            }
          }
        }
        return valid;
      }
      optimize() {
        const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
        let writeIndex = 1;
        for (let i22 = 1; i22 < lastIndex; ++i22) {
          let keep = false;
          const time = times[i22];
          const timeNext = times[i22 + 1];
          if (time !== timeNext && (i22 !== 1 || time !== times[0])) {
            if (!smoothInterpolation) {
              const offset = i22 * stride, offsetP = offset - stride, offsetN = offset + stride;
              for (let j2 = 0; j2 !== stride; ++j2) {
                const value = values[offset + j2];
                if (value !== values[offsetP + j2] || value !== values[offsetN + j2]) {
                  keep = true;
                  break;
                }
              }
            } else {
              keep = true;
            }
          }
          if (keep) {
            if (i22 !== writeIndex) {
              times[writeIndex] = times[i22];
              const readOffset = i22 * stride, writeOffset = writeIndex * stride;
              for (let j2 = 0; j2 !== stride; ++j2) {
                values[writeOffset + j2] = values[readOffset + j2];
              }
            }
            ++writeIndex;
          }
        }
        if (lastIndex > 0) {
          times[writeIndex] = times[lastIndex];
          for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j2 = 0; j2 !== stride; ++j2) {
            values[writeOffset + j2] = values[readOffset + j2];
          }
          ++writeIndex;
        }
        if (writeIndex !== times.length) {
          this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
          this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
        } else {
          this.times = times;
          this.values = values;
        }
        return this;
      }
      clone() {
        const times = AnimationUtils.arraySlice(this.times, 0);
        const values = AnimationUtils.arraySlice(this.values, 0);
        const TypedKeyframeTrack = this.constructor;
        const track = new TypedKeyframeTrack(this.name, times, values);
        track.createInterpolant = this.createInterpolant;
        return track;
      }
    };
    KeyframeTrack.prototype.TimeBufferType = Float32Array;
    KeyframeTrack.prototype.ValueBufferType = Float32Array;
    KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
    BooleanKeyframeTrack = class extends KeyframeTrack {
    };
    BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
    BooleanKeyframeTrack.prototype.ValueBufferType = Array;
    BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
    BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
    BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    ColorKeyframeTrack = class extends KeyframeTrack {
    };
    ColorKeyframeTrack.prototype.ValueTypeName = "color";
    NumberKeyframeTrack = class extends KeyframeTrack {
    };
    NumberKeyframeTrack.prototype.ValueTypeName = "number";
    QuaternionLinearInterpolant = class extends Interpolant {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      }
      interpolate_(i1, t0, t22, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t22 - t0) / (t1 - t0);
        let offset = i1 * stride;
        for (let end = offset + stride; offset !== end; offset += 4) {
          Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        }
        return result;
      }
    };
    QuaternionKeyframeTrack = class extends KeyframeTrack {
      InterpolantFactoryMethodLinear(result) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
      }
    };
    QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
    QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
    QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    StringKeyframeTrack = class extends KeyframeTrack {
    };
    StringKeyframeTrack.prototype.ValueTypeName = "string";
    StringKeyframeTrack.prototype.ValueBufferType = Array;
    StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
    StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
    StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    VectorKeyframeTrack = class extends KeyframeTrack {
    };
    VectorKeyframeTrack.prototype.ValueTypeName = "vector";
    Cache = {
      enabled: false,
      files: {},
      add: function(key2, file) {
        if (this.enabled === false)
          return;
        this.files[key2] = file;
      },
      get: function(key2) {
        if (this.enabled === false)
          return;
        return this.files[key2];
      },
      remove: function(key2) {
        delete this.files[key2];
      },
      clear: function() {
        this.files = {};
      }
    };
    LoadingManager = class {
      constructor(onLoad, onProgress, onError) {
        const scope = this;
        let isLoading = false;
        let itemsLoaded = 0;
        let itemsTotal = 0;
        let urlModifier = void 0;
        const handlers = [];
        this.onStart = void 0;
        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;
        this.itemStart = function(url) {
          itemsTotal++;
          if (isLoading === false) {
            if (scope.onStart !== void 0) {
              scope.onStart(url, itemsLoaded, itemsTotal);
            }
          }
          isLoading = true;
        };
        this.itemEnd = function(url) {
          itemsLoaded++;
          if (scope.onProgress !== void 0) {
            scope.onProgress(url, itemsLoaded, itemsTotal);
          }
          if (itemsLoaded === itemsTotal) {
            isLoading = false;
            if (scope.onLoad !== void 0) {
              scope.onLoad();
            }
          }
        };
        this.itemError = function(url) {
          if (scope.onError !== void 0) {
            scope.onError(url);
          }
        };
        this.resolveURL = function(url) {
          if (urlModifier) {
            return urlModifier(url);
          }
          return url;
        };
        this.setURLModifier = function(transform) {
          urlModifier = transform;
          return this;
        };
        this.addHandler = function(regex, loader2) {
          handlers.push(regex, loader2);
          return this;
        };
        this.removeHandler = function(regex) {
          const index7 = handlers.indexOf(regex);
          if (index7 !== -1) {
            handlers.splice(index7, 2);
          }
          return this;
        };
        this.getHandler = function(file) {
          for (let i22 = 0, l2 = handlers.length; i22 < l2; i22 += 2) {
            const regex = handlers[i22];
            const loader2 = handlers[i22 + 1];
            if (regex.global)
              regex.lastIndex = 0;
            if (regex.test(file)) {
              return loader2;
            }
          }
          return null;
        };
      }
    };
    DefaultLoadingManager = new LoadingManager();
    Loader = class {
      constructor(manager) {
        this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
        this.crossOrigin = "anonymous";
        this.withCredentials = false;
        this.path = "";
        this.resourcePath = "";
        this.requestHeader = {};
      }
      load() {
      }
      loadAsync(url, onProgress) {
        const scope = this;
        return new Promise(function(resolve2, reject) {
          scope.load(url, resolve2, onProgress, reject);
        });
      }
      parse() {
      }
      setCrossOrigin(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
      }
      setWithCredentials(value) {
        this.withCredentials = value;
        return this;
      }
      setPath(path) {
        this.path = path;
        return this;
      }
      setResourcePath(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
      }
      setRequestHeader(requestHeader) {
        this.requestHeader = requestHeader;
        return this;
      }
    };
    loading = {};
    FileLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        if (url === void 0)
          url = "";
        if (this.path !== void 0)
          url = this.path + url;
        url = this.manager.resolveURL(url);
        const cached = Cache.get(url);
        if (cached !== void 0) {
          this.manager.itemStart(url);
          setTimeout(() => {
            if (onLoad)
              onLoad(cached);
            this.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        if (loading[url] !== void 0) {
          loading[url].push({
            onLoad,
            onProgress,
            onError
          });
          return;
        }
        loading[url] = [];
        loading[url].push({
          onLoad,
          onProgress,
          onError
        });
        const req = new Request(url, {
          headers: new Headers(this.requestHeader),
          credentials: this.withCredentials ? "include" : "same-origin"
        });
        const mimeType = this.mimeType;
        const responseType = this.responseType;
        fetch(req).then((response) => {
          if (response.status === 200 || response.status === 0) {
            if (response.status === 0) {
              console.warn("THREE.FileLoader: HTTP Status 0 received.");
            }
            if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
              return response;
            }
            const callbacks = loading[url];
            const reader = response.body.getReader();
            const contentLength = response.headers.get("Content-Length");
            const total = contentLength ? parseInt(contentLength) : 0;
            const lengthComputable = total !== 0;
            let loaded = 0;
            const stream = new ReadableStream({
              start(controller) {
                readData();
                function readData() {
                  reader.read().then(({ done, value }) => {
                    if (done) {
                      controller.close();
                    } else {
                      loaded += value.byteLength;
                      const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                      for (let i22 = 0, il = callbacks.length; i22 < il; i22++) {
                        const callback = callbacks[i22];
                        if (callback.onProgress)
                          callback.onProgress(event);
                      }
                      controller.enqueue(value);
                      readData();
                    }
                  });
                }
              }
            });
            return new Response(stream);
          } else {
            throw Error(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`);
          }
        }).then((response) => {
          switch (responseType) {
            case "arraybuffer":
              return response.arrayBuffer();
            case "blob":
              return response.blob();
            case "document":
              return response.text().then((text) => {
                const parser = new DOMParser();
                return parser.parseFromString(text, mimeType);
              });
            case "json":
              return response.json();
            default:
              if (mimeType === void 0) {
                return response.text();
              } else {
                const re2 = /charset="?([^;"\s]*)"?/i;
                const exec2 = re2.exec(mimeType);
                const label = exec2 && exec2[1] ? exec2[1].toLowerCase() : void 0;
                const decoder = new TextDecoder(label);
                return response.arrayBuffer().then((ab) => decoder.decode(ab));
              }
          }
        }).then((data) => {
          Cache.add(url, data);
          const callbacks = loading[url];
          delete loading[url];
          for (let i22 = 0, il = callbacks.length; i22 < il; i22++) {
            const callback = callbacks[i22];
            if (callback.onLoad)
              callback.onLoad(data);
          }
        }).catch((err) => {
          const callbacks = loading[url];
          if (callbacks === void 0) {
            this.manager.itemError(url);
            throw err;
          }
          delete loading[url];
          for (let i22 = 0, il = callbacks.length; i22 < il; i22++) {
            const callback = callbacks[i22];
            if (callback.onError)
              callback.onError(err);
          }
          this.manager.itemError(url);
        }).finally(() => {
          this.manager.itemEnd(url);
        });
        this.manager.itemStart(url);
      }
      setResponseType(value) {
        this.responseType = value;
        return this;
      }
      setMimeType(value) {
        this.mimeType = value;
        return this;
      }
    };
    ImageLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        if (this.path !== void 0)
          url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== void 0) {
          scope.manager.itemStart(url);
          setTimeout(function() {
            if (onLoad)
              onLoad(cached);
            scope.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        const image = createElementNS("img");
        function onImageLoad() {
          removeEventListeners();
          Cache.add(url, this);
          if (onLoad)
            onLoad(this);
          scope.manager.itemEnd(url);
        }
        function onImageError(event) {
          removeEventListeners();
          if (onError)
            onError(event);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
        function removeEventListeners() {
          image.removeEventListener("load", onImageLoad, false);
          image.removeEventListener("error", onImageError, false);
        }
        image.addEventListener("load", onImageLoad, false);
        image.addEventListener("error", onImageError, false);
        if (url.slice(0, 5) !== "data:") {
          if (this.crossOrigin !== void 0)
            image.crossOrigin = this.crossOrigin;
        }
        scope.manager.itemStart(url);
        image.src = url;
        return image;
      }
    };
    TextureLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const texture = new Texture();
        const loader2 = new ImageLoader(this.manager);
        loader2.setCrossOrigin(this.crossOrigin);
        loader2.setPath(this.path);
        loader2.load(url, function(image) {
          texture.image = image;
          texture.needsUpdate = true;
          if (onLoad !== void 0) {
            onLoad(texture);
          }
        }, onProgress, onError);
        return texture;
      }
    };
    Light = class extends Object3D {
      constructor(color, intensity = 1) {
        super();
        this.isLight = true;
        this.type = "Light";
        this.color = new Color(color);
        this.intensity = intensity;
      }
      dispose() {
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== void 0)
          data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== void 0)
          data.object.distance = this.distance;
        if (this.angle !== void 0)
          data.object.angle = this.angle;
        if (this.decay !== void 0)
          data.object.decay = this.decay;
        if (this.penumbra !== void 0)
          data.object.penumbra = this.penumbra;
        if (this.shadow !== void 0)
          data.object.shadow = this.shadow.toJSON();
        return data;
      }
    };
    _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
    _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
    _lookTarget$1 = /* @__PURE__ */ new Vector3();
    LightShadow = class {
      constructor(camera) {
        this.camera = camera;
        this.bias = 0;
        this.normalBias = 0;
        this.radius = 1;
        this.blurSamples = 8;
        this.mapSize = new Vector2(512, 512);
        this.map = null;
        this.mapPass = null;
        this.matrix = new Matrix4();
        this.autoUpdate = true;
        this.needsUpdate = false;
        this._frustum = new Frustum();
        this._frameExtents = new Vector2(1, 1);
        this._viewportCount = 1;
        this._viewports = [
          new Vector4(0, 0, 1, 1)
        ];
      }
      getViewportCount() {
        return this._viewportCount;
      }
      getFrustum() {
        return this._frustum;
      }
      updateMatrices(light) {
        const shadowCamera = this.camera;
        const shadowMatrix = this.matrix;
        _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy(_lightPositionWorld$1);
        _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(_lookTarget$1);
        shadowCamera.updateMatrixWorld();
        _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
        shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
      }
      getViewport(viewportIndex) {
        return this._viewports[viewportIndex];
      }
      getFrameExtents() {
        return this._frameExtents;
      }
      dispose() {
        if (this.map) {
          this.map.dispose();
        }
        if (this.mapPass) {
          this.mapPass.dispose();
        }
      }
      copy(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const object = {};
        if (this.bias !== 0)
          object.bias = this.bias;
        if (this.normalBias !== 0)
          object.normalBias = this.normalBias;
        if (this.radius !== 1)
          object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
          object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
      }
    };
    SpotLightShadow = class extends LightShadow {
      constructor() {
        super(new PerspectiveCamera$1(50, 1, 0.5, 500));
        this.isSpotLightShadow = true;
        this.focus = 1;
      }
      updateMatrices(light) {
        const camera = this.camera;
        const fov = RAD2DEG * 2 * light.angle * this.focus;
        const aspect = this.mapSize.width / this.mapSize.height;
        const far = light.distance || camera.far;
        if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
          camera.fov = fov;
          camera.aspect = aspect;
          camera.far = far;
          camera.updateProjectionMatrix();
        }
        super.updateMatrices(light);
      }
      copy(source) {
        super.copy(source);
        this.focus = source.focus;
        return this;
      }
    };
    SpotLight$1 = class extends Light {
      constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
        super(color, intensity);
        this.isSpotLight = true;
        this.type = "SpotLight";
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        this.distance = distance;
        this.angle = angle;
        this.penumbra = penumbra;
        this.decay = decay;
        this.shadow = new SpotLightShadow();
      }
      get power() {
        return this.intensity * Math.PI;
      }
      set power(power) {
        this.intensity = power / Math.PI;
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
      }
    };
    AmbientLight$1 = class extends Light {
      constructor(color, intensity) {
        super(color, intensity);
        this.isAmbientLight = true;
        this.type = "AmbientLight";
      }
    };
    InstancedBufferGeometry = class extends BufferGeometry {
      constructor() {
        super();
        this.isInstancedBufferGeometry = true;
        this.type = "InstancedBufferGeometry";
        this.instanceCount = Infinity;
      }
      copy(source) {
        super.copy(source);
        this.instanceCount = source.instanceCount;
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const data = super.toJSON(this);
        data.instanceCount = this.instanceCount;
        data.isInstancedBufferGeometry = true;
        return data;
      }
    };
    Clock = class {
      constructor(autoStart = true) {
        this.autoStart = autoStart;
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
        this.running = false;
      }
      start() {
        this.startTime = now2();
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
      }
      stop() {
        this.getElapsedTime();
        this.running = false;
        this.autoStart = false;
      }
      getElapsedTime() {
        this.getDelta();
        return this.elapsedTime;
      }
      getDelta() {
        let diff = 0;
        if (this.autoStart && !this.running) {
          this.start();
          return 0;
        }
        if (this.running) {
          const newTime = now2();
          diff = (newTime - this.oldTime) / 1e3;
          this.oldTime = newTime;
          this.elapsedTime += diff;
        }
        return diff;
      }
    };
    _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
    _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
    _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
    _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
    _directoryRe = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
    _nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
    _objectRe = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
    _propertyRe = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
    _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
    _supportedObjectNames = ["material", "materials", "bones"];
    Composite = class {
      constructor(targetGroup, path, optionalParsedPath) {
        const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
        this._targetGroup = targetGroup;
        this._bindings = targetGroup.subscribe_(path, parsedPath);
      }
      getValue(array2, offset) {
        this.bind();
        const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
        if (binding !== void 0)
          binding.getValue(array2, offset);
      }
      setValue(array2, offset) {
        const bindings = this._bindings;
        for (let i22 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i22 !== n2; ++i22) {
          bindings[i22].setValue(array2, offset);
        }
      }
      bind() {
        const bindings = this._bindings;
        for (let i22 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i22 !== n2; ++i22) {
          bindings[i22].bind();
        }
      }
      unbind() {
        const bindings = this._bindings;
        for (let i22 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i22 !== n2; ++i22) {
          bindings[i22].unbind();
        }
      }
    };
    PropertyBinding = class {
      constructor(rootNode, path, parsedPath) {
        this.path = path;
        this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
        this.rootNode = rootNode;
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
      }
      static create(root, path, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) {
          return new PropertyBinding(root, path, parsedPath);
        } else {
          return new PropertyBinding.Composite(root, path, parsedPath);
        }
      }
      static sanitizeNodeName(name) {
        return name.replace(/\s/g, "_").replace(_reservedRe, "");
      }
      static parseTrackName(trackName) {
        const matches = _trackRe.exec(trackName);
        if (matches === null) {
          throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
        }
        const results = {
          nodeName: matches[2],
          objectName: matches[3],
          objectIndex: matches[4],
          propertyName: matches[5],
          propertyIndex: matches[6]
        };
        const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
        if (lastDot !== void 0 && lastDot !== -1) {
          const objectName = results.nodeName.substring(lastDot + 1);
          if (_supportedObjectNames.indexOf(objectName) !== -1) {
            results.nodeName = results.nodeName.substring(0, lastDot);
            results.objectName = objectName;
          }
        }
        if (results.propertyName === null || results.propertyName.length === 0) {
          throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
        }
        return results;
      }
      static findNode(root, nodeName) {
        if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
          return root;
        }
        if (root.skeleton) {
          const bone = root.skeleton.getBoneByName(nodeName);
          if (bone !== void 0) {
            return bone;
          }
        }
        if (root.children) {
          const searchNodeSubtree = function(children) {
            for (let i22 = 0; i22 < children.length; i22++) {
              const childNode = children[i22];
              if (childNode.name === nodeName || childNode.uuid === nodeName) {
                return childNode;
              }
              const result = searchNodeSubtree(childNode.children);
              if (result)
                return result;
            }
            return null;
          };
          const subTreeNode = searchNodeSubtree(root.children);
          if (subTreeNode) {
            return subTreeNode;
          }
        }
        return null;
      }
      _getValue_unavailable() {
      }
      _setValue_unavailable() {
      }
      _getValue_direct(buffer, offset) {
        buffer[offset] = this.targetObject[this.propertyName];
      }
      _getValue_array(buffer, offset) {
        const source = this.resolvedProperty;
        for (let i22 = 0, n2 = source.length; i22 !== n2; ++i22) {
          buffer[offset++] = source[i22];
        }
      }
      _getValue_arrayElement(buffer, offset) {
        buffer[offset] = this.resolvedProperty[this.propertyIndex];
      }
      _getValue_toArray(buffer, offset) {
        this.resolvedProperty.toArray(buffer, offset);
      }
      _setValue_direct(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
      }
      _setValue_direct_setNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.needsUpdate = true;
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_array(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i22 = 0, n2 = dest.length; i22 !== n2; ++i22) {
          dest[i22] = buffer[offset++];
        }
      }
      _setValue_array_setNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i22 = 0, n2 = dest.length; i22 !== n2; ++i22) {
          dest[i22] = buffer[offset++];
        }
        this.targetObject.needsUpdate = true;
      }
      _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i22 = 0, n2 = dest.length; i22 !== n2; ++i22) {
          dest[i22] = buffer[offset++];
        }
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_arrayElement(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
      }
      _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.needsUpdate = true;
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_fromArray(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
      }
      _setValue_fromArray_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.needsUpdate = true;
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _getValue_unbound(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
      }
      _setValue_unbound(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
      }
      bind() {
        let targetObject = this.node;
        const parsedPath = this.parsedPath;
        const objectName = parsedPath.objectName;
        const propertyName = parsedPath.propertyName;
        let propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
          targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
          this.node = targetObject;
        }
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        if (!targetObject) {
          console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
          return;
        }
        if (objectName) {
          let objectIndex = parsedPath.objectIndex;
          switch (objectName) {
            case "materials":
              if (!targetObject.material) {
                console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                return;
              }
              if (!targetObject.material.materials) {
                console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                return;
              }
              targetObject = targetObject.material.materials;
              break;
            case "bones":
              if (!targetObject.skeleton) {
                console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                return;
              }
              targetObject = targetObject.skeleton.bones;
              for (let i22 = 0; i22 < targetObject.length; i22++) {
                if (targetObject[i22].name === objectIndex) {
                  objectIndex = i22;
                  break;
                }
              }
              break;
            default:
              if (targetObject[objectName] === void 0) {
                console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                return;
              }
              targetObject = targetObject[objectName];
          }
          if (objectIndex !== void 0) {
            if (targetObject[objectIndex] === void 0) {
              console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
              return;
            }
            targetObject = targetObject[objectIndex];
          }
        }
        const nodeProperty = targetObject[propertyName];
        if (nodeProperty === void 0) {
          const nodeName = parsedPath.nodeName;
          console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
          return;
        }
        let versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.needsUpdate !== void 0) {
          versioning = this.Versioning.NeedsUpdate;
        } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
          versioning = this.Versioning.MatrixWorldNeedsUpdate;
        }
        let bindingType = this.BindingType.Direct;
        if (propertyIndex !== void 0) {
          if (propertyName === "morphTargetInfluences") {
            if (!targetObject.geometry) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              return;
            }
            if (!targetObject.geometry.morphAttributes) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
              return;
            }
            if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
              propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
            }
          }
          bindingType = this.BindingType.ArrayElement;
          this.resolvedProperty = nodeProperty;
          this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
          bindingType = this.BindingType.HasFromToArray;
          this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
          bindingType = this.BindingType.EntireArray;
          this.resolvedProperty = nodeProperty;
        } else {
          this.propertyName = propertyName;
        }
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
      }
      unbind() {
        this.node = null;
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
      }
    };
    PropertyBinding.Composite = Composite;
    PropertyBinding.prototype.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    };
    PropertyBinding.prototype.Versioning = {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2
    };
    PropertyBinding.prototype.GetterByBindingType = [
      PropertyBinding.prototype._getValue_direct,
      PropertyBinding.prototype._getValue_array,
      PropertyBinding.prototype._getValue_arrayElement,
      PropertyBinding.prototype._getValue_toArray
    ];
    PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
      [
        PropertyBinding.prototype._setValue_direct,
        PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
        PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
      ],
      [
        PropertyBinding.prototype._setValue_array,
        PropertyBinding.prototype._setValue_array_setNeedsUpdate,
        PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
      ],
      [
        PropertyBinding.prototype._setValue_arrayElement,
        PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
        PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
      ],
      [
        PropertyBinding.prototype._setValue_fromArray,
        PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
        PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
      ]
    ];
    InstancedInterleavedBuffer = class extends InterleavedBuffer {
      constructor(array2, stride, meshPerAttribute = 1) {
        super(array2, stride);
        this.isInstancedInterleavedBuffer = true;
        this.meshPerAttribute = meshPerAttribute;
      }
      copy(source) {
        super.copy(source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
      }
      clone(data) {
        const ib = super.clone(data);
        ib.meshPerAttribute = this.meshPerAttribute;
        return ib;
      }
      toJSON(data) {
        const json = super.toJSON(data);
        json.isInstancedInterleavedBuffer = true;
        json.meshPerAttribute = this.meshPerAttribute;
        return json;
      }
    };
    Raycaster = class {
      constructor(origin, direction, near = 0, far = Infinity) {
        this.ray = new Ray(origin, direction);
        this.near = near;
        this.far = far;
        this.camera = null;
        this.layers = new Layers();
        this.params = {
          Mesh: {},
          Line: { threshold: 1 },
          LOD: {},
          Points: { threshold: 1 },
          Sprite: {}
        };
      }
      set(origin, direction) {
        this.ray.set(origin, direction);
      }
      setFromCamera(coords, camera) {
        if (camera.isPerspectiveCamera) {
          this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
          this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
          this.camera = camera;
        } else if (camera.isOrthographicCamera) {
          this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
          this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
          this.camera = camera;
        } else {
          console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
        }
      }
      intersectObject(object, recursive = true, intersects = []) {
        intersectObject(object, this, intersects, recursive);
        intersects.sort(ascSort);
        return intersects;
      }
      intersectObjects(objects, recursive = true, intersects = []) {
        for (let i22 = 0, l2 = objects.length; i22 < l2; i22++) {
          intersectObject(objects[i22], this, intersects, recursive);
        }
        intersects.sort(ascSort);
        return intersects;
      }
    };
    Spherical = class {
      constructor(radius = 1, phi = 0, theta = 0) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
      }
      set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
      }
      copy(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
      }
      makeSafe() {
        const EPS = 1e-6;
        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
        return this;
      }
      setFromVector3(v2) {
        return this.setFromCartesianCoords(v2.x, v2.y, v2.z);
      }
      setFromCartesianCoords(x22, y2, z2) {
        this.radius = Math.sqrt(x22 * x22 + y2 * y2 + z2 * z2);
        if (this.radius === 0) {
          this.theta = 0;
          this.phi = 0;
        } else {
          this.theta = Math.atan2(x22, z2);
          this.phi = Math.acos(clamp(y2 / this.radius, -1, 1));
        }
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    _startP = /* @__PURE__ */ new Vector3();
    _startEnd = /* @__PURE__ */ new Vector3();
    Line3 = class {
      constructor(start = new Vector3(), end = new Vector3()) {
        this.start = start;
        this.end = end;
      }
      set(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
      }
      copy(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
      }
      getCenter(target) {
        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
      }
      delta(target) {
        return target.subVectors(this.end, this.start);
      }
      distanceSq() {
        return this.start.distanceToSquared(this.end);
      }
      distance() {
        return this.start.distanceTo(this.end);
      }
      at(t22, target) {
        return this.delta(target).multiplyScalar(t22).add(this.start);
      }
      closestPointToPointParameter(point, clampToLine) {
        _startP.subVectors(point, this.start);
        _startEnd.subVectors(this.end, this.start);
        const startEnd2 = _startEnd.dot(_startEnd);
        const startEnd_startP = _startEnd.dot(_startP);
        let t22 = startEnd_startP / startEnd2;
        if (clampToLine) {
          t22 = clamp(t22, 0, 1);
        }
        return t22;
      }
      closestPointToPoint(point, clampToLine, target) {
        const t22 = this.closestPointToPointParameter(point, clampToLine);
        return this.delta(target).multiplyScalar(t22).add(this.start);
      }
      applyMatrix4(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
      }
      equals(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
        revision: REVISION
      } }));
    }
    if (typeof window !== "undefined") {
      if (window.__THREE__) {
        console.warn("WARNING: Multiple instances of Three.js being imported.");
      } else {
        window.__THREE__ = REVISION;
      }
    }
    Pass = class {
      constructor() {
        this.enabled = true;
        this.needsSwap = true;
        this.clear = false;
        this.renderToScreen = false;
      }
      setSize() {
      }
      render() {
        console.error("THREE.Pass: .render() must be implemented in derived pass.");
      }
    };
    new OrthographicCamera(-1, 1, 1, -1, 0, 1);
    _geometry$1 = new BufferGeometry();
    _geometry$1.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    _geometry$1.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
    new OrthographicCamera(-1, 1, 1, -1, 0, 1);
    _geometry = new BufferGeometry();
    _geometry.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    _geometry.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
    RenderPass = class extends Pass {
      constructor(scene, camera, overrideMaterial, clearColor, clearAlpha) {
        super();
        this.scene = scene;
        this.camera = camera;
        this.overrideMaterial = overrideMaterial;
        this.clearColor = clearColor;
        this.clearAlpha = clearAlpha !== void 0 ? clearAlpha : 0;
        this.clear = true;
        this.clearDepth = false;
        this.needsSwap = false;
        this._oldClearColor = new Color();
      }
      render(renderer, writeBuffer, readBuffer) {
        const oldAutoClear = renderer.autoClear;
        renderer.autoClear = false;
        let oldClearAlpha, oldOverrideMaterial;
        if (this.overrideMaterial !== void 0) {
          oldOverrideMaterial = this.scene.overrideMaterial;
          this.scene.overrideMaterial = this.overrideMaterial;
        }
        if (this.clearColor) {
          renderer.getClearColor(this._oldClearColor);
          oldClearAlpha = renderer.getClearAlpha();
          renderer.setClearColor(this.clearColor, this.clearAlpha);
        }
        if (this.clearDepth) {
          renderer.clearDepth();
        }
        renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
        if (this.clear)
          renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        renderer.render(this.scene, this.camera);
        if (this.clearColor) {
          renderer.setClearColor(this._oldClearColor, oldClearAlpha);
        }
        if (this.overrideMaterial !== void 0) {
          this.scene.overrideMaterial = oldOverrideMaterial;
        }
        renderer.autoClear = oldAutoClear;
      }
    };
    setRendererColorOutput = (ctx, linear, flat) => {
      if (!ctx.renderer)
        return;
      if (linear) {
        ctx.renderer.outputEncoding = LinearEncoding;
      } else {
        ctx.renderer.outputEncoding = sRGBEncoding;
      }
      if (flat) {
        ctx.renderer.toneMapping = NoToneMapping;
      } else {
        ctx.renderer.toneMapping = ACESFilmicToneMapping;
      }
    };
    setRendererAndComposerSize = (ctx, size, dpr) => {
      if (!ctx.renderer || !ctx.composer)
        return;
      ctx.renderer.setSize(size.width, size.height);
      ctx.renderer.setPixelRatio(dpr);
      ctx.composer.setSize(size.width, size.height);
      ctx.composer.setPixelRatio(dpr);
    };
    setRendererShadows = (ctx, shadows, shadowMapType) => {
      if (!ctx.renderer)
        return;
      ctx.renderer.shadowMap.enabled = shadows;
      ctx.renderer.shadowMap.type = shadowMapType;
    };
    getThrelteUserData = (object) => {
      return object.userData;
    };
    setPointerFromEvent = (ctx, e22) => {
      ctx.pointer.update((v2) => {
        if (!ctx.renderer)
          return v2;
        return v2.set(e22.offsetX / ctx.renderer.domElement.clientWidth * 2 - 1, -(e22.offsetY / ctx.renderer.domElement.clientHeight) * 2 + 1);
      });
    };
    runRaycaster = (rootCtx, pointer, camera, objects) => {
      rootCtx.raycaster.setFromCamera(pointer, camera);
      return rootCtx.raycaster.intersectObjects(objects, false);
    };
    targetChanged = (a2, b2) => {
      if (a2.object.uuid !== b2.object.uuid)
        return true;
      if (a2.instanceId !== b2.instanceId)
        return true;
      return false;
    };
    useEventRaycast = (ctx, rootCtx, renderCtx) => {
      let camera;
      const unsubscribeCamera = ctx.camera.subscribe((value) => camera = value);
      onDestroy(unsubscribeCamera);
      let pointer;
      const unsubscribePointer = ctx.pointer.subscribe((value) => pointer = value);
      onDestroy(unsubscribePointer);
      const onEvent = (e22) => {
        var _a, _b;
        e22.preventDefault();
        ctx.pointerOverCanvas.set(true);
        renderCtx.pointerInvalidated = true;
        setPointerFromEvent(ctx, e22);
        if (rootCtx.interactiveObjects.size === 0 || rootCtx.raycastableObjects.size === 0)
          return;
        const intersects = runRaycaster(rootCtx, pointer, camera, Array.from(rootCtx.raycastableObjects));
        if (intersects.length > 0 && rootCtx.interactiveObjects.has(intersects[0].object)) {
          (_b = (_a = getThrelteUserData(intersects[0].object)).eventDispatcher) == null ? void 0 : _b.call(_a, e22.type, {
            ...intersects[0],
            event: e22
          });
        }
      };
      return {
        onClick: onEvent,
        onContextMenu: onEvent,
        onPointerUp: onEvent,
        onPointerDown: onEvent,
        onPointerMove: onEvent
      };
    };
    useFrameloopRaycast = (ctx, rootCtx) => {
      let pointerOverCanvas = get_store_value(ctx.pointerOverCanvas);
      const unsubscribePointerOverCanvas = ctx.pointerOverCanvas.subscribe((value) => pointerOverCanvas = value);
      onDestroy(unsubscribePointerOverCanvas);
      let camera;
      const unsubscribeCamera = ctx.camera.subscribe((value) => camera = value);
      onDestroy(unsubscribeCamera);
      let pointer;
      const unsubscribePointer = ctx.pointer.subscribe((value) => pointer = value);
      onDestroy(unsubscribePointer);
      const raycast = () => {
        var _a, _b, _c, _d, _e2, _f, _g, _h;
        if (rootCtx.interactiveObjects.size === 0 || rootCtx.raycastableObjects.size === 0) {
          return;
        }
        const intersects = pointerOverCanvas ? runRaycaster(rootCtx, pointer, camera, Array.from(rootCtx.raycastableObjects)) : [];
        const intersection = intersects.length && rootCtx.interactiveObjects.has(intersects[0].object) ? intersects[0] : null;
        if (!intersection) {
          if (rootCtx.lastIntersection) {
            (_b = (_a = getThrelteUserData(rootCtx.lastIntersection.object)).eventDispatcher) == null ? void 0 : _b.call(_a, "pointerleave", rootCtx.lastIntersection);
          }
        } else {
          if (!rootCtx.lastIntersection) {
            (_d = (_c = getThrelteUserData(intersection.object)).eventDispatcher) == null ? void 0 : _d.call(_c, "pointerenter", intersection);
          } else if (rootCtx.lastIntersection && targetChanged(rootCtx.lastIntersection, intersection)) {
            (_f = (_e2 = getThrelteUserData(rootCtx.lastIntersection.object)).eventDispatcher) == null ? void 0 : _f.call(_e2, "pointerleave", rootCtx.lastIntersection);
            (_h = (_g = getThrelteUserData(intersection.object)).eventDispatcher) == null ? void 0 : _h.call(_g, "pointerenter", intersection);
          }
        }
        rootCtx.lastIntersection = intersection;
      };
      return {
        raycast
      };
    };
    browser = typeof window !== "undefined";
    useRaf = (cb) => {
      if (!browser)
        return;
      let handle;
      const tick2 = () => {
        cb();
        handle = requestAnimationFrame(tick2);
      };
      tick2();
      onDestroy(() => {
        if (!handle)
          return;
        cancelAnimationFrame(handle);
      });
    };
    runFrameloopCallbacks = (ctx, renderCtx) => {
      if (renderCtx.frameHandlers.size === 0)
        return;
      if (renderCtx.debugFrameloop) {
        let genericFrameHandlers = 0;
        renderCtx.frameHandlers.forEach((h22) => {
          if (h22.debugFrameloopMessage) {
            renderCtx.invalidations[h22.debugFrameloopMessage] = h22.debugFrameloopMessage in renderCtx.invalidations ? renderCtx.invalidations[h22.debugFrameloopMessage] + 1 : 1;
          } else {
            ++genericFrameHandlers;
          }
        });
        if (genericFrameHandlers > 0)
          renderCtx.invalidations["onFrame"] = renderCtx.frameHandlers.size;
      }
      const anyHasOrder = Array.from(renderCtx.frameHandlers).reduce((acc, h22) => h22.order ? true : acc, false);
      const delta = ctx.clock.getDelta();
      if (anyHasOrder) {
        Array.from(renderCtx.frameHandlers).sort((a2, b2) => (a2.order ?? 0) > (b2.order ?? 0) ? 1 : -1).forEach((h22) => h22.fn(ctx, delta));
      } else {
        renderCtx.frameHandlers.forEach((h22) => h22.fn(ctx, delta));
      }
    };
    debugFrame = (renderCtx) => {
      if (!renderCtx.debugFrameloop)
        return;
      renderCtx.frame += 1;
      console.log(`frame: ${renderCtx.frame}${Object.keys(renderCtx.invalidations).length > 0 ? ", requested by \u21B4" : ""}`);
      if (Object.keys(renderCtx.invalidations).length > 0)
        console.table(renderCtx.invalidations);
      renderCtx.invalidations = {};
    };
    useFrameloop = (ctx, rootCtx, renderCtx) => {
      let camera = get_store_value(ctx.camera);
      const unsubscribeCamera = ctx.camera.subscribe((c2) => camera = c2);
      onDestroy(unsubscribeCamera);
      const { raycast } = useFrameloopRaycast(ctx, rootCtx);
      useRaf(() => {
        const shouldRender = renderCtx.frameloop === "always" || renderCtx.frameloop === "demand" && (renderCtx.frameInvalidated || renderCtx.frameHandlers.size > 0) || renderCtx.frameloop === "never" && renderCtx.advance;
        const shouldRaycast = shouldRender || renderCtx.pointerInvalidated;
        if (shouldRaycast) {
          raycast();
          renderCtx.pointerInvalidated = false;
        }
        if (!shouldRender)
          return;
        if (!camera || !ctx.composer || !ctx.renderer)
          return;
        runFrameloopCallbacks(ctx, renderCtx);
        if (ctx.composer.passes.length > 1) {
          ctx.composer.render();
        } else {
          ctx.renderer.render(ctx.scene, camera);
        }
        debugFrame(renderCtx);
        renderCtx.frameInvalidated = false;
        renderCtx.advance = false;
      });
    };
    getDefaultCamera = () => {
      const defaultCamera = new PerspectiveCamera$1(75, 0, 0.1, 1e3);
      getThrelteUserData(defaultCamera).threlteDefaultCamera = true;
      defaultCamera.position.z = 5;
      defaultCamera.lookAt(0, 0, 0);
      return defaultCamera;
    };
    setDefaultCameraAspectOnSizeChange = (ctx) => {
      const unsubscribe = ctx.size.subscribe((size) => {
        if (getThrelteUserData(get_store_value(ctx.camera)).threlteDefaultCamera) {
          ctx.camera.update((c2) => {
            const cam = c2;
            cam.aspect = size.width / size.height;
            cam.updateProjectionMatrix();
            ctx.invalidate("Default camera: aspect ratio changed");
            return cam;
          });
        }
      });
      onDestroy(unsubscribe);
    };
    createContexts = (linear, flat, dpr, userSize, parentSize, debugFrameloop, frameloop) => {
      const audioCtx = {
        audioListeners: /* @__PURE__ */ new Map(),
        addAudioListener: (listener, id) => {
          id = id ?? "default";
          if (audioCtx.audioListeners.has(id)) {
            console.warn(`An AudioListener with the id "${id}" has already been added, aborting.`);
            return;
          }
          audioCtx.audioListeners.set(id, listener);
        },
        removeAudioListener: (id) => {
          id = id ?? "default";
          if (!audioCtx.audioListeners.has(id)) {
            console.warn(`No AudioListener with the id "${id}" found, aborting.`);
            return;
          }
          audioCtx.audioListeners.delete(id);
        },
        getAudioListener: (id) => {
          id = id ?? "default";
          if (!audioCtx.audioListeners.has(id)) {
            console.warn(`No AudioListener with the id "${id}" found, aborting.`);
            return;
          }
          return audioCtx.audioListeners.get(id);
        }
      };
      const renderCtx = {
        debugFrameloop,
        frameloop,
        frame: 0,
        frameInvalidated: true,
        pointerInvalidated: true,
        invalidations: {},
        frameHandlers: /* @__PURE__ */ new Set(),
        advance: false
      };
      const ctx = {
        size: derived([userSize, parentSize], ([uSize, pSize]) => {
          return uSize ? uSize : pSize;
        }),
        pointer: writable2(new Vector2()),
        pointerOverCanvas: writable2(false),
        clock: new Clock(),
        camera: writable2(getDefaultCamera()),
        scene: new Scene(),
        renderer: void 0,
        composer: void 0,
        invalidate: (debugFrameloopMessage) => {
          renderCtx.frameInvalidated = true;
          if (renderCtx.debugFrameloop && debugFrameloopMessage) {
            renderCtx.invalidations[debugFrameloopMessage] = renderCtx.invalidations[debugFrameloopMessage] ? renderCtx.invalidations[debugFrameloopMessage] + 1 : 1;
          }
        },
        advance: () => {
          renderCtx.advance = true;
        }
      };
      const rootCtx = {
        flat: writable2(flat),
        linear: writable2(linear),
        dpr: writable2(dpr),
        setCamera: (camera) => {
          ctx.camera.set(camera);
          if (!ctx.composer)
            return;
          ctx.composer.passes.forEach((pass) => {
            if (pass instanceof RenderPass) {
              pass.camera = camera;
            }
          });
          ctx.invalidate("Canvas: setting camera");
        },
        raycastableObjects: /* @__PURE__ */ new Set(),
        interactiveObjects: /* @__PURE__ */ new Set(),
        raycaster: new Raycaster(),
        lastIntersection: null,
        addRaycastableObject: (object) => {
          rootCtx.raycastableObjects.add(object);
        },
        removeRaycastableObject: (object) => {
          rootCtx.raycastableObjects.delete(object);
        },
        addInteractiveObject: (object) => {
          rootCtx.interactiveObjects.add(object);
        },
        removeInteractiveObject: (object) => {
          rootCtx.interactiveObjects.delete(object);
        },
        addPass: (pass) => {
          if (!ctx.composer)
            return;
          ctx.composer.addPass(pass);
          ctx.invalidate("Canvas: adding pass");
        },
        removePass: (pass) => {
          if (!ctx.composer)
            return;
          ctx.composer.removePass(pass);
          ctx.invalidate("Canvas: removing pass");
        }
      };
      setContext("threlte", ctx);
      setContext("threlte-root", rootCtx);
      setContext("threlte-render-context", renderCtx);
      setContext("threlte-audio-context", audioCtx);
      const getCtx = () => ctx;
      const getRootCtx = () => rootCtx;
      const getRenderCtx = () => renderCtx;
      const getAudioCtx = () => audioCtx;
      return {
        ctx,
        rootCtx,
        renderCtx,
        audioCtx,
        getCtx,
        getRootCtx,
        getRenderCtx,
        getAudioCtx
      };
    };
    useParentSize = () => {
      const parentSizeStore = writable2({ width: 0, height: 0 });
      let parentSize = { width: 0, height: 0 };
      const unsubscribeParentSize = parentSizeStore.subscribe((s22) => parentSize = s22);
      onDestroy(unsubscribeParentSize);
      let el;
      const proxy = () => {
        const currentParentSize = parentSize;
        if (!el)
          return;
        if (!el.parentElement)
          return;
        const { clientWidth, clientHeight } = el.parentElement;
        if (clientWidth !== currentParentSize.width || clientHeight !== currentParentSize.height) {
          parentSizeStore.set({
            width: clientWidth,
            height: clientHeight
          });
        }
      };
      const parentSizeAction = (node) => {
        el = node;
        proxy();
        window.addEventListener("resize", proxy);
      };
      if (!browser) {
        return {
          parentSize: parentSizeStore,
          parentSizeAction
        };
      }
      onDestroy(() => {
        window.removeEventListener("resize", proxy);
      });
      return {
        parentSizeAction,
        parentSize: parentSizeStore
      };
    };
    css3 = {
      code: "canvas.svelte-15bl8wt{display:block}",
      map: null
    };
    invalidationHandlers = /* @__PURE__ */ new Set();
    invalidateGlobally = (debugFrameloopMessage) => {
      invalidationHandlers.forEach((fn2) => fn2(debugFrameloopMessage));
    };
    Canvas = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $dprStore, $$unsubscribe_dprStore;
      let $derivedSize, $$unsubscribe_derivedSize;
      let $flatStore, $$unsubscribe_flatStore;
      let $linearStore, $$unsubscribe_linearStore;
      let { dpr = browser ? window.devicePixelRatio : 1 } = $$props;
      let { flat = false } = $$props;
      let { linear = false } = $$props;
      let { frameloop = "demand" } = $$props;
      let { debugFrameloop = false } = $$props;
      let { shadows = true } = $$props;
      let { shadowMapType = PCFSoftShadowMap } = $$props;
      let { size = void 0 } = $$props;
      let { rendererParameters = void 0 } = $$props;
      let canvas;
      const userSize = writable2(size);
      const { parentSize, parentSizeAction } = useParentSize();
      const contexts = createContexts(linear, flat, dpr, userSize, parentSize, debugFrameloop, frameloop);
      const { getCtx, getRootCtx, getRenderCtx, renderCtx } = contexts;
      const { ctx, rootCtx, audioCtx } = contexts;
      setDefaultCameraAspectOnSizeChange(ctx);
      invalidationHandlers.add(ctx.invalidate);
      onDestroy(() => {
        invalidationHandlers.delete(ctx.invalidate);
      });
      const { size: derivedSize, scene } = ctx;
      $$unsubscribe_derivedSize = subscribe(derivedSize, (value) => $derivedSize = value);
      const { flat: flatStore, linear: linearStore, dpr: dprStore } = rootCtx;
      $$unsubscribe_flatStore = subscribe(flatStore, (value) => $flatStore = value);
      $$unsubscribe_linearStore = subscribe(linearStore, (value) => $linearStore = value);
      $$unsubscribe_dprStore = subscribe(dprStore, (value) => $dprStore = value);
      setContext("threlte-parent", writable2(scene));
      useFrameloop(ctx, rootCtx, renderCtx);
      useEventRaycast(ctx, rootCtx, renderCtx);
      if ($$props.dpr === void 0 && $$bindings.dpr && dpr !== void 0)
        $$bindings.dpr(dpr);
      if ($$props.flat === void 0 && $$bindings.flat && flat !== void 0)
        $$bindings.flat(flat);
      if ($$props.linear === void 0 && $$bindings.linear && linear !== void 0)
        $$bindings.linear(linear);
      if ($$props.frameloop === void 0 && $$bindings.frameloop && frameloop !== void 0)
        $$bindings.frameloop(frameloop);
      if ($$props.debugFrameloop === void 0 && $$bindings.debugFrameloop && debugFrameloop !== void 0)
        $$bindings.debugFrameloop(debugFrameloop);
      if ($$props.shadows === void 0 && $$bindings.shadows && shadows !== void 0)
        $$bindings.shadows(shadows);
      if ($$props.shadowMapType === void 0 && $$bindings.shadowMapType && shadowMapType !== void 0)
        $$bindings.shadowMapType(shadowMapType);
      if ($$props.size === void 0 && $$bindings.size && size !== void 0)
        $$bindings.size(size);
      if ($$props.rendererParameters === void 0 && $$bindings.rendererParameters && rendererParameters !== void 0)
        $$bindings.rendererParameters(rendererParameters);
      if ($$props.ctx === void 0 && $$bindings.ctx && ctx !== void 0)
        $$bindings.ctx(ctx);
      if ($$props.rootCtx === void 0 && $$bindings.rootCtx && rootCtx !== void 0)
        $$bindings.rootCtx(rootCtx);
      if ($$props.audioCtx === void 0 && $$bindings.audioCtx && audioCtx !== void 0)
        $$bindings.audioCtx(audioCtx);
      $$result.css.add(css3);
      {
        userSize.set(size);
      }
      set_store_value(linearStore, $linearStore = linear, $linearStore);
      set_store_value(flatStore, $flatStore = flat, $flatStore);
      set_store_value(dprStore, $dprStore = dpr, $dprStore);
      {
        setRendererColorOutput(getCtx(), $linearStore, $flatStore);
      }
      {
        setRendererAndComposerSize(getCtx(), $derivedSize, $dprStore);
      }
      {
        setRendererShadows(getCtx(), shadows, shadowMapType);
      }
      $$unsubscribe_dprStore();
      $$unsubscribe_derivedSize();
      $$unsubscribe_flatStore();
      $$unsubscribe_linearStore();
      return `<canvas class="${"svelte-15bl8wt"}"${add_attribute("this", canvas, 0)}>${``}
</canvas>`;
    });
    useThrelte = () => {
      return getContext("threlte");
    };
    useThrelteRoot = () => {
      return getContext("threlte-root");
    };
    createObjectStore = (object) => {
      const objectStore = writable2(object);
      let unwrappedObject = object;
      const unsubscribeObjectStore = objectStore.subscribe((o2) => unwrappedObject = o2);
      onDestroy(unsubscribeObjectStore);
      const set = (newObject) => {
        if (newObject.uuid === unwrappedObject.uuid)
          return;
        objectStore.set(newObject);
      };
      return {
        ...objectStore,
        set
      };
    };
    setParent = (objectStore) => {
      setContext("threlte-parent", objectStore);
    };
    getParent = () => {
      return getContext("threlte-parent");
    };
    HierarchicalObject = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $currentObject, $$unsubscribe_currentObject;
      let $currentParent, $$unsubscribe_currentParent;
      const currentParent = getParent();
      $$unsubscribe_currentParent = subscribe(currentParent, (value) => $currentParent = value);
      let previousParent = $currentParent;
      let { object } = $$props;
      const currentObject = writable2(object);
      $$unsubscribe_currentObject = subscribe(currentObject, (value) => $currentObject = value);
      let previousObject = object;
      setParent(currentObject);
      const { invalidate } = useThrelte();
      $currentParent.add($currentObject);
      invalidate("HierarchicalObject: object added");
      onDestroy(() => {
        $currentParent.remove($currentObject);
        invalidate("HierarchicalObject: object removed");
      });
      if ($$props.object === void 0 && $$bindings.object && object !== void 0)
        $$bindings.object(object);
      set_store_value(currentObject, $currentObject = object, $currentObject);
      {
        {
          if ($currentObject !== previousObject) {
            if (previousObject) {
              $currentParent.remove(previousObject);
            }
            $currentParent.add($currentObject);
            invalidate(`HierarchicalObject: object changed`);
            previousObject = $currentObject;
          }
        }
      }
      {
        {
          if ($currentParent !== previousParent) {
            previousParent.remove($currentObject);
            $currentParent.add($currentObject);
            invalidate(`HierarchicalObject: parent changed`);
            previousParent = $currentParent;
          }
        }
      }
      $$unsubscribe_currentObject();
      $$unsubscribe_currentParent();
      return `${slots.default ? slots.default({}) : ``}`;
    });
    LayerableObject = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $layers, $$unsubscribe_layers;
      let $objectStore, $$unsubscribe_objectStore;
      let { object } = $$props;
      const objectStore = createObjectStore(object);
      $$unsubscribe_objectStore = subscribe(objectStore, (value) => $objectStore = value);
      const layers = getContext("threlte-layers");
      $$unsubscribe_layers = subscribe(layers, (value) => $layers = value);
      const { invalidate } = useThrelte();
      if ($$props.object === void 0 && $$bindings.object && object !== void 0)
        $$bindings.object(object);
      {
        objectStore.set(object);
      }
      {
        {
          if ($layers === "all") {
            $objectStore.layers.enableAll();
          } else if ($layers === "none") {
            $objectStore.layers.disableAll();
          } else if (Array.isArray($layers)) {
            for (let index7 = 0; index7 < 32; index7 += 1) {
              const layerIndex = index7;
              const enabled = $layers.includes(layerIndex);
              if (enabled) {
                $objectStore.layers.enable(index7);
              } else {
                $objectStore.layers.disable(index7);
              }
            }
          } else if ($layers !== void 0) {
            $objectStore.layers.set($layers);
          }
          invalidate("LayerableObject");
        }
      }
      $$unsubscribe_layers();
      $$unsubscribe_objectStore();
      return ``;
    });
    useFrame = (fn2, options) => {
      if (!browser) {
        return {
          start: () => void 0,
          stop: () => void 0,
          started: readable2(false)
        };
      }
      const renderCtx = getContext("threlte-render-context");
      const handler = {
        fn: fn2,
        order: options == null ? void 0 : options.order,
        debugFrameloopMessage: options == null ? void 0 : options.debugFrameloopMessage
      };
      const started = writable2(false);
      const stop = () => {
        renderCtx.frameHandlers.delete(handler);
        started.set(false);
      };
      const start = () => {
        renderCtx.frameHandlers.add(handler);
        started.set(true);
      };
      if ((options == null ? void 0 : options.autostart) ?? true) {
        start();
      }
      onDestroy(() => {
        stop();
      });
      return {
        start,
        stop,
        started: {
          subscribe: started.subscribe
        }
      };
    };
    useTicked = () => {
      const ticked = writable2(false);
      const init2 = async () => {
        await tick();
        ticked.set(true);
      };
      init2();
      return ticked;
    };
    TransformableObject = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $objectStore, $$unsubscribe_objectStore;
      let $ticked, $$unsubscribe_ticked;
      let { object } = $$props;
      let { position = void 0 } = $$props;
      let { scale = void 0 } = $$props;
      let { rotation = void 0 } = $$props;
      let { lookAt = void 0 } = $$props;
      const targetWorldPos = new Vector3();
      const dispatch = createEventDispatcher();
      const { invalidate } = useThrelte();
      const ticked = useTicked();
      $$unsubscribe_ticked = subscribe(ticked, (value) => $ticked = value);
      const dispatchTransform = async () => {
        if (!$ticked)
          await tick();
        dispatch("transform");
      };
      const onTransform = async () => {
        invalidate("TransformableObject: transformed");
        await dispatchTransform();
      };
      getThrelteUserData(object).onTransform = onTransform;
      const { start: startLookingAt, stop: stopLookingAt } = useFrame(async () => {
        if (lookAt && !rotation && lookAt instanceof Object3D) {
          lookAt.getWorldPosition(targetWorldPos);
          object.lookAt(targetWorldPos);
          await dispatchTransform();
        }
      }, {
        autostart: false,
        debugFrameloopMessage: "TransformableObject: tracking object"
      });
      const objectStore = createObjectStore(object);
      $$unsubscribe_objectStore = subscribe(objectStore, (value) => $objectStore = value);
      if ($$props.object === void 0 && $$bindings.object && object !== void 0)
        $$bindings.object(object);
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.scale === void 0 && $$bindings.scale && scale !== void 0)
        $$bindings.scale(scale);
      if ($$props.rotation === void 0 && $$bindings.rotation && rotation !== void 0)
        $$bindings.rotation(rotation);
      if ($$props.lookAt === void 0 && $$bindings.lookAt && lookAt !== void 0)
        $$bindings.lookAt(lookAt);
      {
        objectStore.set(object);
      }
      {
        {
          if (position) {
            $objectStore.position.set(position.x ?? 0, position.y ?? 0, position.z ?? 0);
            onTransform();
          }
          if (lookAt && !rotation) {
            if (lookAt instanceof Object3D) {
              startLookingAt();
            } else {
              stopLookingAt();
              $objectStore.lookAt(lookAt.x ?? 0, lookAt.y ?? 0, lookAt.z ?? 0);
              onTransform();
            }
          }
          if (!lookAt) {
            stopLookingAt();
          }
        }
      }
      {
        {
          if (scale) {
            if (typeof scale === "number") {
              $objectStore.scale.set(scale, scale, scale);
            } else {
              $objectStore.scale.set(scale.x ?? 1, scale.y ?? 1, scale.z ?? 1);
            }
            onTransform();
          }
        }
      }
      {
        {
          if (rotation) {
            $objectStore.rotation.set(rotation.x ?? 0, rotation.y ?? 0, rotation.z ?? 0, rotation.order ?? "XYZ");
            onTransform();
          }
        }
      }
      $$unsubscribe_objectStore();
      $$unsubscribe_ticked();
      return ``;
    });
    ViewportAwareObject = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $started, $$unsubscribe_started;
      let $ticked, $$unsubscribe_ticked;
      let $camera, $$unsubscribe_camera;
      let { object } = $$props;
      let { viewportAware = false } = $$props;
      const dispatch = createEventDispatcher();
      const { camera, invalidate } = useThrelte();
      $$unsubscribe_camera = subscribe(camera, (value) => $camera = value);
      const frustum = new Frustum();
      const projScreenMatrix = new Matrix4();
      const objectIsMesh = (objOrMesh) => {
        return objOrMesh.type === "Mesh";
      };
      const v3World = new Vector3();
      const checkInViewport = () => {
        if (!$camera)
          return true;
        projScreenMatrix.multiplyMatrices($camera.projectionMatrix, $camera.matrixWorldInverse);
        frustum.setFromProjectionMatrix(projScreenMatrix);
        if (objectIsMesh(object)) {
          return frustum.intersectsObject(object);
        } else {
          object.getWorldPosition(v3World);
          return frustum.containsPoint(v3World);
        }
      };
      const ticked = useTicked();
      $$unsubscribe_ticked = subscribe(ticked, (value) => $ticked = value);
      let { inViewport = checkInViewport() } = $$props;
      const dispatchEvent = async (isInViewport) => {
        if (isInViewport) {
          if (!$ticked)
            await tick();
          dispatch("viewportenter", object);
        } else {
          if (!$ticked)
            await tick();
          dispatch("viewportleave", object);
        }
      };
      const { start, stop, started } = useFrame(() => {
        const v2 = checkInViewport();
        if (inViewport === void 0) {
          inViewport = checkInViewport();
          dispatchEvent(inViewport);
        } else if (v2 !== inViewport) {
          dispatchEvent(v2);
          inViewport = v2;
        }
      }, {
        autostart: viewportAware,
        debugFrameloopMessage: "ViewportAwareObject: tracking viewport visibility"
      });
      $$unsubscribe_started = subscribe(started, (value) => $started = value);
      invalidate("ViewportAwareObject");
      if ($$props.object === void 0 && $$bindings.object && object !== void 0)
        $$bindings.object(object);
      if ($$props.viewportAware === void 0 && $$bindings.viewportAware && viewportAware !== void 0)
        $$bindings.viewportAware(viewportAware);
      if ($$props.inViewport === void 0 && $$bindings.inViewport && inViewport !== void 0)
        $$bindings.inViewport(inViewport);
      {
        if (viewportAware && !$started) {
          start();
        } else if (!viewportAware && $started) {
          stop();
        }
      }
      $$unsubscribe_started();
      $$unsubscribe_ticked();
      $$unsubscribe_camera();
      return ``;
    });
    Object3DInstance = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { object } = $$props;
      let { position = void 0 } = $$props;
      let { scale = void 0 } = $$props;
      let { rotation = void 0 } = $$props;
      let { lookAt = void 0 } = $$props;
      let { viewportAware = false } = $$props;
      let { inViewport = false } = $$props;
      let { castShadow = void 0 } = $$props;
      let { receiveShadow = void 0 } = $$props;
      let { frustumCulled = void 0 } = $$props;
      let { renderOrder = void 0 } = $$props;
      let { visible = void 0 } = $$props;
      const { invalidate } = useThrelte();
      const getObject = () => object;
      if ($$props.object === void 0 && $$bindings.object && object !== void 0)
        $$bindings.object(object);
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.scale === void 0 && $$bindings.scale && scale !== void 0)
        $$bindings.scale(scale);
      if ($$props.rotation === void 0 && $$bindings.rotation && rotation !== void 0)
        $$bindings.rotation(rotation);
      if ($$props.lookAt === void 0 && $$bindings.lookAt && lookAt !== void 0)
        $$bindings.lookAt(lookAt);
      if ($$props.viewportAware === void 0 && $$bindings.viewportAware && viewportAware !== void 0)
        $$bindings.viewportAware(viewportAware);
      if ($$props.inViewport === void 0 && $$bindings.inViewport && inViewport !== void 0)
        $$bindings.inViewport(inViewport);
      if ($$props.castShadow === void 0 && $$bindings.castShadow && castShadow !== void 0)
        $$bindings.castShadow(castShadow);
      if ($$props.receiveShadow === void 0 && $$bindings.receiveShadow && receiveShadow !== void 0)
        $$bindings.receiveShadow(receiveShadow);
      if ($$props.frustumCulled === void 0 && $$bindings.frustumCulled && frustumCulled !== void 0)
        $$bindings.frustumCulled(frustumCulled);
      if ($$props.renderOrder === void 0 && $$bindings.renderOrder && renderOrder !== void 0)
        $$bindings.renderOrder(renderOrder);
      if ($$props.visible === void 0 && $$bindings.visible && visible !== void 0)
        $$bindings.visible(visible);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        {
          {
            if (visible !== void 0)
              getObject().visible = visible;
            if (castShadow !== void 0)
              getObject().castShadow = castShadow;
            if (receiveShadow !== void 0)
              getObject().receiveShadow = receiveShadow;
            if (frustumCulled !== void 0)
              getObject().frustumCulled = frustumCulled;
            if (renderOrder !== void 0)
              getObject().renderOrder = renderOrder;
            invalidate("Object3DInstance: props changed");
          }
        }
        $$rendered = `${validate_component(LayerableObject, "LayerableObject").$$render($$result, { object }, {}, {})}

${validate_component(TransformableObject, "TransformableObject").$$render($$result, {
          object,
          position,
          rotation,
          scale,
          lookAt
        }, {}, {})}

${validate_component(HierarchicalObject, "HierarchicalObject").$$render($$result, { object }, {}, {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        })}

${validate_component(ViewportAwareObject, "ViewportAwareObject").$$render($$result, { object, viewportAware, inViewport }, {
          inViewport: ($$value) => {
            inViewport = $$value;
            $$settled = false;
          }
        }, {})}`;
      } while (!$$settled);
      return $$rendered;
    });
    CameraInstance = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $cam, $$unsubscribe_cam;
      let { camera } = $$props;
      let { position = void 0 } = $$props;
      let { scale = void 0 } = $$props;
      let { rotation = void 0 } = $$props;
      let { lookAt = void 0 } = $$props;
      let { viewportAware = false } = $$props;
      let { inViewport = false } = $$props;
      let { castShadow = void 0 } = $$props;
      let { receiveShadow = void 0 } = $$props;
      let { frustumCulled = void 0 } = $$props;
      let { renderOrder = void 0 } = $$props;
      let { visible = void 0 } = $$props;
      let { useCamera = false } = $$props;
      const cam = createObjectStore(camera);
      $$unsubscribe_cam = subscribe(cam, (value) => $cam = value);
      const { setCamera } = useThrelteRoot();
      if ($$props.camera === void 0 && $$bindings.camera && camera !== void 0)
        $$bindings.camera(camera);
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.scale === void 0 && $$bindings.scale && scale !== void 0)
        $$bindings.scale(scale);
      if ($$props.rotation === void 0 && $$bindings.rotation && rotation !== void 0)
        $$bindings.rotation(rotation);
      if ($$props.lookAt === void 0 && $$bindings.lookAt && lookAt !== void 0)
        $$bindings.lookAt(lookAt);
      if ($$props.viewportAware === void 0 && $$bindings.viewportAware && viewportAware !== void 0)
        $$bindings.viewportAware(viewportAware);
      if ($$props.inViewport === void 0 && $$bindings.inViewport && inViewport !== void 0)
        $$bindings.inViewport(inViewport);
      if ($$props.castShadow === void 0 && $$bindings.castShadow && castShadow !== void 0)
        $$bindings.castShadow(castShadow);
      if ($$props.receiveShadow === void 0 && $$bindings.receiveShadow && receiveShadow !== void 0)
        $$bindings.receiveShadow(receiveShadow);
      if ($$props.frustumCulled === void 0 && $$bindings.frustumCulled && frustumCulled !== void 0)
        $$bindings.frustumCulled(frustumCulled);
      if ($$props.renderOrder === void 0 && $$bindings.renderOrder && renderOrder !== void 0)
        $$bindings.renderOrder(renderOrder);
      if ($$props.visible === void 0 && $$bindings.visible && visible !== void 0)
        $$bindings.visible(visible);
      if ($$props.useCamera === void 0 && $$bindings.useCamera && useCamera !== void 0)
        $$bindings.useCamera(useCamera);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        {
          cam.set(camera);
        }
        {
          if (useCamera) {
            setCamera($cam);
          }
        }
        $$rendered = `${validate_component(Object3DInstance, "Object3DInstance").$$render($$result, {
          object: camera,
          lookAt,
          castShadow,
          receiveShadow,
          frustumCulled,
          renderOrder,
          position,
          scale,
          rotation,
          viewportAware,
          visible,
          inViewport
        }, {
          inViewport: ($$value) => {
            inViewport = $$value;
            $$settled = false;
          }
        }, {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        })}`;
      } while (!$$settled);
      $$unsubscribe_cam();
      return $$rendered;
    });
    PerspectiveCamera = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $size, $$unsubscribe_size;
      let { position = void 0 } = $$props;
      let { scale = void 0 } = $$props;
      let { rotation = void 0 } = $$props;
      let { lookAt = void 0 } = $$props;
      let { castShadow = void 0 } = $$props;
      let { receiveShadow = void 0 } = $$props;
      let { frustumCulled = void 0 } = $$props;
      let { renderOrder = void 0 } = $$props;
      let { visible = void 0 } = $$props;
      let { viewportAware = false } = $$props;
      let { inViewport = false } = $$props;
      let { useCamera = true } = $$props;
      let { near = void 0 } = $$props;
      let { far = void 0 } = $$props;
      let { fov = void 0 } = $$props;
      const { size, invalidate } = useThrelte();
      $$unsubscribe_size = subscribe(size, (value) => $size = value);
      const camera = new PerspectiveCamera$1(fov, $size.width / $size.height, near, far);
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.scale === void 0 && $$bindings.scale && scale !== void 0)
        $$bindings.scale(scale);
      if ($$props.rotation === void 0 && $$bindings.rotation && rotation !== void 0)
        $$bindings.rotation(rotation);
      if ($$props.lookAt === void 0 && $$bindings.lookAt && lookAt !== void 0)
        $$bindings.lookAt(lookAt);
      if ($$props.castShadow === void 0 && $$bindings.castShadow && castShadow !== void 0)
        $$bindings.castShadow(castShadow);
      if ($$props.receiveShadow === void 0 && $$bindings.receiveShadow && receiveShadow !== void 0)
        $$bindings.receiveShadow(receiveShadow);
      if ($$props.frustumCulled === void 0 && $$bindings.frustumCulled && frustumCulled !== void 0)
        $$bindings.frustumCulled(frustumCulled);
      if ($$props.renderOrder === void 0 && $$bindings.renderOrder && renderOrder !== void 0)
        $$bindings.renderOrder(renderOrder);
      if ($$props.visible === void 0 && $$bindings.visible && visible !== void 0)
        $$bindings.visible(visible);
      if ($$props.viewportAware === void 0 && $$bindings.viewportAware && viewportAware !== void 0)
        $$bindings.viewportAware(viewportAware);
      if ($$props.inViewport === void 0 && $$bindings.inViewport && inViewport !== void 0)
        $$bindings.inViewport(inViewport);
      if ($$props.useCamera === void 0 && $$bindings.useCamera && useCamera !== void 0)
        $$bindings.useCamera(useCamera);
      if ($$props.near === void 0 && $$bindings.near && near !== void 0)
        $$bindings.near(near);
      if ($$props.far === void 0 && $$bindings.far && far !== void 0)
        $$bindings.far(far);
      if ($$props.fov === void 0 && $$bindings.fov && fov !== void 0)
        $$bindings.fov(fov);
      if ($$props.camera === void 0 && $$bindings.camera && camera !== void 0)
        $$bindings.camera(camera);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        {
          {
            camera.aspect = $size.width / $size.height;
            camera.updateProjectionMatrix();
            invalidate("PerspectiveCamera: aspect changed");
          }
        }
        {
          {
            if (near !== void 0)
              camera.near = near;
            if (far !== void 0)
              camera.far = far;
            if (fov !== void 0)
              camera.fov = fov;
            camera.updateProjectionMatrix();
            invalidate("PerspectiveCamera: props changed");
          }
        }
        $$rendered = `${validate_component(CameraInstance, "CameraInstance").$$render($$result, {
          camera,
          position,
          scale,
          rotation,
          castShadow,
          receiveShadow,
          frustumCulled,
          renderOrder,
          visible,
          viewportAware,
          lookAt,
          useCamera,
          inViewport
        }, {
          inViewport: ($$value) => {
            inViewport = $$value;
            $$settled = false;
          }
        }, {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        })}`;
      } while (!$$settled);
      $$unsubscribe_size();
      return $$rendered;
    });
    loaders = [];
    useLoader = (loader2, memoizeFn) => {
      const maybeLoader = loaders.find((ll) => ll instanceof loader2);
      if (maybeLoader)
        return maybeLoader;
      const newLoader = memoizeFn();
      loaders.push(newLoader);
      return newLoader;
    };
    _changeEvent$1 = { type: "change" };
    _startEvent = { type: "start" };
    _endEvent = { type: "end" };
    OrbitControls$1 = class extends EventDispatcher {
      constructor(object, domElement) {
        super();
        if (domElement === void 0)
          console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
        if (domElement === document)
          console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
        this.object = object;
        this.domElement = domElement;
        this.domElement.style.touchAction = "none";
        this.enabled = true;
        this.target = new Vector3();
        this.minDistance = 0;
        this.maxDistance = Infinity;
        this.minZoom = 0;
        this.maxZoom = Infinity;
        this.minPolarAngle = 0;
        this.maxPolarAngle = Math.PI;
        this.minAzimuthAngle = -Infinity;
        this.maxAzimuthAngle = Infinity;
        this.enableDamping = false;
        this.dampingFactor = 0.05;
        this.enableZoom = true;
        this.zoomSpeed = 1;
        this.enableRotate = true;
        this.rotateSpeed = 1;
        this.enablePan = true;
        this.panSpeed = 1;
        this.screenSpacePanning = true;
        this.keyPanSpeed = 7;
        this.autoRotate = false;
        this.autoRotateSpeed = 2;
        this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
        this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
        this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.zoom0 = this.object.zoom;
        this._domElementKeyEvents = null;
        this.getPolarAngle = function() {
          return spherical.phi;
        };
        this.getAzimuthalAngle = function() {
          return spherical.theta;
        };
        this.getDistance = function() {
          return this.object.position.distanceTo(this.target);
        };
        this.listenToKeyEvents = function(domElement2) {
          domElement2.addEventListener("keydown", onKeyDown);
          this._domElementKeyEvents = domElement2;
        };
        this.saveState = function() {
          scope.target0.copy(scope.target);
          scope.position0.copy(scope.object.position);
          scope.zoom0 = scope.object.zoom;
        };
        this.reset = function() {
          scope.target.copy(scope.target0);
          scope.object.position.copy(scope.position0);
          scope.object.zoom = scope.zoom0;
          scope.object.updateProjectionMatrix();
          scope.dispatchEvent(_changeEvent$1);
          scope.update();
          state = STATE.NONE;
        };
        this.update = function() {
          const offset = new Vector3();
          const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
          const quatInverse = quat.clone().invert();
          const lastPosition = new Vector3();
          const lastQuaternion = new Quaternion();
          const twoPI = 2 * Math.PI;
          return function update2() {
            const position = scope.object.position;
            offset.copy(position).sub(scope.target);
            offset.applyQuaternion(quat);
            spherical.setFromVector3(offset);
            if (scope.autoRotate && state === STATE.NONE) {
              rotateLeft(getAutoRotationAngle());
            }
            if (scope.enableDamping) {
              spherical.theta += sphericalDelta.theta * scope.dampingFactor;
              spherical.phi += sphericalDelta.phi * scope.dampingFactor;
            } else {
              spherical.theta += sphericalDelta.theta;
              spherical.phi += sphericalDelta.phi;
            }
            let min = scope.minAzimuthAngle;
            let max = scope.maxAzimuthAngle;
            if (isFinite(min) && isFinite(max)) {
              if (min < -Math.PI)
                min += twoPI;
              else if (min > Math.PI)
                min -= twoPI;
              if (max < -Math.PI)
                max += twoPI;
              else if (max > Math.PI)
                max -= twoPI;
              if (min <= max) {
                spherical.theta = Math.max(min, Math.min(max, spherical.theta));
              } else {
                spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
              }
            }
            spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
            spherical.makeSafe();
            spherical.radius *= scale;
            spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
            if (scope.enableDamping === true) {
              scope.target.addScaledVector(panOffset, scope.dampingFactor);
            } else {
              scope.target.add(panOffset);
            }
            offset.setFromSpherical(spherical);
            offset.applyQuaternion(quatInverse);
            position.copy(scope.target).add(offset);
            scope.object.lookAt(scope.target);
            if (scope.enableDamping === true) {
              sphericalDelta.theta *= 1 - scope.dampingFactor;
              sphericalDelta.phi *= 1 - scope.dampingFactor;
              panOffset.multiplyScalar(1 - scope.dampingFactor);
            } else {
              sphericalDelta.set(0, 0, 0);
              panOffset.set(0, 0, 0);
            }
            scale = 1;
            if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
              scope.dispatchEvent(_changeEvent$1);
              lastPosition.copy(scope.object.position);
              lastQuaternion.copy(scope.object.quaternion);
              zoomChanged = false;
              return true;
            }
            return false;
          };
        }();
        this.dispose = function() {
          scope.domElement.removeEventListener("contextmenu", onContextMenu);
          scope.domElement.removeEventListener("pointerdown", onPointerDown2);
          scope.domElement.removeEventListener("pointercancel", onPointerCancel);
          scope.domElement.removeEventListener("wheel", onMouseWheel);
          scope.domElement.removeEventListener("pointermove", onPointerMove2);
          scope.domElement.removeEventListener("pointerup", onPointerUp2);
          if (scope._domElementKeyEvents !== null) {
            scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
          }
        };
        const scope = this;
        const STATE = {
          NONE: -1,
          ROTATE: 0,
          DOLLY: 1,
          PAN: 2,
          TOUCH_ROTATE: 3,
          TOUCH_PAN: 4,
          TOUCH_DOLLY_PAN: 5,
          TOUCH_DOLLY_ROTATE: 6
        };
        let state = STATE.NONE;
        const EPS = 1e-6;
        const spherical = new Spherical();
        const sphericalDelta = new Spherical();
        let scale = 1;
        const panOffset = new Vector3();
        let zoomChanged = false;
        const rotateStart = new Vector2();
        const rotateEnd = new Vector2();
        const rotateDelta = new Vector2();
        const panStart = new Vector2();
        const panEnd = new Vector2();
        const panDelta = new Vector2();
        const dollyStart = new Vector2();
        const dollyEnd = new Vector2();
        const dollyDelta = new Vector2();
        const pointers = [];
        const pointerPositions = {};
        function getAutoRotationAngle() {
          return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
        }
        function getZoomScale() {
          return Math.pow(0.95, scope.zoomSpeed);
        }
        function rotateLeft(angle) {
          sphericalDelta.theta -= angle;
        }
        function rotateUp(angle) {
          sphericalDelta.phi -= angle;
        }
        const panLeft = function() {
          const v2 = new Vector3();
          return function panLeft2(distance, objectMatrix) {
            v2.setFromMatrixColumn(objectMatrix, 0);
            v2.multiplyScalar(-distance);
            panOffset.add(v2);
          };
        }();
        const panUp = function() {
          const v2 = new Vector3();
          return function panUp2(distance, objectMatrix) {
            if (scope.screenSpacePanning === true) {
              v2.setFromMatrixColumn(objectMatrix, 1);
            } else {
              v2.setFromMatrixColumn(objectMatrix, 0);
              v2.crossVectors(scope.object.up, v2);
            }
            v2.multiplyScalar(distance);
            panOffset.add(v2);
          };
        }();
        const pan = function() {
          const offset = new Vector3();
          return function pan2(deltaX, deltaY) {
            const element = scope.domElement;
            if (scope.object.isPerspectiveCamera) {
              const position = scope.object.position;
              offset.copy(position).sub(scope.target);
              let targetDistance = offset.length();
              targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
              panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
              panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
            } else if (scope.object.isOrthographicCamera) {
              panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
              panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
            } else {
              console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
              scope.enablePan = false;
            }
          };
        }();
        function dollyOut(dollyScale) {
          if (scope.object.isPerspectiveCamera) {
            scale /= dollyScale;
          } else if (scope.object.isOrthographicCamera) {
            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          } else {
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
            scope.enableZoom = false;
          }
        }
        function dollyIn(dollyScale) {
          if (scope.object.isPerspectiveCamera) {
            scale *= dollyScale;
          } else if (scope.object.isOrthographicCamera) {
            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          } else {
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
            scope.enableZoom = false;
          }
        }
        function handleMouseDownRotate(event) {
          rotateStart.set(event.clientX, event.clientY);
        }
        function handleMouseDownDolly(event) {
          dollyStart.set(event.clientX, event.clientY);
        }
        function handleMouseDownPan(event) {
          panStart.set(event.clientX, event.clientY);
        }
        function handleMouseMoveRotate(event) {
          rotateEnd.set(event.clientX, event.clientY);
          rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
          const element = scope.domElement;
          rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
          rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
          rotateStart.copy(rotateEnd);
          scope.update();
        }
        function handleMouseMoveDolly(event) {
          dollyEnd.set(event.clientX, event.clientY);
          dollyDelta.subVectors(dollyEnd, dollyStart);
          if (dollyDelta.y > 0) {
            dollyOut(getZoomScale());
          } else if (dollyDelta.y < 0) {
            dollyIn(getZoomScale());
          }
          dollyStart.copy(dollyEnd);
          scope.update();
        }
        function handleMouseMovePan(event) {
          panEnd.set(event.clientX, event.clientY);
          panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
          pan(panDelta.x, panDelta.y);
          panStart.copy(panEnd);
          scope.update();
        }
        function handleMouseWheel(event) {
          if (event.deltaY < 0) {
            dollyIn(getZoomScale());
          } else if (event.deltaY > 0) {
            dollyOut(getZoomScale());
          }
          scope.update();
        }
        function handleKeyDown(event) {
          let needsUpdate = false;
          switch (event.code) {
            case scope.keys.UP:
              pan(0, scope.keyPanSpeed);
              needsUpdate = true;
              break;
            case scope.keys.BOTTOM:
              pan(0, -scope.keyPanSpeed);
              needsUpdate = true;
              break;
            case scope.keys.LEFT:
              pan(scope.keyPanSpeed, 0);
              needsUpdate = true;
              break;
            case scope.keys.RIGHT:
              pan(-scope.keyPanSpeed, 0);
              needsUpdate = true;
              break;
          }
          if (needsUpdate) {
            event.preventDefault();
            scope.update();
          }
        }
        function handleTouchStartRotate() {
          if (pointers.length === 1) {
            rotateStart.set(pointers[0].pageX, pointers[0].pageY);
          } else {
            const x22 = 0.5 * (pointers[0].pageX + pointers[1].pageX);
            const y2 = 0.5 * (pointers[0].pageY + pointers[1].pageY);
            rotateStart.set(x22, y2);
          }
        }
        function handleTouchStartPan() {
          if (pointers.length === 1) {
            panStart.set(pointers[0].pageX, pointers[0].pageY);
          } else {
            const x22 = 0.5 * (pointers[0].pageX + pointers[1].pageX);
            const y2 = 0.5 * (pointers[0].pageY + pointers[1].pageY);
            panStart.set(x22, y2);
          }
        }
        function handleTouchStartDolly() {
          const dx = pointers[0].pageX - pointers[1].pageX;
          const dy = pointers[0].pageY - pointers[1].pageY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          dollyStart.set(0, distance);
        }
        function handleTouchStartDollyPan() {
          if (scope.enableZoom)
            handleTouchStartDolly();
          if (scope.enablePan)
            handleTouchStartPan();
        }
        function handleTouchStartDollyRotate() {
          if (scope.enableZoom)
            handleTouchStartDolly();
          if (scope.enableRotate)
            handleTouchStartRotate();
        }
        function handleTouchMoveRotate(event) {
          if (pointers.length == 1) {
            rotateEnd.set(event.pageX, event.pageY);
          } else {
            const position = getSecondPointerPosition(event);
            const x22 = 0.5 * (event.pageX + position.x);
            const y2 = 0.5 * (event.pageY + position.y);
            rotateEnd.set(x22, y2);
          }
          rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
          const element = scope.domElement;
          rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
          rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
          rotateStart.copy(rotateEnd);
        }
        function handleTouchMovePan(event) {
          if (pointers.length === 1) {
            panEnd.set(event.pageX, event.pageY);
          } else {
            const position = getSecondPointerPosition(event);
            const x22 = 0.5 * (event.pageX + position.x);
            const y2 = 0.5 * (event.pageY + position.y);
            panEnd.set(x22, y2);
          }
          panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
          pan(panDelta.x, panDelta.y);
          panStart.copy(panEnd);
        }
        function handleTouchMoveDolly(event) {
          const position = getSecondPointerPosition(event);
          const dx = event.pageX - position.x;
          const dy = event.pageY - position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          dollyEnd.set(0, distance);
          dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
          dollyOut(dollyDelta.y);
          dollyStart.copy(dollyEnd);
        }
        function handleTouchMoveDollyPan(event) {
          if (scope.enableZoom)
            handleTouchMoveDolly(event);
          if (scope.enablePan)
            handleTouchMovePan(event);
        }
        function handleTouchMoveDollyRotate(event) {
          if (scope.enableZoom)
            handleTouchMoveDolly(event);
          if (scope.enableRotate)
            handleTouchMoveRotate(event);
        }
        function onPointerDown2(event) {
          if (scope.enabled === false)
            return;
          if (pointers.length === 0) {
            scope.domElement.setPointerCapture(event.pointerId);
            scope.domElement.addEventListener("pointermove", onPointerMove2);
            scope.domElement.addEventListener("pointerup", onPointerUp2);
          }
          addPointer(event);
          if (event.pointerType === "touch") {
            onTouchStart(event);
          } else {
            onMouseDown(event);
          }
        }
        function onPointerMove2(event) {
          if (scope.enabled === false)
            return;
          if (event.pointerType === "touch") {
            onTouchMove(event);
          } else {
            onMouseMove(event);
          }
        }
        function onPointerUp2(event) {
          removePointer(event);
          if (pointers.length === 0) {
            scope.domElement.releasePointerCapture(event.pointerId);
            scope.domElement.removeEventListener("pointermove", onPointerMove2);
            scope.domElement.removeEventListener("pointerup", onPointerUp2);
          }
          scope.dispatchEvent(_endEvent);
          state = STATE.NONE;
        }
        function onPointerCancel(event) {
          removePointer(event);
        }
        function onMouseDown(event) {
          let mouseAction;
          switch (event.button) {
            case 0:
              mouseAction = scope.mouseButtons.LEFT;
              break;
            case 1:
              mouseAction = scope.mouseButtons.MIDDLE;
              break;
            case 2:
              mouseAction = scope.mouseButtons.RIGHT;
              break;
            default:
              mouseAction = -1;
          }
          switch (mouseAction) {
            case MOUSE.DOLLY:
              if (scope.enableZoom === false)
                return;
              handleMouseDownDolly(event);
              state = STATE.DOLLY;
              break;
            case MOUSE.ROTATE:
              if (event.ctrlKey || event.metaKey || event.shiftKey) {
                if (scope.enablePan === false)
                  return;
                handleMouseDownPan(event);
                state = STATE.PAN;
              } else {
                if (scope.enableRotate === false)
                  return;
                handleMouseDownRotate(event);
                state = STATE.ROTATE;
              }
              break;
            case MOUSE.PAN:
              if (event.ctrlKey || event.metaKey || event.shiftKey) {
                if (scope.enableRotate === false)
                  return;
                handleMouseDownRotate(event);
                state = STATE.ROTATE;
              } else {
                if (scope.enablePan === false)
                  return;
                handleMouseDownPan(event);
                state = STATE.PAN;
              }
              break;
            default:
              state = STATE.NONE;
          }
          if (state !== STATE.NONE) {
            scope.dispatchEvent(_startEvent);
          }
        }
        function onMouseMove(event) {
          if (scope.enabled === false)
            return;
          switch (state) {
            case STATE.ROTATE:
              if (scope.enableRotate === false)
                return;
              handleMouseMoveRotate(event);
              break;
            case STATE.DOLLY:
              if (scope.enableZoom === false)
                return;
              handleMouseMoveDolly(event);
              break;
            case STATE.PAN:
              if (scope.enablePan === false)
                return;
              handleMouseMovePan(event);
              break;
          }
        }
        function onMouseWheel(event) {
          if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE)
            return;
          event.preventDefault();
          scope.dispatchEvent(_startEvent);
          handleMouseWheel(event);
          scope.dispatchEvent(_endEvent);
        }
        function onKeyDown(event) {
          if (scope.enabled === false || scope.enablePan === false)
            return;
          handleKeyDown(event);
        }
        function onTouchStart(event) {
          trackPointer(event);
          switch (pointers.length) {
            case 1:
              switch (scope.touches.ONE) {
                case TOUCH.ROTATE:
                  if (scope.enableRotate === false)
                    return;
                  handleTouchStartRotate();
                  state = STATE.TOUCH_ROTATE;
                  break;
                case TOUCH.PAN:
                  if (scope.enablePan === false)
                    return;
                  handleTouchStartPan();
                  state = STATE.TOUCH_PAN;
                  break;
                default:
                  state = STATE.NONE;
              }
              break;
            case 2:
              switch (scope.touches.TWO) {
                case TOUCH.DOLLY_PAN:
                  if (scope.enableZoom === false && scope.enablePan === false)
                    return;
                  handleTouchStartDollyPan();
                  state = STATE.TOUCH_DOLLY_PAN;
                  break;
                case TOUCH.DOLLY_ROTATE:
                  if (scope.enableZoom === false && scope.enableRotate === false)
                    return;
                  handleTouchStartDollyRotate();
                  state = STATE.TOUCH_DOLLY_ROTATE;
                  break;
                default:
                  state = STATE.NONE;
              }
              break;
            default:
              state = STATE.NONE;
          }
          if (state !== STATE.NONE) {
            scope.dispatchEvent(_startEvent);
          }
        }
        function onTouchMove(event) {
          trackPointer(event);
          switch (state) {
            case STATE.TOUCH_ROTATE:
              if (scope.enableRotate === false)
                return;
              handleTouchMoveRotate(event);
              scope.update();
              break;
            case STATE.TOUCH_PAN:
              if (scope.enablePan === false)
                return;
              handleTouchMovePan(event);
              scope.update();
              break;
            case STATE.TOUCH_DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchMoveDollyPan(event);
              scope.update();
              break;
            case STATE.TOUCH_DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return;
              handleTouchMoveDollyRotate(event);
              scope.update();
              break;
            default:
              state = STATE.NONE;
          }
        }
        function onContextMenu(event) {
          if (scope.enabled === false)
            return;
          event.preventDefault();
        }
        function addPointer(event) {
          pointers.push(event);
        }
        function removePointer(event) {
          delete pointerPositions[event.pointerId];
          for (let i22 = 0; i22 < pointers.length; i22++) {
            if (pointers[i22].pointerId == event.pointerId) {
              pointers.splice(i22, 1);
              return;
            }
          }
        }
        function trackPointer(event) {
          let position = pointerPositions[event.pointerId];
          if (position === void 0) {
            position = new Vector2();
            pointerPositions[event.pointerId] = position;
          }
          position.set(event.pageX, event.pageY);
        }
        function getSecondPointerPosition(event) {
          const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
          return pointerPositions[pointer.pointerId];
        }
        scope.domElement.addEventListener("contextmenu", onContextMenu);
        scope.domElement.addEventListener("pointerdown", onPointerDown2);
        scope.domElement.addEventListener("pointercancel", onPointerCancel);
        scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
        this.update();
      }
    };
    OrbitControls = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $parent, $$unsubscribe_parent;
      let { autoRotate = void 0 } = $$props;
      let { autoRotateSpeed = void 0 } = $$props;
      let { dampingFactor = void 0 } = $$props;
      let { enableDamping = void 0 } = $$props;
      let { enabled = void 0 } = $$props;
      let { enablePan = void 0 } = $$props;
      let { enableRotate = void 0 } = $$props;
      let { enableZoom = void 0 } = $$props;
      let { keyPanSpeed = void 0 } = $$props;
      let { keys = void 0 } = $$props;
      let { maxAzimuthAngle = void 0 } = $$props;
      let { maxDistance = void 0 } = $$props;
      let { maxPolarAngle = void 0 } = $$props;
      let { maxZoom = void 0 } = $$props;
      let { minAzimuthAngle = void 0 } = $$props;
      let { minDistance = void 0 } = $$props;
      let { minPolarAngle = void 0 } = $$props;
      let { minZoom = void 0 } = $$props;
      let { mouseButtons = void 0 } = $$props;
      let { panSpeed = void 0 } = $$props;
      let { rotateSpeed = void 0 } = $$props;
      let { screenSpacePanning = void 0 } = $$props;
      let { touches = void 0 } = $$props;
      let { zoomSpeed = void 0 } = $$props;
      let { target = void 0 } = $$props;
      const parent = getParent();
      $$unsubscribe_parent = subscribe(parent, (value) => $parent = value);
      const { renderer, invalidate } = useThrelte();
      if (!renderer)
        throw new Error("Threlte Context missing: Is <OrbitControls> a child of <Canvas>?");
      if (!($parent instanceof Camera)) {
        throw new Error("Parent missing: <OrbitControls> need to be a child of a <Camera>");
      }
      const dispatch = createEventDispatcher();
      const onChange = () => {
        invalidate("Orbitcontrols: change event");
        dispatch("change");
      };
      const onStart = () => dispatch("start");
      const onEnd = () => dispatch("end");
      const controls = new OrbitControls$1($parent, renderer.domElement);
      getThrelteUserData($parent).orbitControls = controls;
      controls.addEventListener("change", onChange);
      controls.addEventListener("start", onStart);
      controls.addEventListener("end", onEnd);
      onDestroy(() => {
        delete getThrelteUserData($parent).orbitControls;
        controls.removeEventListener("change", onChange);
        controls.removeEventListener("start", onStart);
        controls.removeEventListener("end", onEnd);
      });
      const { start, stop } = useFrame(() => controls.update(), {
        autostart: false,
        debugFrameloopMessage: "OrbitControlts: updating controls"
      });
      const targetObject = new Object3D();
      onDestroy(() => {
        controls.dispose();
        invalidate("OrbitControls: onDestroy");
      });
      if ($$props.autoRotate === void 0 && $$bindings.autoRotate && autoRotate !== void 0)
        $$bindings.autoRotate(autoRotate);
      if ($$props.autoRotateSpeed === void 0 && $$bindings.autoRotateSpeed && autoRotateSpeed !== void 0)
        $$bindings.autoRotateSpeed(autoRotateSpeed);
      if ($$props.dampingFactor === void 0 && $$bindings.dampingFactor && dampingFactor !== void 0)
        $$bindings.dampingFactor(dampingFactor);
      if ($$props.enableDamping === void 0 && $$bindings.enableDamping && enableDamping !== void 0)
        $$bindings.enableDamping(enableDamping);
      if ($$props.enabled === void 0 && $$bindings.enabled && enabled !== void 0)
        $$bindings.enabled(enabled);
      if ($$props.enablePan === void 0 && $$bindings.enablePan && enablePan !== void 0)
        $$bindings.enablePan(enablePan);
      if ($$props.enableRotate === void 0 && $$bindings.enableRotate && enableRotate !== void 0)
        $$bindings.enableRotate(enableRotate);
      if ($$props.enableZoom === void 0 && $$bindings.enableZoom && enableZoom !== void 0)
        $$bindings.enableZoom(enableZoom);
      if ($$props.keyPanSpeed === void 0 && $$bindings.keyPanSpeed && keyPanSpeed !== void 0)
        $$bindings.keyPanSpeed(keyPanSpeed);
      if ($$props.keys === void 0 && $$bindings.keys && keys !== void 0)
        $$bindings.keys(keys);
      if ($$props.maxAzimuthAngle === void 0 && $$bindings.maxAzimuthAngle && maxAzimuthAngle !== void 0)
        $$bindings.maxAzimuthAngle(maxAzimuthAngle);
      if ($$props.maxDistance === void 0 && $$bindings.maxDistance && maxDistance !== void 0)
        $$bindings.maxDistance(maxDistance);
      if ($$props.maxPolarAngle === void 0 && $$bindings.maxPolarAngle && maxPolarAngle !== void 0)
        $$bindings.maxPolarAngle(maxPolarAngle);
      if ($$props.maxZoom === void 0 && $$bindings.maxZoom && maxZoom !== void 0)
        $$bindings.maxZoom(maxZoom);
      if ($$props.minAzimuthAngle === void 0 && $$bindings.minAzimuthAngle && minAzimuthAngle !== void 0)
        $$bindings.minAzimuthAngle(minAzimuthAngle);
      if ($$props.minDistance === void 0 && $$bindings.minDistance && minDistance !== void 0)
        $$bindings.minDistance(minDistance);
      if ($$props.minPolarAngle === void 0 && $$bindings.minPolarAngle && minPolarAngle !== void 0)
        $$bindings.minPolarAngle(minPolarAngle);
      if ($$props.minZoom === void 0 && $$bindings.minZoom && minZoom !== void 0)
        $$bindings.minZoom(minZoom);
      if ($$props.mouseButtons === void 0 && $$bindings.mouseButtons && mouseButtons !== void 0)
        $$bindings.mouseButtons(mouseButtons);
      if ($$props.panSpeed === void 0 && $$bindings.panSpeed && panSpeed !== void 0)
        $$bindings.panSpeed(panSpeed);
      if ($$props.rotateSpeed === void 0 && $$bindings.rotateSpeed && rotateSpeed !== void 0)
        $$bindings.rotateSpeed(rotateSpeed);
      if ($$props.screenSpacePanning === void 0 && $$bindings.screenSpacePanning && screenSpacePanning !== void 0)
        $$bindings.screenSpacePanning(screenSpacePanning);
      if ($$props.touches === void 0 && $$bindings.touches && touches !== void 0)
        $$bindings.touches(touches);
      if ($$props.zoomSpeed === void 0 && $$bindings.zoomSpeed && zoomSpeed !== void 0)
        $$bindings.zoomSpeed(zoomSpeed);
      if ($$props.target === void 0 && $$bindings.target && target !== void 0)
        $$bindings.target(target);
      if ($$props.controls === void 0 && $$bindings.controls && controls !== void 0)
        $$bindings.controls(controls);
      {
        {
          if (autoRotate !== void 0)
            controls.autoRotate = autoRotate;
          if (autoRotateSpeed !== void 0)
            controls.autoRotateSpeed = autoRotateSpeed;
          if (dampingFactor !== void 0)
            controls.dampingFactor = dampingFactor;
          if (enableDamping !== void 0)
            controls.enableDamping = enableDamping;
          if (enabled !== void 0)
            controls.enabled = enabled;
          if (enablePan !== void 0)
            controls.enablePan = enablePan;
          if (enableRotate !== void 0)
            controls.enableRotate = enableRotate;
          if (enableZoom !== void 0)
            controls.enableZoom = enableZoom;
          if (keyPanSpeed !== void 0)
            controls.keyPanSpeed = keyPanSpeed;
          if (keys !== void 0)
            controls.keys = keys;
          if (maxAzimuthAngle !== void 0)
            controls.maxAzimuthAngle = maxAzimuthAngle;
          if (maxDistance !== void 0)
            controls.maxDistance = maxDistance;
          if (maxPolarAngle !== void 0)
            controls.maxPolarAngle = maxPolarAngle;
          if (maxZoom !== void 0)
            controls.maxZoom = maxZoom;
          if (minAzimuthAngle !== void 0)
            controls.minAzimuthAngle = minAzimuthAngle;
          if (minDistance !== void 0)
            controls.minDistance = minDistance;
          if (minPolarAngle !== void 0)
            controls.minPolarAngle = minPolarAngle;
          if (minZoom !== void 0)
            controls.minZoom = minZoom;
          if (mouseButtons !== void 0)
            controls.mouseButtons = mouseButtons;
          if (panSpeed !== void 0)
            controls.panSpeed = panSpeed;
          if (rotateSpeed !== void 0)
            controls.rotateSpeed = rotateSpeed;
          if (screenSpacePanning !== void 0)
            controls.screenSpacePanning = screenSpacePanning;
          if (touches !== void 0)
            controls.touches = touches;
          if (zoomSpeed !== void 0)
            controls.zoomSpeed = zoomSpeed;
          controls.update();
          invalidate("OrbitControls: props changed");
        }
      }
      {
        {
          if (autoRotate || enableDamping)
            start();
          else
            stop();
        }
      }
      $$unsubscribe_parent();
      return `${validate_component(TransformableObject, "TransformableObject").$$render($$result, { object: targetObject, position: target }, {}, {})}`;
    });
    _raycaster = new Raycaster();
    _tempVector = new Vector3();
    _tempVector2 = new Vector3();
    _tempQuaternion = new Quaternion();
    _unit = {
      X: new Vector3(1, 0, 0),
      Y: new Vector3(0, 1, 0),
      Z: new Vector3(0, 0, 1)
    };
    _tempEuler = new Euler();
    _alignVector = new Vector3(0, 1, 0);
    _zeroVector = new Vector3(0, 0, 0);
    _lookAtMatrix = new Matrix4();
    _tempQuaternion2 = new Quaternion();
    _identityQuaternion = new Quaternion();
    _dirVector = new Vector3();
    _tempMatrix = new Matrix4();
    _unitX = new Vector3(1, 0, 0);
    _unitY = new Vector3(0, 1, 0);
    _unitZ = new Vector3(0, 0, 1);
    _v1 = new Vector3();
    _v2 = new Vector3();
    _v3 = new Vector3();
    convertColorRepresentationToColor = (colorRep, linear) => {
      if (linear)
        return new Color(colorRep);
      return new Color().setHex(new Color(colorRep).getHex()).convertSRGBToLinear();
    };
    LightInstance = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $linear, $$unsubscribe_linear;
      let { light } = $$props;
      let { position = void 0 } = $$props;
      let { scale = void 0 } = $$props;
      let { rotation = void 0 } = $$props;
      let { lookAt = void 0 } = $$props;
      let { viewportAware = false } = $$props;
      let { inViewport = false } = $$props;
      let { castShadow = void 0 } = $$props;
      let { receiveShadow = void 0 } = $$props;
      let { frustumCulled = void 0 } = $$props;
      let { renderOrder = void 0 } = $$props;
      let { visible = void 0 } = $$props;
      let { color = void 0 } = $$props;
      let { intensity = void 0 } = $$props;
      const { invalidate } = useThrelte();
      const { linear } = useThrelteRoot();
      $$unsubscribe_linear = subscribe(linear, (value) => $linear = value);
      if ($$props.light === void 0 && $$bindings.light && light !== void 0)
        $$bindings.light(light);
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.scale === void 0 && $$bindings.scale && scale !== void 0)
        $$bindings.scale(scale);
      if ($$props.rotation === void 0 && $$bindings.rotation && rotation !== void 0)
        $$bindings.rotation(rotation);
      if ($$props.lookAt === void 0 && $$bindings.lookAt && lookAt !== void 0)
        $$bindings.lookAt(lookAt);
      if ($$props.viewportAware === void 0 && $$bindings.viewportAware && viewportAware !== void 0)
        $$bindings.viewportAware(viewportAware);
      if ($$props.inViewport === void 0 && $$bindings.inViewport && inViewport !== void 0)
        $$bindings.inViewport(inViewport);
      if ($$props.castShadow === void 0 && $$bindings.castShadow && castShadow !== void 0)
        $$bindings.castShadow(castShadow);
      if ($$props.receiveShadow === void 0 && $$bindings.receiveShadow && receiveShadow !== void 0)
        $$bindings.receiveShadow(receiveShadow);
      if ($$props.frustumCulled === void 0 && $$bindings.frustumCulled && frustumCulled !== void 0)
        $$bindings.frustumCulled(frustumCulled);
      if ($$props.renderOrder === void 0 && $$bindings.renderOrder && renderOrder !== void 0)
        $$bindings.renderOrder(renderOrder);
      if ($$props.visible === void 0 && $$bindings.visible && visible !== void 0)
        $$bindings.visible(visible);
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.intensity === void 0 && $$bindings.intensity && intensity !== void 0)
        $$bindings.intensity(intensity);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        {
          {
            if (intensity !== void 0)
              light.intensity = intensity;
            if (color !== void 0)
              light.color = convertColorRepresentationToColor(color, $linear);
            invalidate("LightInstance: props changed");
          }
        }
        $$rendered = `${validate_component(Object3DInstance, "Object3DInstance").$$render($$result, {
          object: light,
          lookAt,
          castShadow,
          receiveShadow,
          frustumCulled,
          renderOrder,
          position,
          scale,
          rotation,
          viewportAware,
          visible,
          inViewport
        }, {
          inViewport: ($$value) => {
            inViewport = $$value;
            $$settled = false;
          }
        }, {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        })}`;
      } while (!$$settled);
      $$unsubscribe_linear();
      return $$rendered;
    });
    AmbientLight = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { position = void 0 } = $$props;
      let { scale = void 0 } = $$props;
      let { rotation = void 0 } = $$props;
      let { lookAt = void 0 } = $$props;
      let { castShadow = void 0 } = $$props;
      let { receiveShadow = void 0 } = $$props;
      let { frustumCulled = void 0 } = $$props;
      let { renderOrder = void 0 } = $$props;
      let { visible = void 0 } = $$props;
      let { viewportAware = false } = $$props;
      let { inViewport = false } = $$props;
      let { color = void 0 } = $$props;
      let { intensity = void 0 } = $$props;
      const light = new AmbientLight$1(color, intensity);
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.scale === void 0 && $$bindings.scale && scale !== void 0)
        $$bindings.scale(scale);
      if ($$props.rotation === void 0 && $$bindings.rotation && rotation !== void 0)
        $$bindings.rotation(rotation);
      if ($$props.lookAt === void 0 && $$bindings.lookAt && lookAt !== void 0)
        $$bindings.lookAt(lookAt);
      if ($$props.castShadow === void 0 && $$bindings.castShadow && castShadow !== void 0)
        $$bindings.castShadow(castShadow);
      if ($$props.receiveShadow === void 0 && $$bindings.receiveShadow && receiveShadow !== void 0)
        $$bindings.receiveShadow(receiveShadow);
      if ($$props.frustumCulled === void 0 && $$bindings.frustumCulled && frustumCulled !== void 0)
        $$bindings.frustumCulled(frustumCulled);
      if ($$props.renderOrder === void 0 && $$bindings.renderOrder && renderOrder !== void 0)
        $$bindings.renderOrder(renderOrder);
      if ($$props.visible === void 0 && $$bindings.visible && visible !== void 0)
        $$bindings.visible(visible);
      if ($$props.viewportAware === void 0 && $$bindings.viewportAware && viewportAware !== void 0)
        $$bindings.viewportAware(viewportAware);
      if ($$props.inViewport === void 0 && $$bindings.inViewport && inViewport !== void 0)
        $$bindings.inViewport(inViewport);
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.intensity === void 0 && $$bindings.intensity && intensity !== void 0)
        $$bindings.intensity(intensity);
      if ($$props.light === void 0 && $$bindings.light && light !== void 0)
        $$bindings.light(light);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `${validate_component(LightInstance, "LightInstance").$$render($$result, {
          light,
          lookAt,
          position,
          scale,
          rotation,
          castShadow,
          receiveShadow,
          frustumCulled,
          renderOrder,
          visible,
          viewportAware,
          color,
          intensity,
          inViewport
        }, {
          inViewport: ($$value) => {
            inViewport = $$value;
            $$settled = false;
          }
        }, {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        })}`;
      } while (!$$settled);
      return $$rendered;
    });
    SpotLight = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $started, $$unsubscribe_started;
      let { position = void 0 } = $$props;
      let { scale = void 0 } = $$props;
      let { rotation = void 0 } = $$props;
      let { viewportAware = false } = $$props;
      let { inViewport = false } = $$props;
      let { frustumCulled = void 0 } = $$props;
      let { receiveShadow = void 0 } = $$props;
      let { renderOrder = void 0 } = $$props;
      let { visible = void 0 } = $$props;
      let { color = void 0 } = $$props;
      let { intensity = void 0 } = $$props;
      let { angle = void 0 } = $$props;
      let { decay = void 0 } = $$props;
      let { distance = void 0 } = $$props;
      let { penumbra = void 0 } = $$props;
      let { power = void 0 } = $$props;
      let { target = void 0 } = $$props;
      let { shadow = void 0 } = $$props;
      const { invalidate } = useThrelte();
      const light = new SpotLight$1(color, intensity);
      const originalTarget = light.target;
      const { start, stop, started } = useFrame(() => {
      }, {
        autostart: false,
        debugFrameloopMessage: "SpotLight: tracking target"
      });
      $$unsubscribe_started = subscribe(started, (value) => $started = value);
      const updateLightTarget = (target2) => {
        if (target2 && target2 instanceof Object3D && !$started) {
          light.target = target2;
          start();
          invalidate("SpotLight: target changed");
        } else if ((!target2 || !(target2 instanceof Object3D)) && $started) {
          light.target = originalTarget;
          stop();
          invalidate("SpotLight: target changed");
        }
      };
      const updateLightShadow = (shadow2) => {
        if (shadow2) {
          const { mapSize = [512, 512], camera: { near = 0.5, far = 500 } = {}, bias = 0, radius = 1 } = shadow2 === true ? {} : shadow2;
          light.shadow.mapSize.set(mapSize[0], mapSize[1]);
          light.shadow.camera.near = near;
          light.shadow.camera.far = far;
          light.shadow.bias = bias;
          light.shadow.radius = radius;
        }
        invalidate("SpotLight: shadow changed");
      };
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.scale === void 0 && $$bindings.scale && scale !== void 0)
        $$bindings.scale(scale);
      if ($$props.rotation === void 0 && $$bindings.rotation && rotation !== void 0)
        $$bindings.rotation(rotation);
      if ($$props.viewportAware === void 0 && $$bindings.viewportAware && viewportAware !== void 0)
        $$bindings.viewportAware(viewportAware);
      if ($$props.inViewport === void 0 && $$bindings.inViewport && inViewport !== void 0)
        $$bindings.inViewport(inViewport);
      if ($$props.frustumCulled === void 0 && $$bindings.frustumCulled && frustumCulled !== void 0)
        $$bindings.frustumCulled(frustumCulled);
      if ($$props.receiveShadow === void 0 && $$bindings.receiveShadow && receiveShadow !== void 0)
        $$bindings.receiveShadow(receiveShadow);
      if ($$props.renderOrder === void 0 && $$bindings.renderOrder && renderOrder !== void 0)
        $$bindings.renderOrder(renderOrder);
      if ($$props.visible === void 0 && $$bindings.visible && visible !== void 0)
        $$bindings.visible(visible);
      if ($$props.color === void 0 && $$bindings.color && color !== void 0)
        $$bindings.color(color);
      if ($$props.intensity === void 0 && $$bindings.intensity && intensity !== void 0)
        $$bindings.intensity(intensity);
      if ($$props.angle === void 0 && $$bindings.angle && angle !== void 0)
        $$bindings.angle(angle);
      if ($$props.decay === void 0 && $$bindings.decay && decay !== void 0)
        $$bindings.decay(decay);
      if ($$props.distance === void 0 && $$bindings.distance && distance !== void 0)
        $$bindings.distance(distance);
      if ($$props.penumbra === void 0 && $$bindings.penumbra && penumbra !== void 0)
        $$bindings.penumbra(penumbra);
      if ($$props.power === void 0 && $$bindings.power && power !== void 0)
        $$bindings.power(power);
      if ($$props.target === void 0 && $$bindings.target && target !== void 0)
        $$bindings.target(target);
      if ($$props.shadow === void 0 && $$bindings.shadow && shadow !== void 0)
        $$bindings.shadow(shadow);
      if ($$props.light === void 0 && $$bindings.light && light !== void 0)
        $$bindings.light(light);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        {
          updateLightTarget(target);
        }
        {
          updateLightShadow(shadow);
        }
        {
          {
            if (distance !== void 0)
              light.distance = distance;
            if (decay !== void 0)
              light.decay = decay;
            if (angle !== void 0)
              light.angle = angle;
            if (penumbra !== void 0)
              light.penumbra = penumbra;
            if (power !== void 0)
              light.power = power;
            invalidate("SpotLight: props changed");
          }
        }
        $$rendered = `${target && !(target instanceof Object3D) ? `${validate_component(HierarchicalObject, "HierarchicalObject").$$render($$result, { object: originalTarget }, {}, {})}
  ${validate_component(TransformableObject, "TransformableObject").$$render($$result, { object: originalTarget, position: target }, {}, {})}` : ``}

${validate_component(LightInstance, "LightInstance").$$render($$result, {
          light,
          position,
          scale,
          rotation,
          castShadow: shadow ? true : false,
          receiveShadow,
          frustumCulled,
          renderOrder,
          visible,
          viewportAware,
          color,
          intensity,
          inViewport
        }, {
          inViewport: ($$value) => {
            inViewport = $$value;
            $$settled = false;
          }
        }, {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        })}`;
      } while (!$$settled);
      $$unsubscribe_started();
      return $$rendered;
    });
    InteractiveObject = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { object } = $$props;
      let previousObject = object;
      let { interactive = false } = $$props;
      let { ignorePointer = false } = $$props;
      const eventDispatcher = createEventDispatcher();
      const { addInteractiveObject, removeInteractiveObject, addRaycastableObject, removeRaycastableObject } = useThrelteRoot();
      const { invalidate } = useThrelte();
      const removeObjectInteractivity = (object2) => {
        removeRaycastableObject(object2);
        removeInteractiveObject(object2);
        delete getThrelteUserData(object2).eventDispatcher;
      };
      const setupObjectInteractivity = (object2, ignorePointer2, interactive2) => {
        getThrelteUserData(object2).eventDispatcher = eventDispatcher;
        if (ignorePointer2) {
          removeRaycastableObject(object2);
          removeInteractiveObject(object2);
        } else {
          addRaycastableObject(object2);
          if (interactive2) {
            addInteractiveObject(object2);
          } else {
            removeInteractiveObject(object2);
          }
        }
      };
      onDestroy(() => {
        removeObjectInteractivity(object);
        invalidate("InteractiveObject: object removed");
      });
      if ($$props.object === void 0 && $$bindings.object && object !== void 0)
        $$bindings.object(object);
      if ($$props.interactive === void 0 && $$bindings.interactive && interactive !== void 0)
        $$bindings.interactive(interactive);
      if ($$props.ignorePointer === void 0 && $$bindings.ignorePointer && ignorePointer !== void 0)
        $$bindings.ignorePointer(ignorePointer);
      {
        {
          if (object !== previousObject) {
            removeObjectInteractivity(previousObject);
            setupObjectInteractivity(object, ignorePointer, interactive);
            invalidate("InteractiveObject: object changed");
            previousObject = object;
          } else if (object === previousObject) {
            setupObjectInteractivity(object, ignorePointer, interactive);
            invalidate("InteractiveObject: props changed");
          }
        }
      }
      return ``;
    });
    MeshInstance = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { mesh } = $$props;
      let { position = void 0 } = $$props;
      let { scale = void 0 } = $$props;
      let { rotation = void 0 } = $$props;
      let { lookAt = void 0 } = $$props;
      let { viewportAware = false } = $$props;
      let { inViewport = false } = $$props;
      let { castShadow = void 0 } = $$props;
      let { receiveShadow = void 0 } = $$props;
      let { frustumCulled = void 0 } = $$props;
      let { renderOrder = void 0 } = $$props;
      let { visible = void 0 } = $$props;
      let { interactive = false } = $$props;
      let { ignorePointer = false } = $$props;
      if ($$props.mesh === void 0 && $$bindings.mesh && mesh !== void 0)
        $$bindings.mesh(mesh);
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.scale === void 0 && $$bindings.scale && scale !== void 0)
        $$bindings.scale(scale);
      if ($$props.rotation === void 0 && $$bindings.rotation && rotation !== void 0)
        $$bindings.rotation(rotation);
      if ($$props.lookAt === void 0 && $$bindings.lookAt && lookAt !== void 0)
        $$bindings.lookAt(lookAt);
      if ($$props.viewportAware === void 0 && $$bindings.viewportAware && viewportAware !== void 0)
        $$bindings.viewportAware(viewportAware);
      if ($$props.inViewport === void 0 && $$bindings.inViewport && inViewport !== void 0)
        $$bindings.inViewport(inViewport);
      if ($$props.castShadow === void 0 && $$bindings.castShadow && castShadow !== void 0)
        $$bindings.castShadow(castShadow);
      if ($$props.receiveShadow === void 0 && $$bindings.receiveShadow && receiveShadow !== void 0)
        $$bindings.receiveShadow(receiveShadow);
      if ($$props.frustumCulled === void 0 && $$bindings.frustumCulled && frustumCulled !== void 0)
        $$bindings.frustumCulled(frustumCulled);
      if ($$props.renderOrder === void 0 && $$bindings.renderOrder && renderOrder !== void 0)
        $$bindings.renderOrder(renderOrder);
      if ($$props.visible === void 0 && $$bindings.visible && visible !== void 0)
        $$bindings.visible(visible);
      if ($$props.interactive === void 0 && $$bindings.interactive && interactive !== void 0)
        $$bindings.interactive(interactive);
      if ($$props.ignorePointer === void 0 && $$bindings.ignorePointer && ignorePointer !== void 0)
        $$bindings.ignorePointer(ignorePointer);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `${validate_component(Object3DInstance, "Object3DInstance").$$render($$result, {
          object: mesh,
          lookAt,
          position,
          scale,
          rotation,
          castShadow,
          receiveShadow,
          frustumCulled,
          renderOrder,
          visible,
          viewportAware,
          inViewport
        }, {
          inViewport: ($$value) => {
            inViewport = $$value;
            $$settled = false;
          }
        }, {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        })}

${validate_component(InteractiveObject, "InteractiveObject").$$render($$result, { object: mesh, interactive, ignorePointer }, {}, {})}`;
      } while (!$$settled);
      return $$rendered;
    });
    Mesh = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { position = void 0 } = $$props;
      let { scale = void 0 } = $$props;
      let { rotation = void 0 } = $$props;
      let { viewportAware = false } = $$props;
      let { inViewport = false } = $$props;
      let { castShadow = void 0 } = $$props;
      let { receiveShadow = void 0 } = $$props;
      let { frustumCulled = void 0 } = $$props;
      let { renderOrder = void 0 } = $$props;
      let { visible = void 0 } = $$props;
      let { interactive = false } = $$props;
      let { ignorePointer = false } = $$props;
      let { lookAt = void 0 } = $$props;
      let { geometry } = $$props;
      let { material } = $$props;
      let previousMaterial = material;
      let previousGeometry = geometry;
      const { invalidate } = useThrelte();
      const mesh = new Mesh$1(geometry, material);
      const getMesh = () => mesh;
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.scale === void 0 && $$bindings.scale && scale !== void 0)
        $$bindings.scale(scale);
      if ($$props.rotation === void 0 && $$bindings.rotation && rotation !== void 0)
        $$bindings.rotation(rotation);
      if ($$props.viewportAware === void 0 && $$bindings.viewportAware && viewportAware !== void 0)
        $$bindings.viewportAware(viewportAware);
      if ($$props.inViewport === void 0 && $$bindings.inViewport && inViewport !== void 0)
        $$bindings.inViewport(inViewport);
      if ($$props.castShadow === void 0 && $$bindings.castShadow && castShadow !== void 0)
        $$bindings.castShadow(castShadow);
      if ($$props.receiveShadow === void 0 && $$bindings.receiveShadow && receiveShadow !== void 0)
        $$bindings.receiveShadow(receiveShadow);
      if ($$props.frustumCulled === void 0 && $$bindings.frustumCulled && frustumCulled !== void 0)
        $$bindings.frustumCulled(frustumCulled);
      if ($$props.renderOrder === void 0 && $$bindings.renderOrder && renderOrder !== void 0)
        $$bindings.renderOrder(renderOrder);
      if ($$props.visible === void 0 && $$bindings.visible && visible !== void 0)
        $$bindings.visible(visible);
      if ($$props.interactive === void 0 && $$bindings.interactive && interactive !== void 0)
        $$bindings.interactive(interactive);
      if ($$props.ignorePointer === void 0 && $$bindings.ignorePointer && ignorePointer !== void 0)
        $$bindings.ignorePointer(ignorePointer);
      if ($$props.lookAt === void 0 && $$bindings.lookAt && lookAt !== void 0)
        $$bindings.lookAt(lookAt);
      if ($$props.geometry === void 0 && $$bindings.geometry && geometry !== void 0)
        $$bindings.geometry(geometry);
      if ($$props.material === void 0 && $$bindings.material && material !== void 0)
        $$bindings.material(material);
      if ($$props.mesh === void 0 && $$bindings.mesh && mesh !== void 0)
        $$bindings.mesh(mesh);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        {
          {
            if (material !== previousMaterial) {
              getMesh().material = material;
              invalidate("Mesh: material changed");
            } else {
              invalidate("Mesh: material props changed");
            }
            previousMaterial = material;
          }
        }
        {
          {
            if (geometry !== previousGeometry) {
              getMesh().geometry = geometry;
              invalidate("Mesh: geometry changed");
            } else {
              invalidate("Mesh: geometry props changed");
            }
            previousGeometry = geometry;
          }
        }
        $$rendered = `${validate_component(MeshInstance, "MeshInstance").$$render($$result, {
          mesh,
          position,
          scale,
          rotation,
          lookAt,
          castShadow,
          receiveShadow,
          frustumCulled,
          renderOrder,
          visible,
          interactive,
          ignorePointer,
          viewportAware,
          inViewport
        }, {
          inViewport: ($$value) => {
            inViewport = $$value;
            $$settled = false;
          }
        }, {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        })}`;
      } while (!$$settled);
      return $$rendered;
    });
    placeholderObject3D = new Object3D();
    placeholderObject3D.scale.set(0, 0, 0);
    ({
      matrix: placeholderObject3D.matrix,
      color: null
    });
    new Matrix4().fromArray(new Array(16).fill(0));
    new Color(16777215);
    Group = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { position = void 0 } = $$props;
      let { scale = void 0 } = $$props;
      let { rotation = void 0 } = $$props;
      let { lookAt = void 0 } = $$props;
      let { viewportAware = false } = $$props;
      let { inViewport = false } = $$props;
      let { castShadow = void 0 } = $$props;
      let { receiveShadow = void 0 } = $$props;
      let { frustumCulled = void 0 } = $$props;
      let { renderOrder = void 0 } = $$props;
      let { visible = void 0 } = $$props;
      const group = new Group$1();
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.scale === void 0 && $$bindings.scale && scale !== void 0)
        $$bindings.scale(scale);
      if ($$props.rotation === void 0 && $$bindings.rotation && rotation !== void 0)
        $$bindings.rotation(rotation);
      if ($$props.lookAt === void 0 && $$bindings.lookAt && lookAt !== void 0)
        $$bindings.lookAt(lookAt);
      if ($$props.viewportAware === void 0 && $$bindings.viewportAware && viewportAware !== void 0)
        $$bindings.viewportAware(viewportAware);
      if ($$props.inViewport === void 0 && $$bindings.inViewport && inViewport !== void 0)
        $$bindings.inViewport(inViewport);
      if ($$props.castShadow === void 0 && $$bindings.castShadow && castShadow !== void 0)
        $$bindings.castShadow(castShadow);
      if ($$props.receiveShadow === void 0 && $$bindings.receiveShadow && receiveShadow !== void 0)
        $$bindings.receiveShadow(receiveShadow);
      if ($$props.frustumCulled === void 0 && $$bindings.frustumCulled && frustumCulled !== void 0)
        $$bindings.frustumCulled(frustumCulled);
      if ($$props.renderOrder === void 0 && $$bindings.renderOrder && renderOrder !== void 0)
        $$bindings.renderOrder(renderOrder);
      if ($$props.visible === void 0 && $$bindings.visible && visible !== void 0)
        $$bindings.visible(visible);
      if ($$props.group === void 0 && $$bindings.group && group !== void 0)
        $$bindings.group(group);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `${validate_component(Object3DInstance, "Object3DInstance").$$render($$result, {
          object: group,
          position,
          scale,
          rotation,
          lookAt,
          frustumCulled,
          renderOrder,
          visible,
          castShadow,
          receiveShadow,
          viewportAware,
          inViewport
        }, {
          inViewport: ($$value) => {
            inViewport = $$value;
            $$settled = false;
          }
        }, {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        })}`;
      } while (!$$settled);
      return $$rendered;
    });
    _q = new Quaternion();
    WorkerPool = class {
      constructor(pool = 4) {
        this.pool = pool;
        this.queue = [];
        this.workers = [];
        this.workersResolve = [];
        this.workerStatus = 0;
      }
      _initWorker(workerId) {
        if (!this.workers[workerId]) {
          const worker = this.workerCreator();
          worker.addEventListener("message", this._onMessage.bind(this, workerId));
          this.workers[workerId] = worker;
        }
      }
      _getIdleWorker() {
        for (let i22 = 0; i22 < this.pool; i22++)
          if (!(this.workerStatus & 1 << i22))
            return i22;
        return -1;
      }
      _onMessage(workerId, msg) {
        const resolve2 = this.workersResolve[workerId];
        resolve2 && resolve2(msg);
        if (this.queue.length) {
          const { resolve: resolve22, msg: msg2, transfer } = this.queue.shift();
          this.workersResolve[workerId] = resolve22;
          this.workers[workerId].postMessage(msg2, transfer);
        } else {
          this.workerStatus ^= 1 << workerId;
        }
      }
      setWorkerCreator(workerCreator) {
        this.workerCreator = workerCreator;
      }
      setWorkerLimit(pool) {
        this.pool = pool;
      }
      postMessage(msg, transfer) {
        return new Promise((resolve2) => {
          const workerId = this._getIdleWorker();
          if (workerId !== -1) {
            this._initWorker(workerId);
            this.workerStatus |= 1 << workerId;
            this.workersResolve[workerId] = resolve2;
            this.workers[workerId].postMessage(msg, transfer);
          } else {
            this.queue.push({ resolve: resolve2, msg, transfer });
          }
        });
      }
      dispose() {
        this.workers.forEach((worker) => worker.terminate());
        this.workersResolve.length = 0;
        this.workers.length = 0;
        this.queue.length = 0;
        this.workerStatus = 0;
      }
    };
    t2 = 0;
    e2 = 1;
    n = 2;
    i2 = 3;
    s3 = 0;
    a = 0;
    r2 = 2;
    o = 0;
    l = 1;
    f3 = 160;
    U = 161;
    c = 162;
    h2 = 163;
    _ = 0;
    p = 1;
    g = 0;
    y = 1;
    x2 = 2;
    u = 3;
    b = 4;
    d = 5;
    m2 = 6;
    w = 7;
    D = 8;
    B = 9;
    L = 10;
    A2 = 11;
    k = 12;
    v = 13;
    S2 = 14;
    I = 15;
    O = 16;
    T = 17;
    V = 18;
    E = 0;
    F2 = 1;
    P = 2;
    C = 3;
    z = 4;
    M = 5;
    W = 6;
    N = 7;
    H = 8;
    K = 9;
    X = 10;
    j = 11;
    R = 0;
    Y = 1;
    q = 2;
    G = 13;
    J = 14;
    Q = 15;
    Z2 = 128;
    $ = 64;
    tt = 32;
    et = 16;
    nt = 0;
    it = 1;
    st = 2;
    at = 3;
    rt = 4;
    ot = 5;
    lt = 6;
    ft = 7;
    Ut = 8;
    ct = 9;
    ht = 10;
    _t = 13;
    pt = 14;
    gt = 15;
    yt = 16;
    xt = 17;
    ut = 20;
    bt = 21;
    dt = 22;
    mt = 23;
    wt = 24;
    Dt = 27;
    Bt = 28;
    Lt = 29;
    At = 30;
    kt = 31;
    vt = 34;
    St = 35;
    It = 36;
    Ot = 37;
    Tt = 38;
    Vt = 41;
    Et = 42;
    Ft = 43;
    Pt = 44;
    Ct = 45;
    zt = 48;
    Mt = 49;
    Wt = 50;
    Nt = 58;
    Ht = 59;
    Kt = 62;
    Xt = 63;
    jt = 64;
    Rt = 65;
    Yt = 68;
    qt = 69;
    Gt = 70;
    Jt = 71;
    Qt = 74;
    Zt = 75;
    $t = 76;
    te = 77;
    ee = 78;
    ne = 81;
    ie = 82;
    se = 83;
    ae = 84;
    re = 85;
    oe = 88;
    le = 89;
    fe = 90;
    Ue = 91;
    ce = 92;
    he = 95;
    _e = 96;
    pe = 97;
    ge = 98;
    ye = 99;
    xe = 100;
    ue = 101;
    be = 102;
    de = 103;
    me = 104;
    we = 105;
    De = 106;
    Be = 107;
    Le = 108;
    Ae = 109;
    ke = 110;
    ve = 111;
    Se = 112;
    Ie = 113;
    Oe = 114;
    Te = 115;
    Ve = 116;
    Ee = 117;
    Fe = 118;
    Pe = 119;
    Ce = 120;
    ze = 121;
    Me = 122;
    We = 123;
    Ne = 124;
    He = 125;
    Ke = 126;
    Xe = 127;
    je = 128;
    Re = 129;
    Ye = 130;
    qe = 131;
    Ge = 132;
    Je = 133;
    Qe = 134;
    Ze = 135;
    $e = 136;
    tn = 137;
    en = 138;
    nn = 139;
    sn = 140;
    an = 141;
    rn = 142;
    on = 143;
    ln = 144;
    fn = 145;
    Un = 146;
    cn = 147;
    hn = 148;
    _n = 149;
    pn = 150;
    gn = 151;
    yn = 152;
    xn = 153;
    un = 154;
    bn = 155;
    dn = 156;
    mn = 157;
    wn = 158;
    Dn = 159;
    Bn = 160;
    Ln = 161;
    An = 162;
    kn = 163;
    vn = 164;
    Sn = 165;
    In = 166;
    On = 167;
    Tn = 168;
    Vn = 169;
    En = 170;
    Fn = 171;
    Pn = 172;
    Cn = 173;
    zn = 174;
    Mn = 175;
    Wn = 176;
    Nn = 177;
    Hn = 178;
    Kn = 179;
    Xn = 180;
    jn = 181;
    Rn = 182;
    Yn = 183;
    qn = 184;
    Gn = 1000156007;
    Jn = 1000156008;
    Qn = 1000156009;
    Zn = 1000156010;
    $n = 1000156011;
    ti = 1000156017;
    ei = 1000156018;
    ni = 1000156019;
    ii = 1000156020;
    si = 1000156021;
    ai = 1000054e3;
    ri = 1000054001;
    oi = 1000054002;
    li = 1000054003;
    fi = 1000054004;
    Ui = 1000054005;
    ci = 1000054006;
    hi = 1000054007;
    _i = 1000066e3;
    pi = 1000066001;
    gi = 1000066002;
    yi = 1000066003;
    xi = 1000066004;
    ui = 1000066005;
    bi = 1000066006;
    di = 1000066007;
    mi = 1000066008;
    wi = 1000066009;
    Di = 1000066010;
    Bi = 1000066011;
    Li = 1000066012;
    Ai = 1000066013;
    ki = 100034e4;
    vi = 1000340001;
    Si = class {
      constructor() {
        this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
      }
    };
    Ii = class {
      constructor(t22, e22, n2, i22) {
        this._dataView = new DataView(t22.buffer, t22.byteOffset + e22, n2), this._littleEndian = i22, this._offset = 0;
      }
      _nextUint8() {
        const t22 = this._dataView.getUint8(this._offset);
        return this._offset += 1, t22;
      }
      _nextUint16() {
        const t22 = this._dataView.getUint16(this._offset, this._littleEndian);
        return this._offset += 2, t22;
      }
      _nextUint32() {
        const t22 = this._dataView.getUint32(this._offset, this._littleEndian);
        return this._offset += 4, t22;
      }
      _nextUint64() {
        const t22 = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
        return this._offset += 8, t22;
      }
      _nextInt32() {
        const t22 = this._dataView.getInt32(this._offset, this._littleEndian);
        return this._offset += 4, t22;
      }
      _skip(t22) {
        return this._offset += t22, this;
      }
      _scan(t22, e22 = 0) {
        const n2 = this._offset;
        let i22 = 0;
        for (; this._dataView.getUint8(this._offset) !== e22 && i22 < t22; )
          i22++, this._offset++;
        return i22 < t22 && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n2, i22);
      }
    };
    Oi = new Uint8Array([0]);
    Ti = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
    zi = { keepWriter: false };
    KTX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      KHR_DF_CHANNEL_RGBSDA_ALPHA: Q,
      KHR_DF_CHANNEL_RGBSDA_BLUE: q,
      KHR_DF_CHANNEL_RGBSDA_DEPTH: J,
      KHR_DF_CHANNEL_RGBSDA_GREEN: Y,
      KHR_DF_CHANNEL_RGBSDA_RED: R,
      KHR_DF_CHANNEL_RGBSDA_STENCIL: G,
      KHR_DF_FLAG_ALPHA_PREMULTIPLIED: p,
      KHR_DF_FLAG_ALPHA_STRAIGHT: _,
      KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT: s3,
      KHR_DF_MODEL_ASTC: c,
      KHR_DF_MODEL_ETC1: f3,
      KHR_DF_MODEL_ETC1S: h2,
      KHR_DF_MODEL_ETC2: U,
      KHR_DF_MODEL_RGBSDA: l,
      KHR_DF_MODEL_UNSPECIFIED: o,
      KHR_DF_PRIMARIES_ACES: W,
      KHR_DF_PRIMARIES_ACESCC: N,
      KHR_DF_PRIMARIES_ADOBERGB: j,
      KHR_DF_PRIMARIES_BT2020: z,
      KHR_DF_PRIMARIES_BT601_EBU: P,
      KHR_DF_PRIMARIES_BT601_SMPTE: C,
      KHR_DF_PRIMARIES_BT709: F2,
      KHR_DF_PRIMARIES_CIEXYZ: M,
      KHR_DF_PRIMARIES_DISPLAYP3: X,
      KHR_DF_PRIMARIES_NTSC1953: H,
      KHR_DF_PRIMARIES_PAL525: K,
      KHR_DF_PRIMARIES_UNSPECIFIED: E,
      KHR_DF_SAMPLE_DATATYPE_EXPONENT: tt,
      KHR_DF_SAMPLE_DATATYPE_FLOAT: Z2,
      KHR_DF_SAMPLE_DATATYPE_LINEAR: et,
      KHR_DF_SAMPLE_DATATYPE_SIGNED: $,
      KHR_DF_TRANSFER_ACESCC: O,
      KHR_DF_TRANSFER_ACESCCT: T,
      KHR_DF_TRANSFER_ADOBERGB: V,
      KHR_DF_TRANSFER_BT1886: w,
      KHR_DF_TRANSFER_DCIP3: k,
      KHR_DF_TRANSFER_HLG_EOTF: B,
      KHR_DF_TRANSFER_HLG_OETF: D,
      KHR_DF_TRANSFER_ITU: u,
      KHR_DF_TRANSFER_LINEAR: y,
      KHR_DF_TRANSFER_NTSC: b,
      KHR_DF_TRANSFER_PAL625_EOTF: S2,
      KHR_DF_TRANSFER_PAL_OETF: v,
      KHR_DF_TRANSFER_PQ_EOTF: L,
      KHR_DF_TRANSFER_PQ_OETF: A2,
      KHR_DF_TRANSFER_SLOG: d,
      KHR_DF_TRANSFER_SLOG2: m2,
      KHR_DF_TRANSFER_SRGB: x2,
      KHR_DF_TRANSFER_ST240: I,
      KHR_DF_TRANSFER_UNSPECIFIED: g,
      KHR_DF_VENDORID_KHRONOS: a,
      KHR_DF_VERSION: r2,
      KHR_SUPERCOMPRESSION_BASISLZ: e2,
      KHR_SUPERCOMPRESSION_NONE: t2,
      KHR_SUPERCOMPRESSION_ZLIB: i2,
      KHR_SUPERCOMPRESSION_ZSTD: n,
      KTX2Container: Si,
      VK_FORMAT_A1R5G5B5_UNORM_PACK16: Ut,
      VK_FORMAT_A2B10G10R10_SINT_PACK32: qt,
      VK_FORMAT_A2B10G10R10_SNORM_PACK32: Rt,
      VK_FORMAT_A2B10G10R10_UINT_PACK32: Yt,
      VK_FORMAT_A2B10G10R10_UNORM_PACK32: jt,
      VK_FORMAT_A2R10G10B10_SINT_PACK32: Xt,
      VK_FORMAT_A2R10G10B10_SNORM_PACK32: Ht,
      VK_FORMAT_A2R10G10B10_UINT_PACK32: Kt,
      VK_FORMAT_A2R10G10B10_UNORM_PACK32: Nt,
      VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT: vi,
      VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT: ki,
      VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: Bi,
      VK_FORMAT_ASTC_10x10_SRGB_BLOCK: Xn,
      VK_FORMAT_ASTC_10x10_UNORM_BLOCK: Kn,
      VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: mi,
      VK_FORMAT_ASTC_10x5_SRGB_BLOCK: zn,
      VK_FORMAT_ASTC_10x5_UNORM_BLOCK: Cn,
      VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: wi,
      VK_FORMAT_ASTC_10x6_SRGB_BLOCK: Wn,
      VK_FORMAT_ASTC_10x6_UNORM_BLOCK: Mn,
      VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: Di,
      VK_FORMAT_ASTC_10x8_SRGB_BLOCK: Hn,
      VK_FORMAT_ASTC_10x8_UNORM_BLOCK: Nn,
      VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: Li,
      VK_FORMAT_ASTC_12x10_SRGB_BLOCK: Rn,
      VK_FORMAT_ASTC_12x10_UNORM_BLOCK: jn,
      VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: Ai,
      VK_FORMAT_ASTC_12x12_SRGB_BLOCK: qn,
      VK_FORMAT_ASTC_12x12_UNORM_BLOCK: Yn,
      VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: _i,
      VK_FORMAT_ASTC_4x4_SRGB_BLOCK: wn,
      VK_FORMAT_ASTC_4x4_UNORM_BLOCK: mn,
      VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: pi,
      VK_FORMAT_ASTC_5x4_SRGB_BLOCK: Bn,
      VK_FORMAT_ASTC_5x4_UNORM_BLOCK: Dn,
      VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: gi,
      VK_FORMAT_ASTC_5x5_SRGB_BLOCK: An,
      VK_FORMAT_ASTC_5x5_UNORM_BLOCK: Ln,
      VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: yi,
      VK_FORMAT_ASTC_6x5_SRGB_BLOCK: vn,
      VK_FORMAT_ASTC_6x5_UNORM_BLOCK: kn,
      VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: xi,
      VK_FORMAT_ASTC_6x6_SRGB_BLOCK: In,
      VK_FORMAT_ASTC_6x6_UNORM_BLOCK: Sn,
      VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: ui,
      VK_FORMAT_ASTC_8x5_SRGB_BLOCK: Tn,
      VK_FORMAT_ASTC_8x5_UNORM_BLOCK: On,
      VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: bi,
      VK_FORMAT_ASTC_8x6_SRGB_BLOCK: En,
      VK_FORMAT_ASTC_8x6_UNORM_BLOCK: Vn,
      VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: di,
      VK_FORMAT_ASTC_8x8_SRGB_BLOCK: Pn,
      VK_FORMAT_ASTC_8x8_UNORM_BLOCK: Fn,
      VK_FORMAT_B10G11R11_UFLOAT_PACK32: Me,
      VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: $n,
      VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: si,
      VK_FORMAT_B4G4R4A4_UNORM_PACK16: at,
      VK_FORMAT_B5G5R5A1_UNORM_PACK16: ft,
      VK_FORMAT_B5G6R5_UNORM_PACK16: ot,
      VK_FORMAT_B8G8R8A8_SINT: Mt,
      VK_FORMAT_B8G8R8A8_SNORM: Ct,
      VK_FORMAT_B8G8R8A8_SRGB: Wt,
      VK_FORMAT_B8G8R8A8_UINT: zt,
      VK_FORMAT_B8G8R8A8_UNORM: Pt,
      VK_FORMAT_B8G8R8_SINT: St,
      VK_FORMAT_B8G8R8_SNORM: kt,
      VK_FORMAT_B8G8R8_SRGB: It,
      VK_FORMAT_B8G8R8_UINT: vt,
      VK_FORMAT_B8G8R8_UNORM: At,
      VK_FORMAT_BC1_RGBA_SRGB_BLOCK: Qe,
      VK_FORMAT_BC1_RGBA_UNORM_BLOCK: Je,
      VK_FORMAT_BC1_RGB_SRGB_BLOCK: Ge,
      VK_FORMAT_BC1_RGB_UNORM_BLOCK: qe,
      VK_FORMAT_BC2_SRGB_BLOCK: $e,
      VK_FORMAT_BC2_UNORM_BLOCK: Ze,
      VK_FORMAT_BC3_SRGB_BLOCK: en,
      VK_FORMAT_BC3_UNORM_BLOCK: tn,
      VK_FORMAT_BC4_SNORM_BLOCK: sn,
      VK_FORMAT_BC4_UNORM_BLOCK: nn,
      VK_FORMAT_BC5_SNORM_BLOCK: rn,
      VK_FORMAT_BC5_UNORM_BLOCK: an,
      VK_FORMAT_BC6H_SFLOAT_BLOCK: ln,
      VK_FORMAT_BC6H_UFLOAT_BLOCK: on,
      VK_FORMAT_BC7_SRGB_BLOCK: Un,
      VK_FORMAT_BC7_UNORM_BLOCK: fn,
      VK_FORMAT_D16_UNORM: Ne,
      VK_FORMAT_D16_UNORM_S8_UINT: je,
      VK_FORMAT_D24_UNORM_S8_UINT: Re,
      VK_FORMAT_D32_SFLOAT: Ke,
      VK_FORMAT_D32_SFLOAT_S8_UINT: Ye,
      VK_FORMAT_E5B9G9R9_UFLOAT_PACK32: We,
      VK_FORMAT_EAC_R11G11_SNORM_BLOCK: dn,
      VK_FORMAT_EAC_R11G11_UNORM_BLOCK: bn,
      VK_FORMAT_EAC_R11_SNORM_BLOCK: un,
      VK_FORMAT_EAC_R11_UNORM_BLOCK: xn,
      VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: pn,
      VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: _n,
      VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: yn,
      VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: gn,
      VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK: hn,
      VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK: cn,
      VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: Zn,
      VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: ii,
      VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG: fi,
      VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG: ai,
      VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG: Ui,
      VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG: ri,
      VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG: ci,
      VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG: oi,
      VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG: hi,
      VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG: li,
      VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: Qn,
      VK_FORMAT_R10X6G10X6_UNORM_2PACK16: Jn,
      VK_FORMAT_R10X6_UNORM_PACK16: Gn,
      VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: ni,
      VK_FORMAT_R12X4G12X4_UNORM_2PACK16: ei,
      VK_FORMAT_R12X4_UNORM_PACK16: ti,
      VK_FORMAT_R16G16B16A16_SFLOAT: pe,
      VK_FORMAT_R16G16B16A16_SINT: _e,
      VK_FORMAT_R16G16B16A16_SNORM: ce,
      VK_FORMAT_R16G16B16A16_UINT: he,
      VK_FORMAT_R16G16B16A16_UNORM: Ue,
      VK_FORMAT_R16G16B16_SFLOAT: fe,
      VK_FORMAT_R16G16B16_SINT: le,
      VK_FORMAT_R16G16B16_SNORM: re,
      VK_FORMAT_R16G16B16_UINT: oe,
      VK_FORMAT_R16G16B16_UNORM: ae,
      VK_FORMAT_R16G16_SFLOAT: se,
      VK_FORMAT_R16G16_SINT: ie,
      VK_FORMAT_R16G16_SNORM: ee,
      VK_FORMAT_R16G16_UINT: ne,
      VK_FORMAT_R16G16_UNORM: te,
      VK_FORMAT_R16_SFLOAT: $t,
      VK_FORMAT_R16_SINT: Zt,
      VK_FORMAT_R16_SNORM: Jt,
      VK_FORMAT_R16_UINT: Qt,
      VK_FORMAT_R16_UNORM: Gt,
      VK_FORMAT_R32G32B32A32_SFLOAT: Ae,
      VK_FORMAT_R32G32B32A32_SINT: Le,
      VK_FORMAT_R32G32B32A32_UINT: Be,
      VK_FORMAT_R32G32B32_SFLOAT: De,
      VK_FORMAT_R32G32B32_SINT: we,
      VK_FORMAT_R32G32B32_UINT: me,
      VK_FORMAT_R32G32_SFLOAT: de,
      VK_FORMAT_R32G32_SINT: be,
      VK_FORMAT_R32G32_UINT: ue,
      VK_FORMAT_R32_SFLOAT: xe,
      VK_FORMAT_R32_SINT: ye,
      VK_FORMAT_R32_UINT: ge,
      VK_FORMAT_R4G4B4A4_UNORM_PACK16: st,
      VK_FORMAT_R4G4_UNORM_PACK8: it,
      VK_FORMAT_R5G5B5A1_UNORM_PACK16: lt,
      VK_FORMAT_R5G6B5_UNORM_PACK16: rt,
      VK_FORMAT_R64G64B64A64_SFLOAT: ze,
      VK_FORMAT_R64G64B64A64_SINT: Ce,
      VK_FORMAT_R64G64B64A64_UINT: Pe,
      VK_FORMAT_R64G64B64_SFLOAT: Fe,
      VK_FORMAT_R64G64B64_SINT: Ee,
      VK_FORMAT_R64G64B64_UINT: Ve,
      VK_FORMAT_R64G64_SFLOAT: Te,
      VK_FORMAT_R64G64_SINT: Oe,
      VK_FORMAT_R64G64_UINT: Ie,
      VK_FORMAT_R64_SFLOAT: Se,
      VK_FORMAT_R64_SINT: ve,
      VK_FORMAT_R64_UINT: ke,
      VK_FORMAT_R8G8B8A8_SINT: Et,
      VK_FORMAT_R8G8B8A8_SNORM: Tt,
      VK_FORMAT_R8G8B8A8_SRGB: Ft,
      VK_FORMAT_R8G8B8A8_UINT: Vt,
      VK_FORMAT_R8G8B8A8_UNORM: Ot,
      VK_FORMAT_R8G8B8_SINT: Bt,
      VK_FORMAT_R8G8B8_SNORM: wt,
      VK_FORMAT_R8G8B8_SRGB: Lt,
      VK_FORMAT_R8G8B8_UINT: Dt,
      VK_FORMAT_R8G8B8_UNORM: mt,
      VK_FORMAT_R8G8_SINT: bt,
      VK_FORMAT_R8G8_SNORM: xt,
      VK_FORMAT_R8G8_SRGB: dt,
      VK_FORMAT_R8G8_UINT: ut,
      VK_FORMAT_R8G8_UNORM: yt,
      VK_FORMAT_R8_SINT: pt,
      VK_FORMAT_R8_SNORM: ht,
      VK_FORMAT_R8_SRGB: gt,
      VK_FORMAT_R8_UINT: _t,
      VK_FORMAT_R8_UNORM: ct,
      VK_FORMAT_S8_UINT: Xe,
      VK_FORMAT_UNDEFINED: nt,
      VK_FORMAT_X8_D24_UNORM_PACK32: He,
      read: Pi,
      write: Mi
    }, Symbol.toStringTag, { value: "Module" }));
    ({
      read: read2,
      KHR_DF_FLAG_ALPHA_PREMULTIPLIED,
      KHR_DF_TRANSFER_SRGB,
      VK_FORMAT_UNDEFINED,
      VK_FORMAT_R16_SFLOAT,
      VK_FORMAT_R16G16_SFLOAT,
      VK_FORMAT_R16G16B16A16_SFLOAT,
      VK_FORMAT_R32_SFLOAT,
      VK_FORMAT_R32G32_SFLOAT,
      VK_FORMAT_R32G32B32A32_SFLOAT,
      VK_FORMAT_R8_SRGB,
      VK_FORMAT_R8_UNORM,
      VK_FORMAT_R8G8_SRGB,
      VK_FORMAT_R8G8_UNORM,
      VK_FORMAT_R8G8B8A8_SRGB,
      VK_FORMAT_R8G8B8A8_UNORM
    } = KTX);
    _taskCache = /* @__PURE__ */ new WeakMap();
    _activeLoaders = 0;
    KTX2Loader = class extends Loader {
      constructor(manager) {
        super(manager);
        this.transcoderPath = "";
        this.transcoderBinary = null;
        this.transcoderPending = null;
        this.workerPool = new WorkerPool();
        this.workerSourceURL = "";
        this.workerConfig = null;
        if (typeof MSC_TRANSCODER !== "undefined") {
          console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
        }
      }
      setTranscoderPath(path) {
        this.transcoderPath = path;
        return this;
      }
      setWorkerLimit(num) {
        this.workerPool.setWorkerLimit(num);
        return this;
      }
      detectSupport(renderer) {
        this.workerConfig = {
          astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
          etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
          etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
          dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
          bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
          pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
        };
        if (renderer.capabilities.isWebGL2) {
          this.workerConfig.etc1Supported = false;
        }
        return this;
      }
      init() {
        if (!this.transcoderPending) {
          const jsLoader = new FileLoader(this.manager);
          jsLoader.setPath(this.transcoderPath);
          jsLoader.setWithCredentials(this.withCredentials);
          const jsContent = jsLoader.loadAsync("basis_transcoder.js");
          const binaryLoader = new FileLoader(this.manager);
          binaryLoader.setPath(this.transcoderPath);
          binaryLoader.setResponseType("arraybuffer");
          binaryLoader.setWithCredentials(this.withCredentials);
          const binaryContent = binaryLoader.loadAsync("basis_transcoder.wasm");
          this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
            const fn2 = KTX2Loader.BasisWorker.toString();
            const body = [
              "/* constants */",
              "let _EngineFormat = " + JSON.stringify(KTX2Loader.EngineFormat),
              "let _TranscoderFormat = " + JSON.stringify(KTX2Loader.TranscoderFormat),
              "let _BasisFormat = " + JSON.stringify(KTX2Loader.BasisFormat),
              "/* basis_transcoder.js */",
              jsContent2,
              "/* worker */",
              fn2.substring(fn2.indexOf("{") + 1, fn2.lastIndexOf("}"))
            ].join("\n");
            this.workerSourceURL = URL.createObjectURL(new Blob([body]));
            this.transcoderBinary = binaryContent2;
            this.workerPool.setWorkerCreator(() => {
              const worker = new Worker(this.workerSourceURL);
              const transcoderBinary = this.transcoderBinary.slice(0);
              worker.postMessage({ type: "init", config: this.workerConfig, transcoderBinary }, [transcoderBinary]);
              return worker;
            });
          });
          if (_activeLoaders > 0) {
            console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances.");
          }
          _activeLoaders++;
        }
        return this.transcoderPending;
      }
      load(url, onLoad, onProgress, onError) {
        if (this.workerConfig === null) {
          throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
        }
        const loader2 = new FileLoader(this.manager);
        loader2.setResponseType("arraybuffer");
        loader2.setWithCredentials(this.withCredentials);
        loader2.load(url, (buffer) => {
          if (_taskCache.has(buffer)) {
            const cachedTask = _taskCache.get(buffer);
            return cachedTask.promise.then(onLoad).catch(onError);
          }
          this._createTexture(buffer).then((texture) => onLoad ? onLoad(texture) : null).catch(onError);
        }, onProgress, onError);
      }
      _createTextureFrom(transcodeResult) {
        const { mipmaps, width, height, format: format2, type, error: error2, dfdTransferFn, dfdFlags } = transcodeResult;
        if (type === "error")
          return Promise.reject(error2);
        const texture = new CompressedTexture(mipmaps, width, height, format2, UnsignedByteType);
        texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
        texture.magFilter = LinearFilter;
        texture.generateMipmaps = false;
        texture.needsUpdate = true;
        texture.encoding = dfdTransferFn === KHR_DF_TRANSFER_SRGB ? sRGBEncoding : LinearEncoding;
        texture.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED);
        return texture;
      }
      _createTexture(buffer, config = {}) {
        const container = read2(new Uint8Array(buffer));
        if (container.vkFormat !== VK_FORMAT_UNDEFINED) {
          return createDataTexture(container);
        }
        const taskConfig = config;
        const texturePending = this.init().then(() => {
          return this.workerPool.postMessage({ type: "transcode", buffer, taskConfig }, [buffer]);
        }).then((e22) => this._createTextureFrom(e22.data));
        _taskCache.set(buffer, { promise: texturePending });
        return texturePending;
      }
      dispose() {
        this.workerPool.dispose();
        if (this.workerSourceURL)
          URL.revokeObjectURL(this.workerSourceURL);
        _activeLoaders--;
        return this;
      }
    };
    KTX2Loader.BasisFormat = {
      ETC1S: 0,
      UASTC_4x4: 1
    };
    KTX2Loader.TranscoderFormat = {
      ETC1: 0,
      ETC2: 1,
      BC1: 2,
      BC3: 3,
      BC4: 4,
      BC5: 5,
      BC7_M6_OPAQUE_ONLY: 6,
      BC7_M5: 7,
      PVRTC1_4_RGB: 8,
      PVRTC1_4_RGBA: 9,
      ASTC_4x4: 10,
      ATC_RGB: 11,
      ATC_RGBA_INTERPOLATED_ALPHA: 12,
      RGBA32: 13,
      RGB565: 14,
      BGR565: 15,
      RGBA4444: 16
    };
    KTX2Loader.EngineFormat = {
      RGBAFormat,
      RGBA_ASTC_4x4_Format,
      RGBA_BPTC_Format,
      RGBA_ETC2_EAC_Format,
      RGBA_PVRTC_4BPPV1_Format,
      RGBA_S3TC_DXT5_Format,
      RGB_ETC1_Format,
      RGB_ETC2_Format,
      RGB_PVRTC_4BPPV1_Format,
      RGB_S3TC_DXT1_Format
    };
    KTX2Loader.BasisWorker = function() {
      let config;
      let transcoderPending;
      let BasisModule;
      const EngineFormat = _EngineFormat;
      const TranscoderFormat = _TranscoderFormat;
      const BasisFormat = _BasisFormat;
      self.addEventListener("message", function(e22) {
        const message = e22.data;
        switch (message.type) {
          case "init":
            config = message.config;
            init2(message.transcoderBinary);
            break;
          case "transcode":
            transcoderPending.then(() => {
              try {
                const { width, height, hasAlpha, mipmaps, format: format2, dfdTransferFn, dfdFlags } = transcode(message.buffer);
                const buffers = [];
                for (let i22 = 0; i22 < mipmaps.length; ++i22) {
                  buffers.push(mipmaps[i22].data.buffer);
                }
                self.postMessage({ type: "transcode", id: message.id, width, height, hasAlpha, mipmaps, format: format2, dfdTransferFn, dfdFlags }, buffers);
              } catch (error2) {
                console.error(error2);
                self.postMessage({ type: "error", id: message.id, error: error2.message });
              }
            });
            break;
        }
      });
      function init2(wasmBinary) {
        transcoderPending = new Promise((resolve2) => {
          BasisModule = { wasmBinary, onRuntimeInitialized: resolve2 };
          BASIS(BasisModule);
        }).then(() => {
          BasisModule.initializeBasis();
          if (BasisModule.KTX2File === void 0) {
            console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
          }
        });
      }
      function transcode(buffer) {
        const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));
        function cleanup() {
          ktx2File.close();
          ktx2File.delete();
        }
        if (!ktx2File.isValid()) {
          cleanup();
          throw new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
        }
        const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
        const width = ktx2File.getWidth();
        const height = ktx2File.getHeight();
        const levels = ktx2File.getLevels();
        const hasAlpha = ktx2File.getHasAlpha();
        const dfdTransferFn = ktx2File.getDFDTransferFunc();
        const dfdFlags = ktx2File.getDFDFlags();
        const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
        if (!width || !height || !levels) {
          cleanup();
          throw new Error("THREE.KTX2Loader:	Invalid texture");
        }
        if (!ktx2File.startTranscoding()) {
          cleanup();
          throw new Error("THREE.KTX2Loader: .startTranscoding failed");
        }
        const mipmaps = [];
        for (let mip = 0; mip < levels; mip++) {
          const levelInfo = ktx2File.getImageLevelInfo(mip, 0, 0);
          const mipWidth = levelInfo.origWidth;
          const mipHeight = levelInfo.origHeight;
          const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, 0, 0, transcoderFormat));
          const status = ktx2File.transcodeImage(dst, mip, 0, 0, transcoderFormat, 0, -1, -1);
          if (!status) {
            cleanup();
            throw new Error("THREE.KTX2Loader: .transcodeImage failed.");
          }
          mipmaps.push({ data: dst, width: mipWidth, height: mipHeight });
        }
        cleanup();
        return { width, height, hasAlpha, mipmaps, format: engineFormat, dfdTransferFn, dfdFlags };
      }
      const FORMAT_OPTIONS = [
        {
          if: "astcSupported",
          basisFormat: [BasisFormat.UASTC_4x4],
          transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
          engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
          priorityETC1S: Infinity,
          priorityUASTC: 1,
          needsPowerOfTwo: false
        },
        {
          if: "bptcSupported",
          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
          transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
          engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
          priorityETC1S: 3,
          priorityUASTC: 2,
          needsPowerOfTwo: false
        },
        {
          if: "dxtSupported",
          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
          transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
          engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
          priorityETC1S: 4,
          priorityUASTC: 5,
          needsPowerOfTwo: false
        },
        {
          if: "etc2Supported",
          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
          transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
          engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
          priorityETC1S: 1,
          priorityUASTC: 3,
          needsPowerOfTwo: false
        },
        {
          if: "etc1Supported",
          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
          transcoderFormat: [TranscoderFormat.ETC1],
          engineFormat: [EngineFormat.RGB_ETC1_Format],
          priorityETC1S: 2,
          priorityUASTC: 4,
          needsPowerOfTwo: false
        },
        {
          if: "pvrtcSupported",
          basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
          transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
          engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
          priorityETC1S: 5,
          priorityUASTC: 6,
          needsPowerOfTwo: true
        }
      ];
      const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a2, b2) {
        return a2.priorityETC1S - b2.priorityETC1S;
      });
      const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a2, b2) {
        return a2.priorityUASTC - b2.priorityUASTC;
      });
      function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
        let transcoderFormat;
        let engineFormat;
        const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
        for (let i22 = 0; i22 < options.length; i22++) {
          const opt = options[i22];
          if (!config[opt.if])
            continue;
          if (!opt.basisFormat.includes(basisFormat))
            continue;
          if (hasAlpha && opt.transcoderFormat.length < 2)
            continue;
          if (opt.needsPowerOfTwo && !(isPowerOfTwo2(width) && isPowerOfTwo2(height)))
            continue;
          transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
          engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
          return { transcoderFormat, engineFormat };
        }
        console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.");
        transcoderFormat = TranscoderFormat.RGBA32;
        engineFormat = EngineFormat.RGBAFormat;
        return { transcoderFormat, engineFormat };
      }
      function isPowerOfTwo2(value) {
        if (value <= 2)
          return true;
        return (value & value - 1) === 0 && value !== 0;
      }
    };
    FORMAT_MAP = {
      [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,
      [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,
      [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,
      [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,
      [VK_FORMAT_R32G32_SFLOAT]: RGFormat,
      [VK_FORMAT_R16G16_SFLOAT]: RGFormat,
      [VK_FORMAT_R8G8_UNORM]: RGFormat,
      [VK_FORMAT_R8G8_SRGB]: RGFormat,
      [VK_FORMAT_R32_SFLOAT]: RedFormat,
      [VK_FORMAT_R16_SFLOAT]: RedFormat,
      [VK_FORMAT_R8_SRGB]: RedFormat,
      [VK_FORMAT_R8_UNORM]: RedFormat
    };
    TYPE_MAP = {
      [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,
      [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,
      [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,
      [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,
      [VK_FORMAT_R32G32_SFLOAT]: FloatType,
      [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,
      [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,
      [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,
      [VK_FORMAT_R32_SFLOAT]: FloatType,
      [VK_FORMAT_R16_SFLOAT]: HalfFloatType,
      [VK_FORMAT_R8_SRGB]: UnsignedByteType,
      [VK_FORMAT_R8_UNORM]: UnsignedByteType
    };
    ENCODING_MAP = {
      [VK_FORMAT_R8G8B8A8_SRGB]: sRGBEncoding,
      [VK_FORMAT_R8G8_SRGB]: sRGBEncoding,
      [VK_FORMAT_R8_SRGB]: sRGBEncoding
    };
    _box$1 = new Box3();
    _vector = new Vector3();
    LineSegmentsGeometry = class extends InstancedBufferGeometry {
      constructor() {
        super();
        this.isLineSegmentsGeometry = true;
        this.type = "LineSegmentsGeometry";
        const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];
        const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];
        const index7 = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
        this.setIndex(index7);
        this.setAttribute("position", new Float32BufferAttribute(positions, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      }
      applyMatrix4(matrix) {
        const start = this.attributes.instanceStart;
        const end = this.attributes.instanceEnd;
        if (start !== void 0) {
          start.applyMatrix4(matrix);
          end.applyMatrix4(matrix);
          start.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
        return this;
      }
      setPositions(array2) {
        let lineSegments;
        if (array2 instanceof Float32Array) {
          lineSegments = array2;
        } else if (Array.isArray(array2)) {
          lineSegments = new Float32Array(array2);
        }
        const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1);
        this.setAttribute("instanceStart", new InterleavedBufferAttribute(instanceBuffer, 3, 0));
        this.setAttribute("instanceEnd", new InterleavedBufferAttribute(instanceBuffer, 3, 3));
        this.computeBoundingBox();
        this.computeBoundingSphere();
        return this;
      }
      setColors(array2) {
        let colors;
        if (array2 instanceof Float32Array) {
          colors = array2;
        } else if (Array.isArray(array2)) {
          colors = new Float32Array(array2);
        }
        const instanceColorBuffer = new InstancedInterleavedBuffer(colors, 6, 1);
        this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(instanceColorBuffer, 3, 0));
        this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute(instanceColorBuffer, 3, 3));
        return this;
      }
      fromWireframeGeometry(geometry) {
        this.setPositions(geometry.attributes.position.array);
        return this;
      }
      fromEdgesGeometry(geometry) {
        this.setPositions(geometry.attributes.position.array);
        return this;
      }
      fromMesh(mesh) {
        this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry));
        return this;
      }
      fromLineSegments(lineSegments) {
        const geometry = lineSegments.geometry;
        this.setPositions(geometry.attributes.position.array);
        return this;
      }
      computeBoundingBox() {
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        const start = this.attributes.instanceStart;
        const end = this.attributes.instanceEnd;
        if (start !== void 0 && end !== void 0) {
          this.boundingBox.setFromBufferAttribute(start);
          _box$1.setFromBufferAttribute(end);
          this.boundingBox.union(_box$1);
        }
      }
      computeBoundingSphere() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        if (this.boundingBox === null) {
          this.computeBoundingBox();
        }
        const start = this.attributes.instanceStart;
        const end = this.attributes.instanceEnd;
        if (start !== void 0 && end !== void 0) {
          const center = this.boundingSphere.center;
          this.boundingBox.getCenter(center);
          let maxRadiusSq = 0;
          for (let i22 = 0, il = start.count; i22 < il; i22++) {
            _vector.fromBufferAttribute(start, i22);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
            _vector.fromBufferAttribute(end, i22);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
          }
          this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
          if (isNaN(this.boundingSphere.radius)) {
            console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
          }
        }
      }
      toJSON() {
      }
      applyMatrix(matrix) {
        console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().");
        return this.applyMatrix4(matrix);
      }
    };
    LineGeometry = class extends LineSegmentsGeometry {
      constructor() {
        super();
        this.isLineGeometry = true;
        this.type = "LineGeometry";
      }
      setPositions(array2) {
        const length = array2.length - 3;
        const points = new Float32Array(2 * length);
        for (let i22 = 0; i22 < length; i22 += 3) {
          points[2 * i22] = array2[i22];
          points[2 * i22 + 1] = array2[i22 + 1];
          points[2 * i22 + 2] = array2[i22 + 2];
          points[2 * i22 + 3] = array2[i22 + 3];
          points[2 * i22 + 4] = array2[i22 + 4];
          points[2 * i22 + 5] = array2[i22 + 5];
        }
        super.setPositions(points);
        return this;
      }
      setColors(array2) {
        const length = array2.length - 3;
        const colors = new Float32Array(2 * length);
        for (let i22 = 0; i22 < length; i22 += 3) {
          colors[2 * i22] = array2[i22];
          colors[2 * i22 + 1] = array2[i22 + 1];
          colors[2 * i22 + 2] = array2[i22 + 2];
          colors[2 * i22 + 3] = array2[i22 + 3];
          colors[2 * i22 + 4] = array2[i22 + 4];
          colors[2 * i22 + 5] = array2[i22 + 5];
        }
        super.setColors(colors);
        return this;
      }
      fromLine(line) {
        const geometry = line.geometry;
        this.setPositions(geometry.attributes.position.array);
        return this;
      }
    };
    UniformsLib.line = {
      worldUnits: { value: 1 },
      linewidth: { value: 1 },
      resolution: { value: new Vector2(1, 1) },
      dashOffset: { value: 0 },
      dashScale: { value: 1 },
      dashSize: { value: 1 },
      gapSize: { value: 1 }
    };
    ShaderLib["line"] = {
      uniforms: UniformsUtils.merge([
        UniformsLib.common,
        UniformsLib.fog,
        UniformsLib.line
      ]),
      vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
      fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
    };
    LineMaterial = class extends ShaderMaterial {
      constructor(parameters) {
        super({
          type: "LineMaterial",
          uniforms: UniformsUtils.clone(ShaderLib["line"].uniforms),
          vertexShader: ShaderLib["line"].vertexShader,
          fragmentShader: ShaderLib["line"].fragmentShader,
          clipping: true
        });
        this.isLineMaterial = true;
        Object.defineProperties(this, {
          color: {
            enumerable: true,
            get: function() {
              return this.uniforms.diffuse.value;
            },
            set: function(value) {
              this.uniforms.diffuse.value = value;
            }
          },
          worldUnits: {
            enumerable: true,
            get: function() {
              return "WORLD_UNITS" in this.defines;
            },
            set: function(value) {
              if (value === true) {
                this.defines.WORLD_UNITS = "";
              } else {
                delete this.defines.WORLD_UNITS;
              }
            }
          },
          linewidth: {
            enumerable: true,
            get: function() {
              return this.uniforms.linewidth.value;
            },
            set: function(value) {
              this.uniforms.linewidth.value = value;
            }
          },
          dashed: {
            enumerable: true,
            get: function() {
              return Boolean("USE_DASH" in this.defines);
            },
            set(value) {
              if (Boolean(value) !== Boolean("USE_DASH" in this.defines)) {
                this.needsUpdate = true;
              }
              if (value === true) {
                this.defines.USE_DASH = "";
              } else {
                delete this.defines.USE_DASH;
              }
            }
          },
          dashScale: {
            enumerable: true,
            get: function() {
              return this.uniforms.dashScale.value;
            },
            set: function(value) {
              this.uniforms.dashScale.value = value;
            }
          },
          dashSize: {
            enumerable: true,
            get: function() {
              return this.uniforms.dashSize.value;
            },
            set: function(value) {
              this.uniforms.dashSize.value = value;
            }
          },
          dashOffset: {
            enumerable: true,
            get: function() {
              return this.uniforms.dashOffset.value;
            },
            set: function(value) {
              this.uniforms.dashOffset.value = value;
            }
          },
          gapSize: {
            enumerable: true,
            get: function() {
              return this.uniforms.gapSize.value;
            },
            set: function(value) {
              this.uniforms.gapSize.value = value;
            }
          },
          opacity: {
            enumerable: true,
            get: function() {
              return this.uniforms.opacity.value;
            },
            set: function(value) {
              this.uniforms.opacity.value = value;
            }
          },
          resolution: {
            enumerable: true,
            get: function() {
              return this.uniforms.resolution.value;
            },
            set: function(value) {
              this.uniforms.resolution.value.copy(value);
            }
          },
          alphaToCoverage: {
            enumerable: true,
            get: function() {
              return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
            },
            set: function(value) {
              if (Boolean(value) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines)) {
                this.needsUpdate = true;
              }
              if (value === true) {
                this.defines.USE_ALPHA_TO_COVERAGE = "";
                this.extensions.derivatives = true;
              } else {
                delete this.defines.USE_ALPHA_TO_COVERAGE;
                this.extensions.derivatives = false;
              }
            }
          }
        });
        this.setValues(parameters);
      }
    };
    _start = new Vector3();
    _end = new Vector3();
    _start4 = new Vector4();
    _end4 = new Vector4();
    _ssOrigin = new Vector4();
    _ssOrigin3 = new Vector3();
    _mvMatrix = new Matrix4();
    _line = new Line3();
    _closestPoint = new Vector3();
    _box = new Box3();
    _sphere = new Sphere();
    _clipToWorldVector = new Vector4();
    LineSegments2 = class extends Mesh$1 {
      constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 16777215 })) {
        super(geometry, material);
        this.isLineSegments2 = true;
        this.type = "LineSegments2";
      }
      computeLineDistances() {
        const geometry = this.geometry;
        const instanceStart = geometry.attributes.instanceStart;
        const instanceEnd = geometry.attributes.instanceEnd;
        const lineDistances = new Float32Array(2 * instanceStart.count);
        for (let i22 = 0, j2 = 0, l2 = instanceStart.count; i22 < l2; i22++, j2 += 2) {
          _start.fromBufferAttribute(instanceStart, i22);
          _end.fromBufferAttribute(instanceEnd, i22);
          lineDistances[j2] = j2 === 0 ? 0 : lineDistances[j2 - 1];
          lineDistances[j2 + 1] = lineDistances[j2] + _start.distanceTo(_end);
        }
        const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);
        geometry.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));
        geometry.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));
        return this;
      }
      raycast(raycaster, intersects) {
        const worldUnits = this.material.worldUnits;
        const camera = raycaster.camera;
        if (camera === null && !worldUnits) {
          console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
        }
        const threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;
        _ray = raycaster.ray;
        const matrixWorld = this.matrixWorld;
        const geometry = this.geometry;
        const material = this.material;
        _lineWidth = material.linewidth + threshold;
        _instanceStart = geometry.attributes.instanceStart;
        _instanceEnd = geometry.attributes.instanceEnd;
        if (geometry.boundingSphere === null) {
          geometry.computeBoundingSphere();
        }
        _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);
        let sphereMargin;
        if (worldUnits) {
          sphereMargin = _lineWidth * 0.5;
        } else {
          const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));
          sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);
        }
        _sphere.radius += sphereMargin;
        if (_ray.intersectsSphere(_sphere) === false) {
          return;
        }
        if (geometry.boundingBox === null) {
          geometry.computeBoundingBox();
        }
        _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);
        let boxMargin;
        if (worldUnits) {
          boxMargin = _lineWidth * 0.5;
        } else {
          const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));
          boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);
        }
        _box.expandByScalar(boxMargin);
        if (_ray.intersectsBox(_box) === false) {
          return;
        }
        if (worldUnits) {
          raycastWorldUnits(this, intersects);
        } else {
          raycastScreenSpace(this, camera, intersects);
        }
      }
    };
    Line2$1 = class extends LineSegments2 {
      constructor(geometry = new LineGeometry(), material = new LineMaterial({ color: Math.random() * 16777215 })) {
        super(geometry, material);
        this.isLine2 = true;
        this.type = "Line2";
      }
    };
    Line2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { position = void 0 } = $$props;
      let { scale = void 0 } = $$props;
      let { rotation = void 0 } = $$props;
      let { viewportAware = false } = $$props;
      let { inViewport = false } = $$props;
      let { castShadow = void 0 } = $$props;
      let { receiveShadow = void 0 } = $$props;
      let { frustumCulled = void 0 } = $$props;
      let { renderOrder = void 0 } = $$props;
      let { visible = void 0 } = $$props;
      let { interactive = false } = $$props;
      let { ignorePointer = false } = $$props;
      let { lookAt = void 0 } = $$props;
      let { points = [] } = $$props;
      let { material } = $$props;
      const geometry = new LineGeometry();
      const pointTuples = points.map((p2) => p2 instanceof Vector3 ? p2.toArray() : p2);
      geometry.setPositions(pointTuples.flat());
      const line2 = new Line2$1(geometry, material);
      line2.computeLineDistances();
      onDestroy(() => {
        geometry.dispose();
      });
      const getLine = () => line2;
      const { invalidate } = useThrelte();
      let previousMaterial = material;
      let previousPoints = points;
      if ($$props.position === void 0 && $$bindings.position && position !== void 0)
        $$bindings.position(position);
      if ($$props.scale === void 0 && $$bindings.scale && scale !== void 0)
        $$bindings.scale(scale);
      if ($$props.rotation === void 0 && $$bindings.rotation && rotation !== void 0)
        $$bindings.rotation(rotation);
      if ($$props.viewportAware === void 0 && $$bindings.viewportAware && viewportAware !== void 0)
        $$bindings.viewportAware(viewportAware);
      if ($$props.inViewport === void 0 && $$bindings.inViewport && inViewport !== void 0)
        $$bindings.inViewport(inViewport);
      if ($$props.castShadow === void 0 && $$bindings.castShadow && castShadow !== void 0)
        $$bindings.castShadow(castShadow);
      if ($$props.receiveShadow === void 0 && $$bindings.receiveShadow && receiveShadow !== void 0)
        $$bindings.receiveShadow(receiveShadow);
      if ($$props.frustumCulled === void 0 && $$bindings.frustumCulled && frustumCulled !== void 0)
        $$bindings.frustumCulled(frustumCulled);
      if ($$props.renderOrder === void 0 && $$bindings.renderOrder && renderOrder !== void 0)
        $$bindings.renderOrder(renderOrder);
      if ($$props.visible === void 0 && $$bindings.visible && visible !== void 0)
        $$bindings.visible(visible);
      if ($$props.interactive === void 0 && $$bindings.interactive && interactive !== void 0)
        $$bindings.interactive(interactive);
      if ($$props.ignorePointer === void 0 && $$bindings.ignorePointer && ignorePointer !== void 0)
        $$bindings.ignorePointer(ignorePointer);
      if ($$props.lookAt === void 0 && $$bindings.lookAt && lookAt !== void 0)
        $$bindings.lookAt(lookAt);
      if ($$props.points === void 0 && $$bindings.points && points !== void 0)
        $$bindings.points(points);
      if ($$props.material === void 0 && $$bindings.material && material !== void 0)
        $$bindings.material(material);
      if ($$props.line2 === void 0 && $$bindings.line2 && line2 !== void 0)
        $$bindings.line2(line2);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        {
          {
            if (material !== previousMaterial) {
              getLine().material = material;
              invalidate("Line2: material changed");
            } else {
              invalidate("Line2: material props changed");
            }
            previousMaterial = material;
          }
        }
        {
          {
            if (points !== previousPoints) {
              const pointTuples2 = points.map((p2) => p2 instanceof Vector3 ? p2.toArray() : p2);
              geometry.setPositions(pointTuples2.flat());
              line2.computeLineDistances();
              invalidate("Line2: points changed");
              previousPoints = points;
            }
          }
        }
        $$rendered = `${validate_component(MeshInstance, "MeshInstance").$$render($$result, {
          mesh: line2,
          position,
          scale,
          rotation,
          lookAt,
          castShadow,
          receiveShadow,
          frustumCulled,
          renderOrder,
          visible,
          interactive,
          ignorePointer,
          viewportAware,
          inViewport
        }, {
          inViewport: ($$value) => {
            inViewport = $$value;
            $$settled = false;
          }
        }, {
          default: () => {
            return `${slots.default ? slots.default({}) : ``}`;
          }
        })}`;
      } while (!$$settled);
      return $$rendered;
    });
    loader = useLoader(TextureLoader, () => new TextureLoader());
    loadTexture = (path, options) => {
      return loader.load(path, (t22) => {
        var _a;
        invalidateGlobally("useTexture");
        (_a = options == null ? void 0 : options.onLoad) == null ? void 0 : _a.call(options, t22);
      }, (e22) => {
        var _a;
        (_a = options == null ? void 0 : options.onProgress) == null ? void 0 : _a.call(options, e22);
      }, (e22) => {
        var _a;
        (_a = options == null ? void 0 : options.onError) == null ? void 0 : _a.call(options, e22);
      });
    };
    pathsIsString = (paths) => {
      return typeof paths === "string";
    };
    pathsIsArray = (paths) => {
      return Array.isArray(paths);
    };
    convertTextureColor = (texture) => {
      try {
        const rootCtx = useThrelteRoot();
        if (!rootCtx)
          return texture;
        if (!get_store_value(rootCtx.linear))
          texture.encoding = sRGBEncoding;
      } catch (error2) {
        console.warn("Calling useTexture outside component initialization does not support color correction.");
      }
      return texture;
    };
    px = "/_app/immutable/assets/px-ccf06248.png";
    px_upside = "/_app/immutable/assets/px_upside-3099a451.png";
    py = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAgcSURBVHgB7dYBAQAQAMAwpBVAaC0I8i3F5j73DQAgZQ0AIEcAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIOgD+H8Gw7HU/A8AAAAASUVORK5CYII=";
    pz = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAgcSURBVHgB7dYBAQAQAMAwpBVAaC0I8i3F5j73DQAgZQ0AIEcAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIOgD+H8Gw7HU/A8AAAAASUVORK5CYII=";
    ny = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAgcSURBVHgB7dYBAQAQAMAwpBVAaC0I8i3F5j73DQAgZQ0AIEcAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIOgD+H8Gw7HU/A8AAAAASUVORK5CYII=";
    nz = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAgcSURBVHgB7dYBAQAQAMAwpBVAaC0I8i3F5j73DQAgZQ0AIEcAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIEgAACBIAAAgSAAAIOgD+H8Gw7HU/A8AAAAASUVORK5CYII=";
    o_px = "/_app/immutable/assets/px_white-ad697628.png";
    o_px_transparent = "/_app/immutable/assets/px-27500c70.png";
    o_px_upside = "/_app/immutable/assets/px_upside_white-09c7c397.png";
    o_px_upside_transparent = "/_app/immutable/assets/px_upside-dec6acd7.png";
    o_ny = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAgYSURBVHgB7dYBAQAgDMCga//O+h6DFJy3BgBIuQMA5AgAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABAkAAAQJAAAECQAABH2OOQf84N9lUwAAAABJRU5ErkJggg==";
    o_transparent = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAQPSURBVHgB7cAxAQAAAMKg9U9tB28oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4DQLwAAFZXWxSAAAAAElFTkSuQmCC";
    ShaderChunk["meshline_vert"] = [
      "",
      "#include <common>",
      "",
      ShaderChunk.logdepthbuf_pars_vertex,
      ShaderChunk.fog_pars_vertex,
      "",
      "attribute vec3 previous;",
      "attribute vec3 next;",
      "attribute float side;",
      "attribute float width;",
      "attribute float counters;",
      "",
      "uniform vec2 resolution;",
      "uniform float lineWidth;",
      "uniform vec3 color;",
      "uniform float opacity;",
      "uniform float sizeAttenuation;",
      "",
      "varying vec2 vUV;",
      "varying vec4 vColor;",
      "varying float vCounters;",
      "",
      "vec2 fix( vec4 i, float aspect ) {",
      "",
      "    vec2 res = i.xy / i.w;",
      "    res.x *= aspect;",
      "	 vCounters = counters;",
      "    return res;",
      "",
      "}",
      "",
      "void main() {",
      "",
      "    float aspect = resolution.x / resolution.y;",
      "",
      "    vColor = vec4( color, opacity );",
      "    vUV = uv;",
      "",
      "    mat4 m = projectionMatrix * modelViewMatrix;",
      "    vec4 finalPosition = m * vec4( position, 1.0 );",
      "    vec4 prevPos = m * vec4( previous, 1.0 );",
      "    vec4 nextPos = m * vec4( next, 1.0 );",
      "",
      "    vec2 currentP = fix( finalPosition, aspect );",
      "    vec2 prevP = fix( prevPos, aspect );",
      "    vec2 nextP = fix( nextPos, aspect );",
      "",
      "    float w = lineWidth * width;",
      "",
      "    vec2 dir;",
      "    if( nextP == currentP ) dir = normalize( currentP - prevP );",
      "    else if( prevP == currentP ) dir = normalize( nextP - currentP );",
      "    else {",
      "        vec2 dir1 = normalize( currentP - prevP );",
      "        vec2 dir2 = normalize( nextP - currentP );",
      "        dir = normalize( dir1 + dir2 );",
      "",
      "        vec2 perp = vec2( -dir1.y, dir1.x );",
      "        vec2 miter = vec2( -dir.y, dir.x );",
      "        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );",
      "",
      "    }",
      "",
      "    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;",
      "    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );",
      "    normal.xy *= .5 * w;",
      "    normal *= projectionMatrix;",
      "    if( sizeAttenuation == 0. ) {",
      "        normal.xy *= finalPosition.w;",
      "        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;",
      "    }",
      "",
      "    finalPosition.xy += normal.xy * side;",
      "",
      "    gl_Position = finalPosition;",
      "",
      ShaderChunk.logdepthbuf_vertex,
      ShaderChunk.fog_vertex && "    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
      ShaderChunk.fog_vertex,
      "}"
    ].join("\n");
    ShaderChunk["meshline_frag"] = [
      "",
      ShaderChunk.fog_pars_fragment,
      ShaderChunk.logdepthbuf_pars_fragment,
      "",
      "uniform sampler2D map;",
      "uniform sampler2D alphaMap;",
      "uniform float useMap;",
      "uniform float useAlphaMap;",
      "uniform float useDash;",
      "uniform float dashArray;",
      "uniform float dashOffset;",
      "uniform float dashRatio;",
      "uniform float visibility;",
      "uniform float alphaTest;",
      "uniform vec2 repeat;",
      "",
      "varying vec2 vUV;",
      "varying vec4 vColor;",
      "varying float vCounters;",
      "",
      "void main() {",
      "",
      ShaderChunk.logdepthbuf_fragment,
      "",
      "    vec4 c = vColor;",
      "    if( useMap == 1. ) c *= texture2D( map, vUV * repeat );",
      "    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV * repeat ).a;",
      "    if( c.a < alphaTest ) discard;",
      "    if( useDash == 1. ){",
      "        c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));",
      "    }",
      "    gl_FragColor = c;",
      "    gl_FragColor.a *= step(vCounters, visibility);",
      "",
      ShaderChunk.fog_fragment,
      "}"
    ].join("\n");
    useCursor = (onPointerOver = "pointer", onPointerOut = "auto") => {
      let hovering = false;
      const hoveringStore = writable2(false);
      const onPointerEnter = () => {
        hoveringStore.set(true);
      };
      const onPointerLeave = () => {
        hoveringStore.set(false);
      };
      if (typeof window === "undefined") {
        return {
          hovering: hoveringStore,
          onPointerEnter,
          onPointerLeave
        };
      }
      let el = document.body;
      const rootCtx = useThrelte();
      if (rootCtx && rootCtx.renderer)
        el = rootCtx.renderer.domElement;
      let onPointerOverValue = typeof onPointerOver === "string" ? onPointerOver : get_store_value(onPointerOver);
      if (typeof onPointerOver !== "string") {
        const unsubscribeOnPointerOver = onPointerOver.subscribe((cursorStyle) => {
          onPointerOverValue = cursorStyle;
          if (hovering) {
            el.style.cursor = cursorStyle;
          }
        });
        onDestroy(unsubscribeOnPointerOver);
      }
      let onPointerOutValue = typeof onPointerOut === "string" ? onPointerOut : get_store_value(onPointerOut);
      if (typeof onPointerOut !== "string") {
        const unsubscribeOnPointerOut = onPointerOut.subscribe((cursorStyle) => {
          onPointerOutValue = cursorStyle;
          if (!hovering) {
            el.style.cursor = cursorStyle;
          }
        });
        onDestroy(unsubscribeOnPointerOut);
      }
      const unsubscribeHovering = hoveringStore.subscribe((isHovering) => {
        hovering = isHovering;
        if (isHovering) {
          el.style.cursor = onPointerOverValue;
        } else {
          el.style.cursor = onPointerOutValue;
        }
      });
      onDestroy(unsubscribeHovering);
      onDestroy(() => {
        el.style.cursor = onPointerOutValue;
      });
      return {
        hovering: hoveringStore,
        onPointerEnter,
        onPointerLeave
      };
    };
    new Vector3();
    new Vector3();
    new Vector3();
    SHOW_INSIDE = false;
    Game = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let logoMaterial;
      let holdingMaterial;
      let boxHeight;
      let $scale, $$unsubscribe_scale;
      let $logoFade, $$unsubscribe_logoFade;
      let $fovScale, $$unsubscribe_fovScale;
      let $logoRotate, $$unsubscribe_logoRotate;
      let boxMesh, logoCamera;
      logoActive.subscribe((value) => {
      });
      new MeshBasicMaterial();
      const texture = useTexture([pz, py, px, px_upside, ny, nz]);
      const textureOppositeOpaque = useTexture([o_ny, o_ny, o_px, o_px_upside, o_ny, o_ny]);
      useTexture([
        o_transparent,
        o_transparent,
        o_px_transparent,
        o_px_upside_transparent,
        o_transparent,
        o_transparent
      ]);
      const textureOpposite = textureOppositeOpaque;
      let scale = spring(0.4, {});
      $$unsubscribe_scale = subscribe(scale, (value) => $scale = value);
      let fovScale = spring(1.6, {});
      $$unsubscribe_fovScale = subscribe(fovScale, (value) => $fovScale = value);
      const logoRotate = tweened(0, { duration: 60, easing: identity });
      $$unsubscribe_logoRotate = subscribe(logoRotate, (value) => $logoRotate = value);
      const logoFade = spring(1, { duration: 1e3, easing: cubicIn });
      $$unsubscribe_logoFade = subscribe(logoFade, (value) => $logoFade = value);
      new MeshBasicMaterial({
        map: textureOpposite[0],
        transparent: true
      });
      new PlaneGeometry(1, 1);
      let canvasEl;
      useCursor();
      let controls;
      new TextureLoader();
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        {
          {
            logoFade.set(1);
          }
        }
        logoMaterial = texture.map((el) => new MeshPhongMaterial({
          shininess: 10,
          transparent: true,
          opacity: $logoFade,
          color: "#ffffff",
          map: el,
          flatShading: true
        }));
        holdingMaterial = textureOpposite.map((el) => new MeshPhongMaterial({ map: el, transparent: SHOW_INSIDE }));
        boxHeight = 1.7 - $scale / 2;
        $$rendered = `


${validate_component(Canvas, "Canvas").$$render($$result, {
          linear: true,
          rendererParameters: { antialias: true, precision: "lowp" },
          flat: true,
          size: { width: 400, height: 400 },
          this: canvasEl
        }, {
          this: ($$value) => {
            canvasEl = $$value;
            $$settled = false;
          }
        }, {
          default: () => {
            return `
  

  
  
  ${validate_component(PerspectiveCamera, "PerspectiveCamera").$$render($$result, {
              position: {
                x: 16 / (350 / 400),
                y: 6 / (350 / 400),
                z: 16 / (350 / 400)
              },
              fov: $fovScale,
              lookAt: { y: -2, x: 0, z: 0 },
              camera: logoCamera
            }, {
              camera: ($$value) => {
                logoCamera = $$value;
                $$settled = false;
              }
            }, {
              default: () => {
                return `${validate_component(OrbitControls, "OrbitControls").$$render($$result, {
                  autoRotate: false,
                  enableRotate: true,
                  maxAzimuthAngle: Infinity,
                  minAzimuthAngle: -Infinity,
                  enablePan: false,
                  enableDamping: true,
                  enableZoom: false,
                  target: { y: 0.5 },
                  controls
                }, {
                  controls: ($$value) => {
                    controls = $$value;
                    $$settled = false;
                  }
                }, {})}`;
              }
            })}

  ${validate_component(SpotLight, "SpotLight").$$render($$result, {
              power: 6,
              intensity: 0.21,
              penumbra: 0.5,
              target: boxMesh,
              position: { x: 200, y: 200, z: 200 }
            }, {}, {})}
  ${validate_component(SpotLight, "SpotLight").$$render($$result, {
              power: 6,
              intensity: 0.21,
              penumbra: 0.5,
              target: boxMesh,
              position: { x: -200, y: 200, z: 200 }
            }, {}, {})}
  ${validate_component(SpotLight, "SpotLight").$$render($$result, {
              power: 6,
              intensity: 0.21,
              penumbra: 0.5,
              target: boxMesh,
              position: { x: 200, y: 200, z: -200 }
            }, {}, {})}
  ${validate_component(SpotLight, "SpotLight").$$render($$result, {
              power: 6,
              intensity: 0.21,
              penumbra: 0.5,
              target: boxMesh,
              position: { x: -200, y: 200, z: -200 }
            }, {}, {})}
  ${validate_component(SpotLight, "SpotLight").$$render($$result, {
              power: 6,
              intensity: 0.21,
              penumbra: 0.5,
              target: boxMesh,
              position: { x: 200, y: -200, z: 200 }
            }, {}, {})}
  ${validate_component(SpotLight, "SpotLight").$$render($$result, {
              power: 6,
              intensity: 0.21,
              penumbra: 0.5,
              target: boxMesh,
              position: { x: -200, y: -200, z: 200 }
            }, {}, {})}
  ${validate_component(SpotLight, "SpotLight").$$render($$result, {
              power: 6,
              intensity: 0.21,
              penumbra: 0.5,
              target: boxMesh,
              position: { x: 200, y: -200, z: -200 }
            }, {}, {})}
  ${validate_component(SpotLight, "SpotLight").$$render($$result, {
              power: 6,
              intensity: 0.21,
              penumbra: 0.5,
              target: boxMesh,
              position: { x: -200, y: -200, z: -200 }
            }, {}, {})}


  ${validate_component(AmbientLight, "AmbientLight").$$render($$result, { intensity: 0.5 }, {}, {})}


  
  ${validate_component(Group, "Group").$$render($$result, {
              scale: 0.3 + $scale / 10,
              rotation: { y: $logoRotate }
            }, {}, {
              default: () => {
                return `${``}

    ${$logoFade < 1 ? `${validate_component(Mesh, "MeshT").$$render($$result, {
                  interactive: true,
                  receiveShadow: true,
                  position: { y: boxHeight },
                  rotation: { x: 1.5708 },
                  castShadow: true,
                  geometry: new BoxGeometry(1, 1, 1),
                  material: holdingMaterial
                }, {}, {})}` : ``}

    ${$logoFade > 0 ? `${validate_component(Mesh, "MeshT").$$render($$result, {
                  interactive: true,
                  receiveShadow: true,
                  position: { y: boxHeight },
                  rotation: { x: 1.5708 },
                  castShadow: true,
                  geometry: new BoxGeometry(1, 1, 1),
                  material: logoMaterial
                }, {}, {})}` : ``}

    ${validate_component(Line2, "Line2").$$render($$result, {
                  points: cube(1.004),
                  position: { x: 0, y: boxHeight, z: 0 },
                  scale: 1,
                  material: new LineMaterial({
                    worldUnits: true,
                    color: "#C3C7F6",
                    linewidth: 0.017 * (($scale + 1) / 4)
                  })
                }, {}, {})}
    ${``}`;
              }
            })}`;
          }
        })}`;
      } while (!$$settled);
      $$unsubscribe_scale();
      $$unsubscribe_logoFade();
      $$unsubscribe_fovScale();
      $$unsubscribe_logoRotate();
      return $$rendered;
    });
    Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let logoActiveVal;
      logoActive.subscribe((value) => {
        logoActiveVal = value;
      });
      return `${validate_component(Page, "Page").$$render($$result, { home: "true" }, {}, {
        default: () => {
          return `
  <div class="${"relative block [height:80vh] mx-auto max-w-[86rem]"}"><div class="${"mt-20 sm:mt-32 md:mt-60 px-4 lg:px-16 block md:flex flex-row justify-between w-full h-full"}"><div class="${"justify-center flex w-full basis-full md:basis-2/3 lg:basis-3/5 sm:mr-10 px-4 lg:px-0"}"><div class="${"container max-w-xl z-10"}"><p class="${"text-4xl sm:text-5xl lg:text-6xl font-vollkorn font-light text-primary"}">Your Mental Toolbox</p>
          <p class="${"text-lg text-black font-baloo2 font-extralight sm:max-w-prose mb-3 text-primary sm:pl-1.5 mt-8"}">We all deal with stress and anxiety in our lives but most of us don&#39;t know how to effectively let go of
            it.
          </p>
          <p class="${"mb-10 text-lg text-black font-baloo2 font-extralight sm:max-w-prose text-primary mt-6 sm:mt-0 sm:pl-1.5"}">PeaceBox is like a toolbox for your mind with the tools and techniques you need to relax and de-stress.
          </p>
          <div class="${"flex flex-col sm:flex-row items-center justify-center sm:justify-between flex-wrap lg:flex-nowrap"}"><div class="${"flex flex-row items-center justify-center sm:justify-between"}"><a href="${" https://apps.apple.com/us/app/peacebox-tools-for-your-mind/id1592436336"}" aria-label="${"Visit PeaceBox on the Appstore"}"><img${add_attribute("src", ___ASSET___0, 0)} class="${"w-44 borderAppStore min-w-32"}"></a>
              <a href="${"https://play.google.com/store/apps/details?id=com.neiltools&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1"}"><img class="${"w-60 min-w-40"}" alt="${"Get it on Google Play"}" src="${"https://play.google.com/intl/en_us/badges/static/images/badges/en_badge_web_generic.png"}"></a></div>
            <div class="${"mt-4 sm:mt-0"}">${validate_component(Github_button, "GithubButton").$$render($$result, {}, {}, {})}</div></div></div></div>
      <div id="${"boxTrigger"}" class="${"disableSelect opacity-90 md:opacity-100 justify-center w-full flex md:basis-1/3 lg:basis-2/5"}" style="${"min-height: 400px; min-width: 400px"}">
        
        
        
        
        
        
        
        
        

        
        
        
        
        

        
        

        <div class="${"disableSelect scale-75 opacity-90 md:opacity-100 md:scale-100 justify-center w-full relative md:basis-1/3 lg:basis-2/5"}"><div class="${"relative md:w-full md:h-full lg:h-72 lg:w-72 rounded-5xl lg:rounded-6xl logoMain opacityLogo logoContainer"}"><div id="${"boxCanvas"}">${logoActiveVal <= 2 ? `${validate_component(Logo_anim, "LogoAnim").$$render($$result, { active: logoActiveVal }, {}, {})}` : ``}
              ${logoActiveVal >= 2 ? `<div class="${[
            "absolute block justify-center items-center",
            logoActiveVal <= 2 ? "opacity-0" : ""
          ].join(" ").trim()}" style="${"width: 400px; height: 400px"}">${validate_component(Game, "Game").$$render($$result, {}, {}, {})}</div>` : ``}</div></div></div></div></div></div>

  
  <div class="${"my-80 mt-96 md:mt-72"}"><div class="${"sm:px-4 lg:px-4 flex flex-col md:flex-row justify-between items-center justify-center w-full"}" id="${"section2"}"><div class="${"disableSelect z-0 items-center sm:-translate-y-3 md:-translate-y-0 md:mt-10 w-3/2 sm:w-full flex md:fixed md:relative basis-full md:basis-1/2"}"><div class="${"rounded-5xl lg:rounded-6xl mx-auto absolute smallTapes md:tapesImage"}">
          
          
          <img${add_attribute("src", ___ASSET___1, 0)}></div></div>

      <div class="${"justify-center relative flex basis-1/2 px-4 lg:px,-0 mx-4 z-10 sm:mr-5 mobileCard"}" id="${"section2Card"}"><div class="${"container w-full md:w-fit md:max-w-xl"}"><p class="${"text-5xl sm:text-6xl lg:text-6xl font-vollkorn font-light text-primary sm:whitespace-nowrap"}">Don&#39;t
            Pay for Peace\xA0
            <i class="${"fa-solid fa-hand-peace fa-sm"}"></i></p>
          <p class="${"text-lg font-baloo2 font-extralight sm:max-w-prose mt-8 mb-3 text-primary sm:pl-1.5"}">With journaling tools, breathing exercises, and audio meditation tapes, you&#39;ll always have your mental
            toolbox in your back pocket
          </p>
          <p class="${"text-lg font-vollkorn font-extralight sm:max-w-prose mt-8 mb-3 text-primary sm:pl-1.5"}">PeaceBox is completely <strong class="${"font-bold"}">free</strong> and will never have ads. Content and tools
            are available to all users free of cost.
          </p>
          <div class="${"flex-row flex align-middle items-center sm:pl-1.5 mt-8 max-w-sm md:max-w-full"}"><a href="${"https://apps.apple.com/us/app/peacebox-tools-for-your-mind/id1592436336"}" aria-label="${"Visit PeaceBox on the Appstore"}"><img${add_attribute("src", ___ASSET___0, 0)} class="${"w-44 borderAppStore min-w-32"}"></a>
            <a href="${"https://play.google.com/store/apps/details?id=com.neiltools&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1"}"><img class="${"w-60 min-w-40 ml-4"}" alt="${"Get it on Google Play"}" src="${"https://play.google.com/intl/en_us/badges/static/images/badges/en_badge_web_generic.png"}"></a></div></div></div></div>

    <div class="${"my-80 mt-96 md:mt-72 flex justify-center"}">${validate_component(Writing_pad, "WritingPad").$$render($$result, { size: 6 }, {}, {})}</div>
    
    
    
    

    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    </div>`;
        }
      })}`;
    });
  }
});

// .svelte-kit/output/server/nodes/2.js
var __exports3 = {};
__export(__exports3, {
  css: () => css4,
  entry: () => entry3,
  index: () => index3,
  js: () => js3,
  module: () => index_svelte_exports
});
var index3, entry3, js3, css4;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/2.js"() {
    init_shims();
    init_index_svelte();
    index3 = 2;
    entry3 = "pages/index.svelte-5b004dd4.js";
    js3 = ["pages/index.svelte-5b004dd4.js", "chunks/index-fb8c27ab.js", "chunks/page-dbb5658c.js", "chunks/github_button-0f6de72f.js", "chunks/index-5606ccfd.js"];
    css4 = ["assets/pages/index.svelte-0c50f9fd.css", "assets/page-945bcade.css"];
  }
});

// .svelte-kit/output/server/entries/pages/license.svelte.js
var license_svelte_exports = {};
__export(license_svelte_exports, {
  default: () => License
});
var License;
var init_license_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/license.svelte.js"() {
    init_shims();
    init_index_7a55addd();
    init_page_0c511438();
    init_github_button_7b97a99c();
    License = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Page, "Page").$$render($$result, { home: "false" }, {}, {
        default: () => {
          return `<div class="${"mx-auto my-20 max-w-5xl mt-24 font-baloo2 px-20"}"><div class="${"mb-10"}">${validate_component(Github_button, "GithubButton").$$render($$result, {}, {}, {})}</div>

    <h1 class="${"font-vollkorn text-3xl my-6"}"><strong>Source Code Licensing</strong></h1>


    <h1 class="${"font-vollkorn text-2xl"}">Mozilla Public License Version 2.0</h1>
    <h2 id="${"1-definitions"}">1. Definitions</h2>
    <p class="${"my-4"}">1.1. &quot;Contributor&quot;
      means each individual or legal entity that creates, contributes to
      the creation of, or owns Covered Software.</p>
    <p class="${"my-4"}">1.2. &quot;Contributor Version&quot;
      means the combination of the Contributions of others (if any) used
      by a Contributor and that particular Contributor&#39;s Contribution.</p>
    <p class="${"my-4"}">1.3. &quot;Contribution&quot;
      means Covered Software of a particular Contributor.</p>
    <p class="${"my-4"}">1.4. &quot;Covered Software&quot;
      means Source Code Form to which the initial Contributor has attached
      the notice in Exhibit A, the Executable Form of such Source Code
      Form, and Modifications of such Source Code Form, in each case
      including portions thereof.</p>
    <p class="${"my-4"}">1.5. &quot;Incompatible With Secondary Licenses&quot;
      means</p>
    (a) that the initial Contributor has attached the notice described
    in Exhibit B to the Covered Software; or

    (b) that the Covered Software was made available under the terms of
    version 1.1 or earlier of the License, but not also under the
    terms of a Secondary License.
    <p class="${"my-4"}">1.6. &quot;Executable Form&quot;
      means any form of the work other than Source Code Form.</p>
    <p class="${"my-4"}">1.7. &quot;Larger Work&quot;
      means a work that combines Covered Software with other material, in
      a separate file or files, that is not Covered Software.</p>
    <p class="${"my-4"}">1.8. &quot;License&quot;
      means this document.</p>
    <p class="${"my-4"}">1.9. &quot;Licensable&quot;
      means having the right to grant, to the maximum extent possible,
      whether at the time of the initial grant or subsequently, any and
      all of the rights conveyed by this License.</p>
    <p class="${"my-4"}">1.10. &quot;Modifications&quot;
      means any of the following:</p>
    (a) any file in Source Code Form that results from an addition to,
    deletion from, or modification of the contents of Covered
    Software; or

    (b) any new file in Source Code Form that contains any Covered
    Software.
    <p class="${"my-4"}">1.11. &quot;Patent Claims&quot; of a Contributor
      means any patent claim(s), including without limitation, method,
      process, and apparatus claims, in any patent Licensable by such
      Contributor that would be infringed, but for the grant of the
      License, by the making, using, selling, offering for sale, having
      made, import, or transfer of either its Contributions or its
      Contributor Version.</p>
    <p class="${"my-4"}">1.12. &quot;Secondary License&quot;
      means either the GNU General Public License, Version 2.0, the GNU
      Lesser General Public License, Version 2.1, the GNU Affero General
      Public License, Version 3.0, or any later versions of those
      licenses.</p>
    <p class="${"my-4"}">1.13. &quot;Source Code Form&quot;
      means the form of the work preferred for making modifications.</p>
    <p class="${"my-4"}">1.14. &quot;You&quot; (or &quot;Your&quot;)
      means an individual or a legal entity exercising rights under this
      License. For legal entities, &quot;You&quot; includes any entity that
      controls, is controlled by, or is under common control with You. For
      purposes of this definition, &quot;control&quot; means (a) the power, direct
      or indirect, to cause the direction or management of such entity,
      whether by contract or otherwise, or (b) ownership of more than
      fifty percent (50%) of the outstanding shares or beneficial
      ownership of such entity.</p>
    <h2 id="${"2-license-grants-and-conditions"}">2. License Grants and Conditions</h2>
    <p class="${"my-4"}">2.1. Grants</p>
    <p class="${"my-4"}">Each Contributor hereby grants You a world-wide, royalty-free,
      non-exclusive license:</p>
    <p class="${"my-4"}">(a) under intellectual property rights (other than patent or trademark)
      Licensable by such Contributor to use, reproduce, make available,
      modify, display, perform, distribute, and otherwise exploit its
      Contributions, either on an unmodified basis, with Modifications, or
      as part of a Larger Work; and</p>
    <p class="${"my-4"}">(b) under Patent Claims of such Contributor to make, use, sell, offer
      for sale, have made, import, and otherwise transfer either its
      Contributions or its Contributor Version.</p>
    <p class="${"my-4"}">2.2. Effective Date</p>
    <p class="${"my-4"}">The licenses granted in Section 2.1 with respect to any Contribution
      become effective for each Contribution on the date the Contributor first
      distributes such Contribution.</p>
    <p class="${"my-4"}">2.3. Limitations on Grant Scope</p>
    <p class="${"my-4"}">The licenses granted in this Section 2 are the only rights granted under
      this License. No additional rights or licenses will be implied from the
      distribution or licensing of Covered Software under this License.
      Notwithstanding Section 2.1(b) above, no patent license is granted by a
      Contributor:</p>
    <p class="${"my-4"}">(a) for any code that a Contributor has removed from Covered Software;
      or</p>
    <p class="${"my-4"}">(b) for infringements caused by: (i) Your and any other third party&#39;s
      modifications of Covered Software, or (ii) the combination of its
      Contributions with other software (except as part of its Contributor
      Version); or</p>
    <p class="${"my-4"}">(c) under Patent Claims infringed by Covered Software in the absence of
      its Contributions.</p>
    <p class="${"my-4"}">This License does not grant any rights in the trademarks, service marks,
      or logos of any Contributor (except as may be necessary to comply with
      the notice requirements in Section 3.4).</p>
    <p class="${"my-4"}">2.4. Subsequent Licenses</p>
    <p class="${"my-4"}">No Contributor makes additional grants as a result of Your choice to
      distribute the Covered Software under a subsequent version of this
      License (see Section 10.2) or under the terms of a Secondary License (if
      permitted under the terms of Section 3.3).</p>
    <p class="${"my-4"}">2.5. Representation</p>
    <p class="${"my-4"}">Each Contributor represents that the Contributor believes its
      Contributions are its original creation(s) or it has sufficient rights
      to grant the rights to its Contributions conveyed by this License.</p>
    <p class="${"my-4"}">2.6. Fair Use</p>
    <p class="${"my-4"}">This License is not intended to limit any rights You have under
      applicable copyright doctrines of fair use, fair dealing, or other
      equivalents.</p>
    <p class="${"my-4"}">2.7. Conditions</p>
    <p class="${"my-4"}">Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
      in Section 2.1.</p>
    <h2 id="${"3-responsibilities"}">3. Responsibilities</h2>
    <p class="${"my-4"}">3.1. Distribution of Source Form</p>
    <p class="${"my-4"}">All distribution of Covered Software in Source Code Form, including any
      Modifications that You create or to which You contribute, must be under
      the terms of this License. You must inform recipients that the Source
      Code Form of the Covered Software is governed by the terms of this
      License, and how they can obtain a copy of this License. You may not
      attempt to alter or restrict the recipients&#39; rights in the Source Code
      Form.</p>
    <p class="${"my-4"}">3.2. Distribution of Executable Form</p>
    <p class="${"my-4"}">If You distribute Covered Software in Executable Form then:</p>
    <p class="${"my-4"}">(a) such Covered Software must also be made available in Source Code
      Form, as described in Section 3.1, and You must inform recipients of
      the Executable Form how they can obtain a copy of such Source Code
      Form by reasonable means in a timely manner, at a charge no more
      than the cost of distribution to the recipient; and</p>
    <p class="${"my-4"}">(b) You may distribute such Executable Form under the terms of this
      License, or sublicense it under different terms, provided that the
      license for the Executable Form does not attempt to limit or alter
      the recipients&#39; rights in the Source Code Form under this License.</p>
    <p class="${"my-4"}">3.3. Distribution of a Larger Work</p>
    <p class="${"my-4"}">You may create and distribute a Larger Work under terms of Your choice,
      provided that You also comply with the requirements of this License for
      the Covered Software. If the Larger Work is a combination of Covered
      Software with a work governed by one or more Secondary Licenses, and the
      Covered Software is not Incompatible With Secondary Licenses, this
      License permits You to additionally distribute such Covered Software
      under the terms of such Secondary License(s), so that the recipient of
      the Larger Work may, at their option, further distribute the Covered
      Software under the terms of either this License or such Secondary
      License(s).</p>
    <p class="${"my-4"}">3.4. Notices</p>
    <p class="${"my-4"}">You may not remove or alter the substance of any license notices
      (including copyright notices, patent notices, disclaimers of warranty,
      or limitations of liability) contained within the Source Code Form of
      the Covered Software, except that You may alter any license notices to
      the extent required to remedy known factual inaccuracies.</p>
    <p class="${"my-4"}">3.5. Application of Additional Terms</p>
    <p class="${"my-4"}">You may choose to offer, and to charge a fee for, warranty, support,
      indemnity or liability obligations to one or more recipients of Covered
      Software. However, You may do so only on Your own behalf, and not on
      behalf of any Contributor. You must make it absolutely clear that any
      such warranty, support, indemnity, or liability obligation is offered by
      You alone, and You hereby agree to indemnify every Contributor for any
      liability incurred by such Contributor as a result of warranty, support,
      indemnity or liability terms You offer. You may include additional
      disclaimers of warranty and limitations of liability specific to any
      jurisdiction.</p>
    <h2 id="${"4-inability-to-comply-due-to-statute-or-regulation"}">4. Inability to Comply Due to Statute or Regulation</h2>
    <p class="${"my-4"}">If it is impossible for You to comply with any of the terms of this
      License with respect to some or all of the Covered Software due to
      statute, judicial order, or regulation then You must: (a) comply with
      the terms of this License to the maximum extent possible; and (b)
      describe the limitations and the code they affect. Such description must
      be placed in a text file included with all distributions of the Covered
      Software under this License. Except to the extent prohibited by statute
      or regulation, such description must be sufficiently detailed for a
      recipient of ordinary skill to be able to understand it.</p>
    <h2 id="${"5-termination"}">5. Termination</h2>
    <p class="${"my-4"}">5.1. The rights granted under this License will terminate automatically
      if You fail to comply with any of its terms. However, if You become
      compliant, then the rights granted under this License from a particular
      Contributor are reinstated (a) provisionally, unless and until such
      Contributor explicitly and finally terminates Your grants, and (b) on an
      ongoing basis, if such Contributor fails to notify You of the
      non-compliance by some reasonable means prior to 60 days after You have
      come back into compliance. Moreover, Your grants from a particular
      Contributor are reinstated on an ongoing basis if such Contributor
      notifies You of the non-compliance by some reasonable means, this is the
      first time You have received notice of non-compliance with this License
      from such Contributor, and You become compliant prior to 30 days after
      Your receipt of the notice.</p>
    <p class="${"my-4"}">5.2. If You initiate litigation against any entity by asserting a patent
      infringement claim (excluding declaratory judgment actions,
      counter-claims, and cross-claims) alleging that a Contributor Version
      directly or indirectly infringes any patent, then the rights granted to
      You by any and all Contributors for the Covered Software under Section
      2.1 of this License shall terminate.</p>
    <p class="${"my-4"}">5.3. In the event of termination under Sections 5.1 or 5.2 above, all
      end user license agreements (excluding distributors and resellers) which
      have been validly granted by You or Your distributors under this License
      prior to termination shall survive termination.</p>
    <hr>
    <ul><li>*</li>
      <li><ol><li>Disclaimer of Warranty *</li></ol></li></ul>
    <hr>
    <ul><li>*</li>
      <li>Covered Software is provided under this License on an &quot;as is&quot; *</li>
      <li>basis, without warranty of any kind, either expressed, implied, or *</li>
      <li>statutory, including, without limitation, warranties that the *</li>
      <li>Covered Software is free of defects, merchantable, fit for a *</li>
      <li>particular purpose or non-infringing. The entire risk as to the *</li>
      <li>quality and performance of the Covered Software is with You. *</li>
      <li>Should any Covered Software prove defective in any respect, You *</li>
      <li>(not any Contributor) assume the cost of any necessary servicing, *</li>
      <li>repair, or correction. This disclaimer of warranty constitutes an *</li>
      <li>essential part of this License. No use of any Covered Software is *</li>
      <li>authorized under this License except under this disclaimer. *</li>
      <li>*</li></ul>
    <hr>
    <hr>
    <ul><li>*</li>
      <li><ol><li>Limitation of Liability *</li></ol></li></ul>
    <hr>
    <ul><li>*</li>
      <li>Under no circumstances and under no legal theory, whether tort *</li>
      <li>(including negligence), contract, or otherwise, shall any *</li>
      <li>Contributor, or anyone who distributes Covered Software as *</li>
      <li>permitted above, be liable to You for any direct, indirect, *</li>
      <li>special, incidental, or consequential damages of any character *</li>
      <li>including, without limitation, damages for lost profits, loss of *</li>
      <li>goodwill, work stoppage, computer failure or malfunction, or any *</li>
      <li>and all other commercial damages or losses, even if such party *</li>
      <li>shall have been informed of the possibility of such damages. This *</li>
      <li>limitation of liability shall not apply to liability for death or *</li>
      <li>personal injury resulting from such party&#39;s negligence to the *</li>
      <li>extent applicable law prohibits such limitation. Some *</li>
      <li>jurisdictions do not allow the exclusion or limitation of *</li>
      <li>incidental or consequential damages, so this exclusion and *</li>
      <li>limitation may not apply to You. *</li>
      <li>*</li></ul>
    <hr>
    <h2 id="${"8-litigation"}">8. Litigation</h2>
    <p class="${"my-4"}">Any litigation relating to this License may be brought only in the
      courts of a jurisdiction where the defendant maintains its principal
      place of business and such litigation shall be governed by laws of that
      jurisdiction, without reference to its conflict-of-law provisions.
      Nothing in this Section shall prevent a party&#39;s ability to bring
      cross-claims or counter-claims.</p>
    <h2 id="${"9-miscellaneous"}">9. Miscellaneous</h2>
    <p class="${"my-4"}">This License represents the complete agreement concerning the subject
      matter hereof. If any provision of this License is held to be
      unenforceable, such provision shall be reformed only to the extent
      necessary to make it enforceable. Any law or regulation which provides
      that the language of a contract shall be construed against the drafter
      shall not be used to construe this License against a Contributor.</p>
    <h2 id="${"10-versions-of-the-license"}">10. Versions of the License</h2>
    <p class="${"my-4"}">10.1. New Versions</p>
    <p class="${"my-4"}">Mozilla Foundation is the license steward. Except as provided in Section
      10.3, no one other than the license steward has the right to modify or
      publish new versions of this License. Each version will be given a
      distinguishing version number.</p>
    <p class="${"my-4"}">10.2. Effect of New Versions</p>
    <p class="${"my-4"}">You may distribute the Covered Software under the terms of the version
      of the License under which You originally received the Covered Software,
      or under the terms of any subsequent version published by the license
      steward.</p>
    <p class="${"my-4"}">10.3. Modified Versions</p>
    <p class="${"my-4"}">If you create software not governed by this License, and you want to
      create a new license for such software, you may create and use a
      modified version of this License if you rename the license and remove
      any references to the name of the license steward (except to note that
      such modified license differs from this License).</p>
    <p class="${"my-4"}">10.4. Distributing Source Code Form that is Incompatible With Secondary
      Licenses</p>
    <p class="${"my-4"}">If You choose to distribute Source Code Form that is Incompatible With
      Secondary Licenses under the terms of this version of the License, the
      notice described in Exhibit B of this License must be attached.</p>
    <h2 id="${"exhibit-a-source-code-form-license-notice"}">Exhibit A - Source Code Form License Notice</h2>
    <p class="${"my-4"}">This Source Code Form is subject to the terms of the Mozilla Public
      License, v. 2.0. If a copy of the MPL was not distributed with this
      file, You can obtain one at <a href="${"http://mozilla.org/MPL/2.0/"}">http://mozilla.org/MPL/2.0/</a>.</p>
    <p class="${"my-4"}">If it is not possible or desirable to put the notice in a particular
      file, then You may include the notice in a location (such as a LICENSE
      file in a relevant directory) where a recipient would be likely to look
      for such a notice.</p>
    <p class="${"my-4"}">You may add additional accurate notices of copyright ownership.</p>
    <h2 id="${"exhibit-b-incompatible-with-secondary-licenses-notice"}">Exhibit B - &quot;Incompatible With Secondary
      Licenses&quot; Notice</h2>
    <p class="${"my-4"}">This Source Code Form is &quot;Incompatible With Secondary Licenses&quot;, as
      defined by the Mozilla Public License, v. 2.0.</p></div>`;
        }
      })}`;
    });
  }
});

// .svelte-kit/output/server/nodes/3.js
var __exports4 = {};
__export(__exports4, {
  css: () => css5,
  entry: () => entry4,
  index: () => index4,
  js: () => js4,
  module: () => license_svelte_exports
});
var index4, entry4, js4, css5;
var init__4 = __esm({
  ".svelte-kit/output/server/nodes/3.js"() {
    init_shims();
    init_license_svelte();
    index4 = 3;
    entry4 = "pages/license.svelte-0a36cd55.js";
    js4 = ["pages/license.svelte-0a36cd55.js", "chunks/index-fb8c27ab.js", "chunks/page-dbb5658c.js", "chunks/github_button-0f6de72f.js"];
    css5 = ["assets/page-945bcade.css"];
  }
});

// .svelte-kit/output/server/entries/pages/privacy.svelte.js
var privacy_svelte_exports = {};
__export(privacy_svelte_exports, {
  default: () => Privacy
});
var Privacy;
var init_privacy_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/privacy.svelte.js"() {
    init_shims();
    init_index_7a55addd();
    init_page_0c511438();
    Privacy = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Page, "Page").$$render($$result, { home: "false" }, {}, {
        default: () => {
          return `<div class="${"mx-auto my-20 max-w-5xl mt-24 font-baloo2 px-20"}"><h1 class="${"font-vollkorn text-3xl"}"><strong>Privacy Policy</strong></h1>
    <br>

    <p>Neil Agrawal built the PeaceBox app as
      a Free app. This SERVICE is provided by
      Neil Agrawal at no cost and is intended for use as
      is.
    </p>
    <br>
    <p>This page is used to inform visitors regarding my
      policies with the collection, use, and disclosure of Personal
      Information if anyone decided to use my Service.
    </p>
    <br>
    <p>If you choose to use my Service, then you agree to
      the collection and use of information in relation to this
      policy. The Personal Information that I collect is
      used for providing and improving the Service. I will not use or share your information with
      anyone except as described in this Privacy Policy.
    </p>
    <br>
    <p>The terms used in this Privacy Policy have the same meanings
      as in our Terms and Conditions, which is accessible at
      PeaceBox unless otherwise defined in this Privacy Policy.
    </p>
    <br>
    <br>
    <p style="${"font-family: 'vollkorn', Helvetica, Arial, sans-serif"}"><strong>Information Collection and Use</strong></p>
    <br>
    <p>For a better experience, while using our Service, I
      may require you to provide us with certain personally
      identifiable information. The information that
      I request will be retained on your device and is not collected by me in any way.
    </p>
    <br>
    <div><p>The app does use third party services that may collect
      information used to identify you.
    </p>
      <br>
      <p>Link to privacy policy of third party service providers used
        by the app
      </p>
      <br>
      <ul>
        <li><a href="${"https://firebase.google.com/policies/analytics"}" target="${"_blank"}" rel="${"noopener noreferrer"}"><strong>Google
          Analytics for Firebase</strong></a></li>
        <br>
        <li><a href="${"https://firebase.google.com/support/privacy/"}" target="${"_blank"}" rel="${"noopener noreferrer"}"><strong>Firebase
          Crashlytics</strong></a></li>
        
        </ul></div>
    <br>
    <br>
    <p class="${"font-vollkorn text-2xl"}"><strong>Log Data</strong></p>
    <br>
    <p>I want to inform you that whenever you
      use my Service, in a case of an error in the app
      I collect data and information (through third party
      products) on your phone called Log Data. This Log Data may
      include information such as your device Internet Protocol
      (\u201CIP\u201D) address, device name, operating system version, the
      configuration of the app when utilizing my Service,
      the time and date of your use of the Service, and other
      statistics.
    </p>
    <br><br>
    <p class="${"font-vollkorn text-2xl"}"><strong>Cookies</strong></p>
    <br>
    <p>Cookies are files with a small amount of data that are
      commonly used as anonymous unique identifiers. These are sent
      to your browser from the websites that you visit and are
      stored on your device&#39;s internal memory.
    </p>
    <p>This Service does not use these \u201Ccookies\u201D explicitly. However,
      the app may use third party code and libraries that use
      \u201Ccookies\u201D to collect information and improve their services.
      You have the option to either accept or refuse these cookies
      and know when a cookie is being sent to your device. If you
      choose to refuse our cookies, you may not be able to use some
      portions of this Service.
    </p>
    <br><br>
    <p class="${"font-vollkorn text-2xl"}"><strong>Service Providers</strong></p>
    <br>
    <p>I may employ third-party companies and
      individuals due to the following reasons:
    </p>
    <br>
    <ul><li>To facilitate our Service;</li>
      <li>To provide the Service on our behalf;</li>
      <li>To perform Service-related services; or</li>
      <li>To assist us in analyzing how our Service is used.</li></ul>
    <br>
    <p>I want to inform users of this Service
      that these third parties have access to your Personal
      Information. The reason is to perform the tasks assigned to
      them on our behalf. However, they are obligated not to
      disclose or use the information for any other purpose.
    </p>
    <p class="${"font-vollkorn text-2xl"}"><strong>Security</strong></p>
    <br>
    <p>I value your trust in providing us your
      Personal Information, thus we are striving to use commercially
      acceptable means of protecting it. But remember that no method
      of transmission over the internet, or method of electronic
      storage is 100% secure and reliable, and I cannot
      guarantee its absolute security.
    </p>
    <br><br>
    <p class="${"font-vollkorn text-2xl"}"><strong>Links to Other Sites</strong></p>
    <br>
    <p>This Service may contain links to other sites. If you click on
      a third-party link, you will be directed to that site. Note
      that these external sites are not operated by me.
      Therefore, I strongly advise you to review the
      Privacy Policy of these websites. I have
      no control over and assume no responsibility for the content,
      privacy policies, or practices of any third-party sites or
      services.
    </p>
    <br><br>
    <p class="${"font-vollkorn text-2xl"}"><strong>Children\u2019s Privacy</strong></p>
    <br>
    <p>These Services do not address anyone under the age of 13.
      I do not knowingly collect personally
      identifiable information from children under 13 years of age. In the case
      I discover that a child under 13 has provided
      me with personal information, I immediately
      delete this from our servers. If you are a parent or guardian
      and you are aware that your child has provided us with
      personal information, please contact me so that
      I will be able to do necessary actions.
    </p>
    <br><br>
    <p class="${"font-vollkorn text-2xl"}"><strong>Changes to This Privacy Policy</strong></p>
    <br>
    <p>I may update our Privacy Policy from
      time to time. Thus, you are advised to review this page
      periodically for any changes. I will
      notify you of any changes by posting the new Privacy Policy on
      this page.
    </p>
    <br>
    <p>This policy is effective as of 2021-10-29</p>
    <br>
    <p class="${"font-vollkorn text-2xl"}"><strong>Contact Us</strong></p>
    <p>If you have any questions or suggestions about my
      Privacy Policy, do not hesitate to contact me at contact@peacebox.app.
    </p></div>`;
        }
      })}`;
    });
  }
});

// .svelte-kit/output/server/nodes/4.js
var __exports5 = {};
__export(__exports5, {
  css: () => css6,
  entry: () => entry5,
  index: () => index5,
  js: () => js5,
  module: () => privacy_svelte_exports
});
var index5, entry5, js5, css6;
var init__5 = __esm({
  ".svelte-kit/output/server/nodes/4.js"() {
    init_shims();
    init_privacy_svelte();
    index5 = 4;
    entry5 = "pages/privacy.svelte-c16fef98.js";
    js5 = ["pages/privacy.svelte-c16fef98.js", "chunks/index-fb8c27ab.js", "chunks/page-dbb5658c.js"];
    css6 = ["assets/page-945bcade.css"];
  }
});

// .svelte-kit/output/server/entries/pages/terms.svelte.js
var terms_svelte_exports = {};
__export(terms_svelte_exports, {
  default: () => Terms
});
var Terms;
var init_terms_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/terms.svelte.js"() {
    init_shims();
    init_index_7a55addd();
    init_page_0c511438();
    Terms = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${validate_component(Page, "Page").$$render($$result, { home: "false" }, {}, {
        default: () => {
          return `<div class="${"mx-auto my-20 max-w-5xl mt-24 font-baloo2 px-20"}"><h1 class="${"font-vollkorn text-3xl"}"><strong>Terms &amp; Conditions</strong></h1>
    <br>
    <p>By downloading or using the app, these terms will
      automatically apply to you \u2013 you should make sure therefore
      that you read them carefully before using the app. You\u2019re not
      allowed to copy, or modify the app, any part of the app, or
      our trademarks in any way. You\u2019re not allowed to attempt to
      extract the source code of the app, and you also shouldn\u2019t try
      to translate the app into other languages, or make derivative
      versions. The app itself, and all the trade marks, copyright,
      database rights and other intellectual property rights related
      to it, still belong to Neil Agrawal.
    </p>
    <br>
    <p>Neil Agrawal is committed to ensuring that the app is
      as useful and efficient as possible. For that reason, we
      reserve the right to make changes to the app or to charge for
      its services, at any time and for any reason. We will never
      charge you for the app or its services without making it very
      clear to you exactly what you\u2019re paying for.
    </p>
    <br>
    <p>The PeaceBox app stores and processes personal data that
      you have provided to us, in order to provide my
      Service. It\u2019s your responsibility to keep your phone and
      access to the app secure. We therefore recommend that you do
      not jailbreak or root your phone, which is the process of
      removing software restrictions and limitations imposed by the
      official operating system of your device. It could make your
      phone vulnerable to malware/viruses/malicious programs,
      compromise your phone\u2019s security features and it could mean
      that the PeaceBox app won\u2019t work properly or at all.
    </p>
    <br>
    <div><p>The app does use third party services that declare their own
      Terms and Conditions.
    </p>
      <br>
      <p>Link to Terms and Conditions of third party service
        providers used by the app
      </p>
      <ul>
        <br>
        <li><a href="${"https://firebase.google.com/terms/analytics"}" target="${"_blank"}" rel="${"noopener noreferrer"}">Google
          Analytics for Firebase</a></li>
        <br>
        <li><a href="${"https://firebase.google.com/terms/crashlytics"}" target="${"_blank"}" rel="${"noopener noreferrer"}">Firebase
          Crashlytics</a></li>
        </ul>
      <br></div>
    <p>You should be aware that there are certain things that
      Neil Agrawal will not take responsibility for. Certain
      functions of the app will require the app to have an active
      internet connection. The connection can be Wi-Fi, or provided
      by your mobile network provider, but Neil Agrawal
      cannot take responsibility for the app not working at full
      functionality if you don\u2019t have access to Wi-Fi, and you don\u2019t
      have any of your data allowance left.
    </p>
    <br>
    <p></p>
    <br>
    <p>If you\u2019re using the app outside of an area with Wi-Fi, you
      should remember that your terms of the agreement with your
      mobile network provider will still apply. As a result, you may
      be charged by your mobile provider for the cost of data for
      the duration of the connection while accessing the app, or
      other third party charges. In using the app, you\u2019re accepting
      responsibility for any such charges, including roaming data
      charges if you use the app outside of your home territory
      (i.e. region or country) without turning off data roaming. If
      you are not the bill payer for the device on which you\u2019re
      using the app, please be aware that we assume that you have
      received permission from the bill payer for using the app.
    </p>
    <br>
    <p>Along the same lines, Neil Agrawal cannot always take
      responsibility for the way you use the app i.e. You need to
      make sure that your device stays charged \u2013 if it runs out of
      battery and you can\u2019t turn it on to avail the Service,
      Neil Agrawal cannot accept responsibility.
    </p>
    <br>
    <p>With respect to Neil Agrawal\u2019s responsibility for your
      use of the app, when you\u2019re using the app, it\u2019s important to
      bear in mind that although we endeavour to ensure that it is
      updated and correct at all times, we do rely on third parties
      to provide information to us so that we can make it available
      to you. Neil Agrawal accepts no liability for any
      loss, direct or indirect, you experience as a result of
      relying wholly on this functionality of the app.
    </p>
    <br>
    <p>At some point, we may wish to update the app. The app is
      currently available on iOS \u2013 the requirements for
      system(and for any additional systems we
      decide to extend the availability of the app to) may change,
      and you\u2019ll need to download the updates if you want to keep
      using the app. Neil Agrawal does not promise that it
      will always update the app so that it is relevant to you
      and/or works with the iOS version that you have
      installed on your device. However, you promise to always
      accept updates to the application when offered to you, We may
      also wish to stop providing the app, and may terminate use of
      it at any time without giving notice of termination to you.
      Unless we tell you otherwise, upon any termination, (a) the
      rights and licenses granted to you in these terms will end;
      (b) you must stop using the app, and (if needed) delete it
      from your device.
    </p>
    <br>
    <p class="${"font-vollkorn text-2xl"}"><strong>Changes to This Terms and Conditions</strong></p><br>

    <p>I may update our Terms and Conditions
      from time to time. Thus, you are advised to review this page
      periodically for any changes. I will
      notify you of any changes by posting the new Terms and
      Conditions on this page.
    </p>
    <br>
    <p>These terms and conditions are effective as of 2021-10-29
    </p>
    <br>
    <p class="${"font-vollkorn text-2xl"}"><strong>Contact Us</strong></p>
    <br>
    <p>If you have any questions or suggestions about my
      Terms and Conditions, do not hesitate to contact me
      at contact@peacebox.app.
    </p></div>`;
        }
      })}`;
    });
  }
});

// .svelte-kit/output/server/nodes/5.js
var __exports6 = {};
__export(__exports6, {
  css: () => css7,
  entry: () => entry6,
  index: () => index6,
  js: () => js6,
  module: () => terms_svelte_exports
});
var index6, entry6, js6, css7;
var init__6 = __esm({
  ".svelte-kit/output/server/nodes/5.js"() {
    init_shims();
    init_terms_svelte();
    index6 = 5;
    entry6 = "pages/terms.svelte-fb687ef4.js";
    js6 = ["pages/terms.svelte-fb687ef4.js", "chunks/index-fb8c27ab.js", "chunks/page-dbb5658c.js"];
    css7 = ["assets/page-945bcade.css"];
  }
});

// .svelte-kit/.svelte-kit/entry.js
var entry_exports = {};
__export(entry_exports, {
  default: () => svelteKit
});
module.exports = __toCommonJS(entry_exports);
init_shims();

// .svelte-kit/output/server/index.js
init_shims();
init_index_7a55addd();
function afterUpdate() {
}
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page } = $$props;
  let { components } = $$props;
  let { props_0 = null } = $$props;
  let { props_1 = null } = $$props;
  let { props_2 = null } = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  {
    stores.page.set(page);
  }
  return `


${components[1] ? `${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => {
      return `${components[2] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
        default: () => {
          return `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}`;
        }
      })}` : `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {})}`}`;
    }
  })}` : `${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {})}`}

${``}`;
});
function to_headers(object) {
  const headers = new Headers();
  if (object) {
    for (const key2 in object) {
      const value = object[key2];
      if (!value)
        continue;
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          headers.append(key2, value2);
        });
      } else {
        headers.set(key2, value);
      }
    }
  }
  return headers;
}
function hash(value) {
  let hash2 = 5381;
  let i3 = value.length;
  if (typeof value === "string") {
    while (i3)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i3);
  } else {
    while (i3)
      hash2 = hash2 * 33 ^ value[--i3];
  }
  return (hash2 >>> 0).toString(36);
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key2 in obj) {
    clone2[key2.toLowerCase()] = obj[key2];
  }
  return clone2;
}
function decode_params(params) {
  for (const key2 in params) {
    params[key2] = params[key2].replace(/%23/g, "#").replace(/%3[Bb]/g, ";").replace(/%2[Cc]/g, ",").replace(/%2[Ff]/g, "/").replace(/%3[Ff]/g, "?").replace(/%3[Aa]/g, ":").replace(/%40/g, "@").replace(/%26/g, "&").replace(/%3[Dd]/g, "=").replace(/%2[Bb]/g, "+").replace(/%24/g, "$");
  }
  return params;
}
function is_pojo(body) {
  if (typeof body !== "object")
    return false;
  if (body) {
    if (body instanceof Uint8Array)
      return false;
    if (body._readableState && typeof body.pipe === "function")
      return false;
    if (typeof ReadableStream !== "undefined" && body instanceof ReadableStream)
      return false;
  }
  return true;
}
function normalize_request_method(event) {
  const method = event.request.method.toLowerCase();
  return method === "delete" ? "del" : method;
}
function error(body) {
  return new Response(body, {
    status: 500
  });
}
function is_string(s22) {
  return typeof s22 === "string" || s22 instanceof String;
}
var text_types = /* @__PURE__ */ new Set([
  "application/xml",
  "application/json",
  "application/x-www-form-urlencoded",
  "multipart/form-data"
]);
function is_text(content_type) {
  if (!content_type)
    return true;
  const type = content_type.split(";")[0].toLowerCase();
  return type.startsWith("text/") || type.endsWith("+xml") || text_types.has(type);
}
async function render_endpoint(event, mod) {
  const method = normalize_request_method(event);
  let handler = mod[method];
  if (!handler && method === "head") {
    handler = mod.get;
  }
  if (!handler) {
    const allowed = [];
    for (const method2 in ["get", "post", "put", "patch"]) {
      if (mod[method2])
        allowed.push(method2.toUpperCase());
    }
    if (mod.del)
      allowed.push("DELETE");
    if (mod.get || mod.head)
      allowed.push("HEAD");
    return event.request.headers.get("x-sveltekit-load") ? new Response(void 0, {
      status: 204
    }) : new Response(`${event.request.method} method not allowed`, {
      status: 405,
      headers: {
        allow: allowed.join(", ")
      }
    });
  }
  const response = await handler(event);
  const preface = `Invalid response from route ${event.url.pathname}`;
  if (typeof response !== "object") {
    return error(`${preface}: expected an object, got ${typeof response}`);
  }
  if (response.fallthrough) {
    throw new Error("fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching");
  }
  const { status = 200, body = {} } = response;
  const headers = response.headers instanceof Headers ? new Headers(response.headers) : to_headers(response.headers);
  const type = headers.get("content-type");
  if (!is_text(type) && !(body instanceof Uint8Array || is_string(body))) {
    return error(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if (is_pojo(body) && (!type || type.startsWith("application/json"))) {
    headers.set("content-type", "application/json; charset=utf-8");
    normalized_body = JSON.stringify(body);
  } else {
    normalized_body = body;
  }
  if ((typeof normalized_body === "string" || normalized_body instanceof Uint8Array) && !headers.has("etag")) {
    const cache_control = headers.get("cache-control");
    if (!cache_control || !/(no-store|immutable)/.test(cache_control)) {
      headers.set("etag", `"${hash(normalized_body)}"`);
    }
  }
  return new Response(method !== "head" ? normalized_body : void 0, {
    status,
    headers
  });
}
var chars$1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped2 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key2) {
            return walk(thing[key2]);
          });
      }
    }
  }
  walk(value);
  var names = /* @__PURE__ */ new Map();
  Array.from(counts).filter(function(entry7) {
    return entry7[1] > 1;
  }).sort(function(a2, b2) {
    return b2[1] - a2[1];
  }).forEach(function(entry7, i3) {
    names.set(entry7[0], getName(i3));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v2, i3) {
          return i3 in thing ? stringify(v2) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key2) {
          return safeKey(key2) + ":" + stringify(thing[key2]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v2, i3) {
            statements_1.push(name + "[" + i3 + "]=" + stringify(v2));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v2) {
            return "add(" + stringify(v2) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a) {
            var k2 = _a[0], v2 = _a[1];
            return "set(" + stringify(k2) + ", " + stringify(v2) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key2) {
            statements_1.push("" + name + safeProp(key2) + "=" + stringify(thing[key2]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars$1[num % chars$1.length] + name;
    num = ~~(num / chars$1.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c2) {
  return escaped2[c2] || c2;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? key2 : escapeUnsafeChars(JSON.stringify(key2));
}
function safeProp(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? "." + key2 : "[" + escapeUnsafeChars(JSON.stringify(key2)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i3 = 0; i3 < str.length; i3 += 1) {
    var char = str.charAt(i3);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped2) {
      result += escaped2[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i3 + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i3];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop3() {
}
function safe_not_equal2(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || (a2 && typeof a2 === "object" || typeof a2 === "function");
}
Promise.resolve();
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop3) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal2(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i3 = 0; i3 < subscriber_queue.length; i3 += 2) {
            subscriber_queue[i3][0](subscriber_queue[i3 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn2) {
    set(fn2(value));
  }
  function subscribe2(run2, invalidate = noop3) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop3;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function coalesce_to_error(err) {
  return err instanceof Error || err && err.name && err.message ? err : new Error(JSON.stringify(err));
}
var render_json_payload_script_dict = {
  "<": "\\u003C",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var render_json_payload_script_regex = new RegExp(`[${Object.keys(render_json_payload_script_dict).join("")}]`, "g");
function render_json_payload_script(attrs, payload) {
  const safe_payload = JSON.stringify(payload).replace(render_json_payload_script_regex, (match) => render_json_payload_script_dict[match]);
  let safe_attrs = "";
  for (const [key2, value] of Object.entries(attrs)) {
    if (value === void 0)
      continue;
    safe_attrs += ` sveltekit:data-${key2}=${escape_html_attr(value)}`;
  }
  return `<script type="application/json"${safe_attrs}>${safe_payload}<\/script>`;
}
var escape_html_attr_dict = {
  "&": "&amp;",
  '"': "&quot;"
};
var escape_html_attr_regex = new RegExp(`[${Object.keys(escape_html_attr_dict).join("")}]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]`, "g");
function escape_html_attr(str) {
  const escaped_str = str.replace(escape_html_attr_regex, (match) => {
    if (match.length === 2) {
      return match;
    }
    return escape_html_attr_dict[match] ?? `&#${match.charCodeAt(0)};`;
  });
  return `"${escaped_str}"`;
}
var s2 = JSON.stringify;
var encoder = new TextEncoder();
function sha256(data) {
  if (!key[0])
    precompute();
  const out = init.slice(0);
  const array2 = encode$1(data);
  for (let i3 = 0; i3 < array2.length; i3 += 16) {
    const w2 = array2.subarray(i3, i3 + 16);
    let tmp;
    let a2;
    let b2;
    let out0 = out[0];
    let out1 = out[1];
    let out2 = out[2];
    let out3 = out[3];
    let out4 = out[4];
    let out5 = out[5];
    let out6 = out[6];
    let out7 = out[7];
    for (let i22 = 0; i22 < 64; i22++) {
      if (i22 < 16) {
        tmp = w2[i22];
      } else {
        a2 = w2[i22 + 1 & 15];
        b2 = w2[i22 + 14 & 15];
        tmp = w2[i22 & 15] = (a2 >>> 7 ^ a2 >>> 18 ^ a2 >>> 3 ^ a2 << 25 ^ a2 << 14) + (b2 >>> 17 ^ b2 >>> 19 ^ b2 >>> 10 ^ b2 << 15 ^ b2 << 13) + w2[i22 & 15] + w2[i22 + 9 & 15] | 0;
      }
      tmp = tmp + out7 + (out4 >>> 6 ^ out4 >>> 11 ^ out4 >>> 25 ^ out4 << 26 ^ out4 << 21 ^ out4 << 7) + (out6 ^ out4 & (out5 ^ out6)) + key[i22];
      out7 = out6;
      out6 = out5;
      out5 = out4;
      out4 = out3 + tmp | 0;
      out3 = out2;
      out2 = out1;
      out1 = out0;
      out0 = tmp + (out1 & out2 ^ out3 & (out1 ^ out2)) + (out1 >>> 2 ^ out1 >>> 13 ^ out1 >>> 22 ^ out1 << 30 ^ out1 << 19 ^ out1 << 10) | 0;
    }
    out[0] = out[0] + out0 | 0;
    out[1] = out[1] + out1 | 0;
    out[2] = out[2] + out2 | 0;
    out[3] = out[3] + out3 | 0;
    out[4] = out[4] + out4 | 0;
    out[5] = out[5] + out5 | 0;
    out[6] = out[6] + out6 | 0;
    out[7] = out[7] + out7 | 0;
  }
  const bytes = new Uint8Array(out.buffer);
  reverse_endianness(bytes);
  return base64(bytes);
}
var init = new Uint32Array(8);
var key = new Uint32Array(64);
function precompute() {
  function frac(x3) {
    return (x3 - Math.floor(x3)) * 4294967296;
  }
  let prime = 2;
  for (let i3 = 0; i3 < 64; prime++) {
    let is_prime = true;
    for (let factor = 2; factor * factor <= prime; factor++) {
      if (prime % factor === 0) {
        is_prime = false;
        break;
      }
    }
    if (is_prime) {
      if (i3 < 8) {
        init[i3] = frac(prime ** (1 / 2));
      }
      key[i3] = frac(prime ** (1 / 3));
      i3++;
    }
  }
}
function reverse_endianness(bytes) {
  for (let i3 = 0; i3 < bytes.length; i3 += 4) {
    const a2 = bytes[i3 + 0];
    const b2 = bytes[i3 + 1];
    const c2 = bytes[i3 + 2];
    const d2 = bytes[i3 + 3];
    bytes[i3 + 0] = d2;
    bytes[i3 + 1] = c2;
    bytes[i3 + 2] = b2;
    bytes[i3 + 3] = a2;
  }
}
function encode$1(str) {
  const encoded = encoder.encode(str);
  const length = encoded.length * 8;
  const size = 512 * Math.ceil((length + 65) / 512);
  const bytes = new Uint8Array(size / 8);
  bytes.set(encoded);
  bytes[encoded.length] = 128;
  reverse_endianness(bytes);
  const words = new Uint32Array(bytes.buffer);
  words[words.length - 2] = Math.floor(length / 4294967296);
  words[words.length - 1] = length;
  return words;
}
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
function base64(bytes) {
  const l2 = bytes.length;
  let result = "";
  let i3;
  for (i3 = 2; i3 < l2; i3 += 3) {
    result += chars[bytes[i3 - 2] >> 2];
    result += chars[(bytes[i3 - 2] & 3) << 4 | bytes[i3 - 1] >> 4];
    result += chars[(bytes[i3 - 1] & 15) << 2 | bytes[i3] >> 6];
    result += chars[bytes[i3] & 63];
  }
  if (i3 === l2 + 1) {
    result += chars[bytes[i3 - 2] >> 2];
    result += chars[(bytes[i3 - 2] & 3) << 4];
    result += "==";
  }
  if (i3 === l2) {
    result += chars[bytes[i3 - 2] >> 2];
    result += chars[(bytes[i3 - 2] & 3) << 4 | bytes[i3 - 1] >> 4];
    result += chars[(bytes[i3 - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
var csp_ready;
var array = new Uint8Array(16);
function generate_nonce() {
  crypto.getRandomValues(array);
  return base64(array);
}
var quoted = /* @__PURE__ */ new Set([
  "self",
  "unsafe-eval",
  "unsafe-hashes",
  "unsafe-inline",
  "none",
  "strict-dynamic",
  "report-sample"
]);
var crypto_pattern = /^(nonce|sha\d\d\d)-/;
var Csp = class {
  #use_hashes;
  #dev;
  #script_needs_csp;
  #style_needs_csp;
  #directives;
  #script_src;
  #style_src;
  constructor({ mode, directives }, { dev, prerender, needs_nonce }) {
    this.#use_hashes = mode === "hash" || mode === "auto" && prerender;
    this.#directives = dev ? { ...directives } : directives;
    this.#dev = dev;
    const d2 = this.#directives;
    if (dev) {
      const effective_style_src2 = d2["style-src"] || d2["default-src"];
      if (effective_style_src2 && !effective_style_src2.includes("unsafe-inline")) {
        d2["style-src"] = [...effective_style_src2, "unsafe-inline"];
      }
    }
    this.#script_src = [];
    this.#style_src = [];
    const effective_script_src = d2["script-src"] || d2["default-src"];
    const effective_style_src = d2["style-src"] || d2["default-src"];
    this.#script_needs_csp = !!effective_script_src && effective_script_src.filter((value) => value !== "unsafe-inline").length > 0;
    this.#style_needs_csp = !dev && !!effective_style_src && effective_style_src.filter((value) => value !== "unsafe-inline").length > 0;
    this.script_needs_nonce = this.#script_needs_csp && !this.#use_hashes;
    this.style_needs_nonce = this.#style_needs_csp && !this.#use_hashes;
    if (this.script_needs_nonce || this.style_needs_nonce || needs_nonce) {
      this.nonce = generate_nonce();
    }
  }
  add_script(content) {
    if (this.#script_needs_csp) {
      if (this.#use_hashes) {
        this.#script_src.push(`sha256-${sha256(content)}`);
      } else if (this.#script_src.length === 0) {
        this.#script_src.push(`nonce-${this.nonce}`);
      }
    }
  }
  add_style(content) {
    if (this.#style_needs_csp) {
      if (this.#use_hashes) {
        this.#style_src.push(`sha256-${sha256(content)}`);
      } else if (this.#style_src.length === 0) {
        this.#style_src.push(`nonce-${this.nonce}`);
      }
    }
  }
  get_header(is_meta = false) {
    const header = [];
    const directives = { ...this.#directives };
    if (this.#style_src.length > 0) {
      directives["style-src"] = [
        ...directives["style-src"] || directives["default-src"] || [],
        ...this.#style_src
      ];
    }
    if (this.#script_src.length > 0) {
      directives["script-src"] = [
        ...directives["script-src"] || directives["default-src"] || [],
        ...this.#script_src
      ];
    }
    for (const key2 in directives) {
      if (is_meta && (key2 === "frame-ancestors" || key2 === "report-uri" || key2 === "sandbox")) {
        continue;
      }
      const value = directives[key2];
      if (!value)
        continue;
      const directive = [key2];
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          if (quoted.has(value2) || crypto_pattern.test(value2)) {
            directive.push(`'${value2}'`);
          } else {
            directive.push(value2);
          }
        });
      }
      header.push(directive.join(" "));
    }
    return header.join("; ");
  }
  get_meta() {
    const content = escape_html_attr(this.get_header(true));
    return `<meta http-equiv="content-security-policy" content=${content}>`;
  }
};
var absolute = /^([a-z]+:)?\/?\//;
var scheme = /^[a-z]+:/;
function resolve(base2, path) {
  if (scheme.test(path))
    return path;
  const base_match = absolute.exec(base2);
  const path_match = absolute.exec(path);
  if (!base_match) {
    throw new Error(`bad base path: "${base2}"`);
  }
  const baseparts = path_match ? [] : base2.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path.slice(path_match[0].length).split("/") : path.split("/");
  baseparts.pop();
  for (let i3 = 0; i3 < pathparts.length; i3 += 1) {
    const part = pathparts[i3];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
function is_root_relative(path) {
  return path[0] === "/" && path[1] !== "/";
}
function normalize_path(path, trailing_slash) {
  if (path === "/" || trailing_slash === "ignore")
    return path;
  if (trailing_slash === "never") {
    return path.endsWith("/") ? path.slice(0, -1) : path;
  } else if (trailing_slash === "always" && !path.endsWith("/")) {
    return path + "/";
  }
  return path;
}
var LoadURL = class extends URL {
  get hash() {
    throw new Error("url.hash is inaccessible from load. Consider accessing hash from the page store within the script tag of your component.");
  }
};
var PrerenderingURL = class extends URL {
  get search() {
    throw new Error("Cannot access url.search on a page with prerendering enabled");
  }
  get searchParams() {
    throw new Error("Cannot access url.searchParams on a page with prerendering enabled");
  }
};
var updated = {
  ...readable(false),
  check: () => false
};
async function render_response({
  branch,
  options,
  state,
  $session,
  page_config,
  status,
  error: error2 = null,
  event,
  resolve_opts,
  stuff
}) {
  if (state.prerendering) {
    if (options.csp.mode === "nonce") {
      throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    }
    if (options.template_contains_nonce) {
      throw new Error("Cannot use prerendering if page template contains %sveltekit.nonce%");
    }
  }
  const stylesheets = new Set(options.manifest._.entry.css);
  const modulepreloads = new Set(options.manifest._.entry.js);
  const styles = /* @__PURE__ */ new Map();
  const serialized_data = [];
  let shadow_props;
  let rendered;
  let is_private = false;
  let cache;
  if (error2) {
    error2.stack = options.get_stack(error2);
  }
  if (resolve_opts.ssr) {
    branch.forEach(({ node, props: props2, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => stylesheets.add(url));
      if (node.js)
        node.js.forEach((url) => modulepreloads.add(url));
      if (node.styles)
        Object.entries(node.styles).forEach(([k2, v2]) => styles.set(k2, v2));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (props2)
        shadow_props = props2;
      cache = loaded == null ? void 0 : loaded.cache;
      is_private = (cache == null ? void 0 : cache.private) ?? uses_credentials;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session: {
          ...session,
          subscribe: (fn2) => {
            is_private = (cache == null ? void 0 : cache.private) ?? true;
            return session.subscribe(fn2);
          }
        },
        updated
      },
      page: {
        error: error2,
        params: event.params,
        routeId: event.routeId,
        status,
        stuff,
        url: state.prerendering ? new PrerenderingURL(event.url) : event.url
      },
      components: branch.map(({ node }) => node.module.default)
    };
    const print_error = (property, replacement) => {
      Object.defineProperty(props.page, property, {
        get: () => {
          throw new Error(`$page.${property} has been replaced by $page.url.${replacement}`);
        }
      });
    };
    print_error("origin", "origin");
    print_error("path", "pathname");
    print_error("query", "searchParams");
    for (let i3 = 0; i3 < branch.length; i3 += 1) {
      props[`props_${i3}`] = await branch[i3].loaded.props;
    }
    rendered = options.root.render(props);
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  let { head, html: body } = rendered;
  const inlined_style = Array.from(styles.values()).join("\n");
  await csp_ready;
  const csp = new Csp(options.csp, {
    dev: options.dev,
    prerender: !!state.prerendering,
    needs_nonce: options.template_contains_nonce
  });
  const target = hash(body);
  const init_app = `
		import { start } from ${s2(options.prefix + options.manifest._.entry.file)};
		start({
			target: document.querySelector('[data-sveltekit-hydrate="${target}"]').parentNode,
			paths: ${s2(options.paths)},
			session: ${try_serialize($session, (error3) => {
    throw new Error(`Failed to serialize session data: ${error3.message}`);
  })},
			route: ${!!page_config.router},
			spa: ${!resolve_opts.ssr},
			trailing_slash: ${s2(options.trailing_slash)},
			hydrate: ${resolve_opts.ssr && page_config.hydrate ? `{
				status: ${status},
				error: ${serialize_error(error2)},
				nodes: [${branch.map(({ node }) => node.index).join(", ")}],
				params: ${devalue(event.params)},
				routeId: ${s2(event.routeId)}
			}` : "null"}
		});
	`;
  const init_service_worker = `
		if ('serviceWorker' in navigator) {
			addEventListener('load', () => {
				navigator.serviceWorker.register('${options.service_worker}');
			});
		}
	`;
  if (inlined_style) {
    const attributes = [];
    if (options.dev)
      attributes.push(" data-sveltekit");
    if (csp.style_needs_nonce)
      attributes.push(` nonce="${csp.nonce}"`);
    csp.add_style(inlined_style);
    head += `
	<style${attributes.join("")}>${inlined_style}</style>`;
  }
  head += Array.from(stylesheets).map((dep) => {
    const attributes = [
      'rel="stylesheet"',
      `href="${options.prefix + dep}"`
    ];
    if (csp.style_needs_nonce) {
      attributes.push(`nonce="${csp.nonce}"`);
    }
    if (styles.has(dep)) {
      attributes.push("disabled", 'media="(max-width: 0)"');
    }
    return `
	<link ${attributes.join(" ")}>`;
  }).join("");
  if (page_config.router || page_config.hydrate) {
    head += Array.from(modulepreloads).map((dep) => `
	<link rel="modulepreload" href="${options.prefix + dep}">`).join("");
    const attributes = ['type="module"', `data-sveltekit-hydrate="${target}"`];
    csp.add_script(init_app);
    if (csp.script_needs_nonce) {
      attributes.push(`nonce="${csp.nonce}"`);
    }
    body += `
		<script ${attributes.join(" ")}>${init_app}<\/script>`;
    body += serialized_data.map(({ url, body: body2, response }) => render_json_payload_script({ type: "data", url, body: typeof body2 === "string" ? hash(body2) : void 0 }, response)).join("\n	");
    if (shadow_props) {
      body += render_json_payload_script({ type: "props" }, shadow_props);
    }
  }
  if (options.service_worker) {
    csp.add_script(init_service_worker);
    head += `
			<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>${init_service_worker}<\/script>`;
  }
  if (state.prerendering) {
    const http_equiv = [];
    const csp_headers = csp.get_meta();
    if (csp_headers) {
      http_equiv.push(csp_headers);
    }
    if (cache) {
      http_equiv.push(`<meta http-equiv="cache-control" content="max-age=${cache.maxage}">`);
    }
    if (http_equiv.length > 0) {
      head = http_equiv.join("\n") + head;
    }
  }
  const segments = event.url.pathname.slice(options.paths.base.length).split("/").slice(2);
  const assets2 = options.paths.assets || (segments.length > 0 ? segments.map(() => "..").join("/") : ".");
  const html = await resolve_opts.transformPage({
    html: options.template({ head, body, assets: assets2, nonce: csp.nonce })
  });
  const headers = new Headers({
    "content-type": "text/html",
    etag: `"${hash(html)}"`
  });
  if (cache) {
    headers.set("cache-control", `${is_private ? "private" : "public"}, max-age=${cache.maxage}`);
  }
  if (!options.floc) {
    headers.set("permissions-policy", "interest-cohort=()");
  }
  if (!state.prerendering) {
    const csp_header = csp.get_header();
    if (csp_header) {
      headers.set("content-security-policy", csp_header);
    }
  }
  return new Response(html, {
    status,
    headers
  });
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(coalesce_to_error(err));
    return null;
  }
}
function serialize_error(error2) {
  if (!error2)
    return null;
  let serialized = try_serialize(error2);
  if (!serialized) {
    const { name, message, stack } = error2;
    serialized = try_serialize({ ...error2, name, message, stack });
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
var parse_1 = parse$1;
var serialize_1 = serialize;
var __toString = Object.prototype.toString;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse$1(str, options) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options || {};
  var dec = opt.decode || decode;
  var index7 = 0;
  while (index7 < str.length) {
    var eqIdx = str.indexOf("=", index7);
    if (eqIdx === -1) {
      break;
    }
    var endIdx = str.indexOf(";", index7);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index7 = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    var key2 = str.slice(index7, eqIdx).trim();
    if (obj[key2] === void 0) {
      var val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key2] = tryDecode(val, dec);
    }
    index7 = endIdx + 1;
  }
  return obj;
}
function serialize(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name + "=" + value;
  if (opt.maxAge != null) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    var expires = opt.expires;
    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.priority) {
    var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}
function decode(str) {
  return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
}
function encode(val) {
  return encodeURIComponent(val);
}
function isDate(val) {
  return __toString.call(val) === "[object Date]" || val instanceof Date;
}
function tryDecode(str, decode2) {
  try {
    return decode2(str);
  } catch (e3) {
    return str;
  }
}
var setCookie = { exports: {} };
var defaultParseOptions = {
  decodeValues: true,
  map: false,
  silent: false
};
function isNonEmptyString(str) {
  return typeof str === "string" && !!str.trim();
}
function parseString(setCookieValue, options) {
  var parts = setCookieValue.split(";").filter(isNonEmptyString);
  var nameValue = parts.shift().split("=");
  var name = nameValue.shift();
  var value = nameValue.join("=");
  options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
  try {
    value = options.decodeValues ? decodeURIComponent(value) : value;
  } catch (e3) {
    console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e3);
  }
  var cookie = {
    name,
    value
  };
  parts.forEach(function(part) {
    var sides = part.split("=");
    var key2 = sides.shift().trimLeft().toLowerCase();
    var value2 = sides.join("=");
    if (key2 === "expires") {
      cookie.expires = new Date(value2);
    } else if (key2 === "max-age") {
      cookie.maxAge = parseInt(value2, 10);
    } else if (key2 === "secure") {
      cookie.secure = true;
    } else if (key2 === "httponly") {
      cookie.httpOnly = true;
    } else if (key2 === "samesite") {
      cookie.sameSite = value2;
    } else {
      cookie[key2] = value2;
    }
  });
  return cookie;
}
function parse(input, options) {
  options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
  if (!input) {
    if (!options.map) {
      return [];
    } else {
      return {};
    }
  }
  if (input.headers && input.headers["set-cookie"]) {
    input = input.headers["set-cookie"];
  } else if (input.headers) {
    var sch = input.headers[Object.keys(input.headers).find(function(key2) {
      return key2.toLowerCase() === "set-cookie";
    })];
    if (!sch && input.headers.cookie && !options.silent) {
      console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
    }
    input = sch;
  }
  if (!Array.isArray(input)) {
    input = [input];
  }
  options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
  if (!options.map) {
    return input.filter(isNonEmptyString).map(function(str) {
      return parseString(str, options);
    });
  } else {
    var cookies = {};
    return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
      var cookie = parseString(str, options);
      cookies2[cookie.name] = cookie;
      return cookies2;
    }, cookies);
  }
}
function splitCookiesString(cookiesString) {
  if (Array.isArray(cookiesString)) {
    return cookiesString;
  }
  if (typeof cookiesString !== "string") {
    return [];
  }
  var cookiesStrings = [];
  var pos = 0;
  var start;
  var ch;
  var lastComma;
  var nextStart;
  var cookiesSeparatorFound;
  function skipWhitespace() {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  }
  function notSpecialChar() {
    ch = cookiesString.charAt(pos);
    return ch !== "=" && ch !== ";" && ch !== ",";
  }
  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;
    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        lastComma = pos;
        pos += 1;
        skipWhitespace();
        nextStart = pos;
        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          cookiesSeparatorFound = true;
          pos = nextStart;
          cookiesStrings.push(cookiesString.substring(start, lastComma));
          start = pos;
        } else {
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }
    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
    }
  }
  return cookiesStrings;
}
setCookie.exports = parse;
setCookie.exports.parse = parse;
var parseString_1 = setCookie.exports.parseString = parseString;
var splitCookiesString_1 = setCookie.exports.splitCookiesString = splitCookiesString;
function normalize(loaded) {
  if (loaded.fallthrough) {
    throw new Error("fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching");
  }
  if ("maxage" in loaded) {
    throw new Error("maxage should be replaced with cache: { maxage }");
  }
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return { status: status || 500, error: new Error() };
    }
    const error2 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error2 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error2 };
    }
    return { status, error: error2 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      throw new Error('"redirect" property returned from load() must be accompanied by a 3xx status code');
    }
    if (typeof loaded.redirect !== "string") {
      throw new Error('"redirect" property returned from load() must be a string');
    }
  }
  if (loaded.dependencies) {
    if (!Array.isArray(loaded.dependencies) || loaded.dependencies.some((dep) => typeof dep !== "string")) {
      throw new Error('"dependencies" property returned from load() must be of type string[]');
    }
  }
  if (loaded.context) {
    throw new Error('You are returning "context" from a load function. "context" was renamed to "stuff", please adjust your code accordingly.');
  }
  return loaded;
}
function domain_matches(hostname, constraint) {
  if (!constraint)
    return true;
  const normalized = constraint[0] === "." ? constraint.slice(1) : constraint;
  if (hostname === normalized)
    return true;
  return hostname.endsWith("." + normalized);
}
function path_matches(path, constraint) {
  if (!constraint)
    return true;
  const normalized = constraint.endsWith("/") ? constraint.slice(0, -1) : constraint;
  if (path === normalized)
    return true;
  return path.startsWith(normalized + "/");
}
async function load_node({
  event,
  options,
  state,
  route,
  node,
  $session,
  stuff,
  is_error,
  is_leaf,
  status,
  error: error2
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  const cookies = parse_1(event.request.headers.get("cookie") || "");
  const new_cookies = [];
  let loaded;
  const should_prerender = node.module.prerender ?? options.prerender.default;
  const shadow = is_leaf ? await load_shadow_data(route, event, options, should_prerender) : {};
  if (shadow.cookies) {
    shadow.cookies.forEach((header) => {
      new_cookies.push(parseString_1(header));
    });
  }
  if (shadow.error) {
    loaded = {
      status: shadow.status,
      error: shadow.error
    };
  } else if (shadow.redirect) {
    loaded = {
      status: shadow.status,
      redirect: shadow.redirect
    };
  } else if (module2.load) {
    const load_input = {
      url: state.prerendering ? new PrerenderingURL(event.url) : new LoadURL(event.url),
      params: event.params,
      props: shadow.body || {},
      routeId: event.routeId,
      get session() {
        if (node.module.prerender ?? options.prerender.default) {
          throw Error("Attempted to access session from a prerendered page. Session would never be populated.");
        }
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let requested;
        if (typeof resource === "string") {
          requested = resource;
        } else {
          requested = resource.url;
          opts = {
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity,
            ...opts
          };
        }
        opts.headers = new Headers(opts.headers);
        for (const [key2, value] of event.request.headers) {
          if (key2 !== "authorization" && key2 !== "cookie" && key2 !== "host" && key2 !== "if-none-match" && !opts.headers.has(key2)) {
            opts.headers.set(key2, value);
          }
        }
        const resolved = resolve(event.url.pathname, requested.split("?")[0]);
        let response;
        let dependency;
        const prefix = options.paths.assets || options.paths.base;
        const filename = decodeURIComponent(resolved.startsWith(prefix) ? resolved.slice(prefix.length) : resolved).slice(1);
        const filename_html = `${filename}/index.html`;
        const is_asset = options.manifest.assets.has(filename);
        const is_asset_html = options.manifest.assets.has(filename_html);
        if (is_asset || is_asset_html) {
          const file = is_asset ? filename : filename_html;
          if (options.read) {
            const type = is_asset ? options.manifest.mimeTypes[filename.slice(filename.lastIndexOf("."))] : "text/html";
            response = new Response(options.read(file), {
              headers: type ? { "content-type": type } : {}
            });
          } else {
            response = await fetch(`${event.url.origin}/${file}`, opts);
          }
        } else if (is_root_relative(resolved)) {
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            const authorization = event.request.headers.get("authorization");
            const combined_cookies = { ...cookies };
            for (const cookie2 of new_cookies) {
              if (!domain_matches(event.url.hostname, cookie2.domain))
                continue;
              if (!path_matches(resolved, cookie2.path))
                continue;
              combined_cookies[cookie2.name] = cookie2.value;
            }
            const cookie = Object.entries(combined_cookies).map(([name, value]) => `${name}=${value}`).join("; ");
            if (cookie) {
              opts.headers.set("cookie", cookie);
            }
            if (authorization && !opts.headers.has("authorization")) {
              opts.headers.set("authorization", authorization);
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          response = await respond(new Request(new URL(requested, event.url).href, { ...opts }), options, {
            ...state,
            initiator: route
          });
          if (state.prerendering) {
            dependency = { response, body: null };
            state.prerendering.dependencies.set(resolved, dependency);
          }
        } else {
          if (resolved.startsWith("//")) {
            requested = event.url.protocol + requested;
          }
          if (`.${new URL(requested).hostname}`.endsWith(`.${event.url.hostname}`) && opts.credentials !== "omit") {
            uses_credentials = true;
            const cookie = event.request.headers.get("cookie");
            if (cookie)
              opts.headers.set("cookie", cookie);
          }
          const external_request = new Request(requested, opts);
          response = await options.hooks.externalFetch.call(null, external_request);
        }
        const set_cookie = response.headers.get("set-cookie");
        if (set_cookie) {
          new_cookies.push(...splitCookiesString_1(set_cookie).map((str) => parseString_1(str)));
        }
        const proxy = new Proxy(response, {
          get(response2, key2, _receiver) {
            async function text() {
              const body = await response2.text();
              const headers = {};
              for (const [key3, value] of response2.headers) {
                if (key3 !== "set-cookie" && key3 !== "etag") {
                  headers[key3] = value;
                }
              }
              if (!opts.body || typeof opts.body === "string") {
                const status_number = Number(response2.status);
                if (isNaN(status_number)) {
                  throw new Error(`response.status is not a number. value: "${response2.status}" type: ${typeof response2.status}`);
                }
                fetched.push({
                  url: requested,
                  body: opts.body,
                  response: {
                    status: status_number,
                    statusText: response2.statusText,
                    headers,
                    body
                  }
                });
              }
              if (dependency) {
                dependency.body = body;
              }
              return body;
            }
            if (key2 === "arrayBuffer") {
              return async () => {
                const buffer = await response2.arrayBuffer();
                if (dependency) {
                  dependency.body = new Uint8Array(buffer);
                }
                return buffer;
              };
            }
            if (key2 === "text") {
              return text;
            }
            if (key2 === "json") {
              return async () => {
                return JSON.parse(await text());
              };
            }
            return Reflect.get(response2, key2, response2);
          }
        });
        return proxy;
      },
      stuff: { ...stuff },
      status: is_error ? status ?? null : null,
      error: is_error ? error2 ?? null : null
    };
    if (options.dev) {
      Object.defineProperty(load_input, "page", {
        get: () => {
          throw new Error("`page` in `load` functions has been replaced by `url` and `params`");
        }
      });
    }
    loaded = await module2.load.call(null, load_input);
    if (!loaded) {
      throw new Error(`load function must return a value${options.dev ? ` (${node.entry})` : ""}`);
    }
  } else if (shadow.body) {
    loaded = {
      props: shadow.body
    };
  } else {
    loaded = {};
  }
  if (shadow.body && state.prerendering) {
    const pathname = `${event.url.pathname.replace(/\/$/, "")}/__data.json`;
    const dependency = {
      response: new Response(void 0),
      body: JSON.stringify(shadow.body)
    };
    state.prerendering.dependencies.set(pathname, dependency);
  }
  return {
    node,
    props: shadow.body,
    loaded: normalize(loaded),
    stuff: loaded.stuff || stuff,
    fetched,
    set_cookie_headers: new_cookies.map((new_cookie) => {
      const { name, value, ...options2 } = new_cookie;
      return serialize_1(name, value, options2);
    }),
    uses_credentials
  };
}
async function load_shadow_data(route, event, options, prerender) {
  if (!route.shadow)
    return {};
  try {
    const mod = await route.shadow();
    if (prerender && (mod.post || mod.put || mod.del || mod.patch)) {
      throw new Error("Cannot prerender pages that have endpoints with mutative methods");
    }
    const method = normalize_request_method(event);
    const is_get = method === "head" || method === "get";
    const handler = method === "head" ? mod.head || mod.get : mod[method];
    if (!handler && !is_get) {
      return {
        status: 405,
        error: new Error(`${method} method not allowed`)
      };
    }
    const data = {
      status: 200,
      cookies: [],
      body: {}
    };
    if (!is_get) {
      const result = await handler(event);
      if (result.fallthrough) {
        throw new Error("fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching");
      }
      const { status, headers, body } = validate_shadow_output(result);
      data.status = status;
      add_cookies(data.cookies, headers);
      if (status >= 300 && status < 400) {
        data.redirect = headers instanceof Headers ? headers.get("location") : headers.location;
        return data;
      }
      data.body = body;
    }
    const get = method === "head" && mod.head || mod.get;
    if (get) {
      const result = await get(event);
      if (result.fallthrough) {
        throw new Error("fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching");
      }
      const { status, headers, body } = validate_shadow_output(result);
      add_cookies(data.cookies, headers);
      data.status = status;
      if (status >= 400) {
        data.error = new Error("Failed to load data");
        return data;
      }
      if (status >= 300) {
        data.redirect = headers instanceof Headers ? headers.get("location") : headers.location;
        return data;
      }
      data.body = { ...body, ...data.body };
    }
    return data;
  } catch (e3) {
    const error2 = coalesce_to_error(e3);
    options.handle_error(error2, event);
    return {
      status: 500,
      error: error2
    };
  }
}
function add_cookies(target, headers) {
  const cookies = headers["set-cookie"];
  if (cookies) {
    if (Array.isArray(cookies)) {
      target.push(...cookies);
    } else {
      target.push(cookies);
    }
  }
}
function validate_shadow_output(result) {
  const { status = 200, body = {} } = result;
  let headers = result.headers || {};
  if (headers instanceof Headers) {
    if (headers.has("set-cookie")) {
      throw new Error("Endpoint request handler cannot use Headers interface with Set-Cookie headers");
    }
  } else {
    headers = lowercase_keys(headers);
  }
  if (!is_pojo(body)) {
    throw new Error("Body returned from endpoint request handler must be a plain object");
  }
  return { status, headers, body };
}
async function respond_with_error({
  event,
  options,
  state,
  $session,
  status,
  error: error2,
  resolve_opts
}) {
  try {
    const branch = [];
    let stuff = {};
    if (resolve_opts.ssr) {
      const default_layout = await options.manifest._.nodes[0]();
      const default_error = await options.manifest._.nodes[1]();
      const layout_loaded = await load_node({
        event,
        options,
        state,
        route: null,
        node: default_layout,
        $session,
        stuff: {},
        is_error: false,
        is_leaf: false
      });
      const error_loaded = await load_node({
        event,
        options,
        state,
        route: null,
        node: default_error,
        $session,
        stuff: layout_loaded ? layout_loaded.stuff : {},
        is_error: true,
        is_leaf: false,
        status,
        error: error2
      });
      branch.push(layout_loaded, error_loaded);
      stuff = error_loaded.stuff;
    }
    return await render_response({
      options,
      state,
      $session,
      page_config: {
        hydrate: options.hydrate,
        router: options.router
      },
      stuff,
      status,
      error: error2,
      branch,
      event,
      resolve_opts
    });
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options.handle_error(error3, event);
    return new Response(error3.stack, {
      status: 500
    });
  }
}
async function respond$1(opts) {
  const { event, options, state, $session, route, resolve_opts } = opts;
  let nodes;
  if (!resolve_opts.ssr) {
    return await render_response({
      ...opts,
      branch: [],
      page_config: {
        hydrate: true,
        router: true
      },
      status: 200,
      error: null,
      event,
      stuff: {}
    });
  }
  try {
    nodes = await Promise.all(route.a.map((n2) => n2 == void 0 ? n2 : options.manifest._.nodes[n2]()));
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options.handle_error(error3, event);
    return await respond_with_error({
      event,
      options,
      state,
      $session,
      status: 500,
      error: error3,
      resolve_opts
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  let page_config = get_page_config(leaf, options);
  if (state.prerendering) {
    const should_prerender = leaf.prerender ?? options.prerender.default;
    if (!should_prerender) {
      return new Response(void 0, {
        status: 204
      });
    }
  }
  let branch = [];
  let status = 200;
  let error2 = null;
  let set_cookie_headers = [];
  let stuff = {};
  ssr: {
    for (let i3 = 0; i3 < nodes.length; i3 += 1) {
      const node = nodes[i3];
      let loaded;
      if (node) {
        try {
          loaded = await load_node({
            ...opts,
            node,
            stuff,
            is_error: false,
            is_leaf: i3 === nodes.length - 1
          });
          set_cookie_headers = set_cookie_headers.concat(loaded.set_cookie_headers);
          if (loaded.loaded.redirect) {
            return with_cookies(new Response(void 0, {
              status: loaded.loaded.status,
              headers: {
                location: loaded.loaded.redirect
              }
            }), set_cookie_headers);
          }
          if (loaded.loaded.error) {
            ({ status, error: error2 } = loaded.loaded);
          }
        } catch (err) {
          const e3 = coalesce_to_error(err);
          options.handle_error(e3, event);
          status = 500;
          error2 = e3;
        }
        if (loaded && !error2) {
          branch.push(loaded);
        }
        if (error2) {
          while (i3--) {
            if (route.b[i3]) {
              const index7 = route.b[i3];
              const error_node = await options.manifest._.nodes[index7]();
              let node_loaded;
              let j2 = i3;
              while (!(node_loaded = branch[j2])) {
                j2 -= 1;
              }
              try {
                const error_loaded = await load_node({
                  ...opts,
                  node: error_node,
                  stuff: node_loaded.stuff,
                  is_error: true,
                  is_leaf: false,
                  status,
                  error: error2
                });
                if (error_loaded.loaded.error) {
                  continue;
                }
                page_config = get_page_config(error_node.module, options);
                branch = branch.slice(0, j2 + 1).concat(error_loaded);
                stuff = { ...node_loaded.stuff, ...error_loaded.stuff };
                break ssr;
              } catch (err) {
                const e3 = coalesce_to_error(err);
                options.handle_error(e3, event);
                continue;
              }
            }
          }
          return with_cookies(await respond_with_error({
            event,
            options,
            state,
            $session,
            status,
            error: error2,
            resolve_opts
          }), set_cookie_headers);
        }
      }
      if (loaded && loaded.loaded.stuff) {
        stuff = {
          ...stuff,
          ...loaded.loaded.stuff
        };
      }
    }
  }
  try {
    return with_cookies(await render_response({
      ...opts,
      stuff,
      event,
      page_config,
      status,
      error: error2,
      branch: branch.filter(Boolean)
    }), set_cookie_headers);
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options.handle_error(error3, event);
    return with_cookies(await respond_with_error({
      ...opts,
      status: 500,
      error: error3
    }), set_cookie_headers);
  }
}
function get_page_config(leaf, options) {
  if ("ssr" in leaf) {
    throw new Error("`export const ssr` has been removed \u2014 use the handle hook instead: https://kit.svelte.dev/docs/hooks#handle");
  }
  return {
    router: "router" in leaf ? !!leaf.router : options.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options.hydrate
  };
}
function with_cookies(response, set_cookie_headers) {
  if (set_cookie_headers.length) {
    set_cookie_headers.forEach((value) => {
      response.headers.append("set-cookie", value);
    });
  }
  return response;
}
async function render_page(event, route, options, state, resolve_opts) {
  if (state.initiator === route) {
    return new Response(`Not found: ${event.url.pathname}`, {
      status: 404
    });
  }
  if (route.shadow) {
    const type = negotiate(event.request.headers.get("accept") || "text/html", [
      "text/html",
      "application/json"
    ]);
    if (type === "application/json") {
      return render_endpoint(event, await route.shadow());
    }
  }
  const $session = await options.hooks.getSession(event);
  return respond$1({
    event,
    options,
    state,
    $session,
    resolve_opts,
    route
  });
}
function negotiate(accept, types2) {
  const parts = accept.split(",").map((str, i3) => {
    const match = /([^/]+)\/([^;]+)(?:;q=([0-9.]+))?/.exec(str);
    if (match) {
      const [, type, subtype, q2 = "1"] = match;
      return { type, subtype, q: +q2, i: i3 };
    }
    throw new Error(`Invalid Accept header: ${accept}`);
  }).sort((a2, b2) => {
    if (a2.q !== b2.q) {
      return b2.q - a2.q;
    }
    if (a2.subtype === "*" !== (b2.subtype === "*")) {
      return a2.subtype === "*" ? 1 : -1;
    }
    if (a2.type === "*" !== (b2.type === "*")) {
      return a2.type === "*" ? 1 : -1;
    }
    return a2.i - b2.i;
  });
  let accepted;
  let min_priority = Infinity;
  for (const mimetype of types2) {
    const [type, subtype] = mimetype.split("/");
    const priority = parts.findIndex((part) => (part.type === type || part.type === "*") && (part.subtype === subtype || part.subtype === "*"));
    if (priority !== -1 && priority < min_priority) {
      accepted = mimetype;
      min_priority = priority;
    }
  }
  return accepted;
}
function exec(match, names, types2, matchers) {
  const params = {};
  for (let i3 = 0; i3 < names.length; i3 += 1) {
    const name = names[i3];
    const type = types2[i3];
    const value = match[i3 + 1] || "";
    if (type) {
      const matcher = matchers[type];
      if (!matcher)
        throw new Error(`Missing "${type}" param matcher`);
      if (!matcher(value))
        return;
    }
    params[name] = value;
  }
  return params;
}
var DATA_SUFFIX = "/__data.json";
var default_transform = ({ html }) => html;
async function respond(request, options, state) {
  var _a, _b, _c, _d;
  let url = new URL(request.url);
  const { parameter, allowed } = options.method_override;
  const method_override = (_a = url.searchParams.get(parameter)) == null ? void 0 : _a.toUpperCase();
  if (method_override) {
    if (request.method === "POST") {
      if (allowed.includes(method_override)) {
        request = new Proxy(request, {
          get: (target, property, _receiver) => {
            if (property === "method")
              return method_override;
            return Reflect.get(target, property, target);
          }
        });
      } else {
        const verb = allowed.length === 0 ? "enabled" : "allowed";
        const body = `${parameter}=${method_override} is not ${verb}. See https://kit.svelte.dev/docs/configuration#methodoverride`;
        return new Response(body, {
          status: 400
        });
      }
    } else {
      throw new Error(`${parameter}=${method_override} is only allowed with POST requests`);
    }
  }
  let decoded = decodeURI(url.pathname);
  let route = null;
  let params = {};
  if (options.paths.base && !((_b = state.prerendering) == null ? void 0 : _b.fallback)) {
    if (!decoded.startsWith(options.paths.base)) {
      return new Response(void 0, { status: 404 });
    }
    decoded = decoded.slice(options.paths.base.length) || "/";
  }
  const is_data_request = decoded.endsWith(DATA_SUFFIX);
  if (is_data_request) {
    const data_suffix_length = DATA_SUFFIX.length - (options.trailing_slash === "always" ? 1 : 0);
    decoded = decoded.slice(0, -data_suffix_length) || "/";
    url = new URL(url.origin + url.pathname.slice(0, -data_suffix_length) + url.search);
  }
  if (!((_c = state.prerendering) == null ? void 0 : _c.fallback)) {
    const matchers = await options.manifest._.matchers();
    for (const candidate of options.manifest._.routes) {
      const match = candidate.pattern.exec(decoded);
      if (!match)
        continue;
      const matched = exec(match, candidate.names, candidate.types, matchers);
      if (matched) {
        route = candidate;
        params = decode_params(matched);
        break;
      }
    }
  }
  if (route) {
    if (route.type === "page") {
      const normalized = normalize_path(url.pathname, options.trailing_slash);
      if (normalized !== url.pathname && !((_d = state.prerendering) == null ? void 0 : _d.fallback)) {
        return new Response(void 0, {
          status: 301,
          headers: {
            "x-sveltekit-normalize": "1",
            location: (normalized.startsWith("//") ? url.origin + normalized : normalized) + (url.search === "?" ? "" : url.search)
          }
        });
      }
    } else if (is_data_request) {
      return new Response(void 0, {
        status: 404
      });
    }
  }
  const event = {
    get clientAddress() {
      if (!state.getClientAddress) {
        throw new Error(`${"svelte-adapter-firebase"} does not specify getClientAddress. Please raise an issue`);
      }
      Object.defineProperty(event, "clientAddress", {
        value: state.getClientAddress()
      });
      return event.clientAddress;
    },
    locals: {},
    params,
    platform: state.platform,
    request,
    routeId: route && route.id,
    url
  };
  const removed = (property, replacement, suffix = "") => ({
    get: () => {
      throw new Error(`event.${property} has been replaced by event.${replacement}` + suffix);
    }
  });
  const details = ". See https://github.com/sveltejs/kit/pull/3384 for details";
  const body_getter = {
    get: () => {
      throw new Error("To access the request body use the text/json/arrayBuffer/formData methods, e.g. `body = await request.json()`" + details);
    }
  };
  Object.defineProperties(event, {
    method: removed("method", "request.method", details),
    headers: removed("headers", "request.headers", details),
    origin: removed("origin", "url.origin"),
    path: removed("path", "url.pathname"),
    query: removed("query", "url.searchParams"),
    body: body_getter,
    rawBody: body_getter
  });
  let resolve_opts = {
    ssr: true,
    transformPage: default_transform
  };
  try {
    const response = await options.hooks.handle({
      event,
      resolve: async (event2, opts) => {
        var _a2;
        if (opts) {
          resolve_opts = {
            ssr: opts.ssr !== false,
            transformPage: opts.transformPage || default_transform
          };
        }
        if ((_a2 = state.prerendering) == null ? void 0 : _a2.fallback) {
          return await render_response({
            event: event2,
            options,
            state,
            $session: await options.hooks.getSession(event2),
            page_config: { router: true, hydrate: true },
            stuff: {},
            status: 200,
            error: null,
            branch: [],
            resolve_opts: {
              ...resolve_opts,
              ssr: false
            }
          });
        }
        if (route) {
          let response2;
          if (is_data_request && route.type === "page" && route.shadow) {
            response2 = await render_endpoint(event2, await route.shadow());
            if (request.headers.has("x-sveltekit-load")) {
              if (response2.status >= 300 && response2.status < 400) {
                const location = response2.headers.get("location");
                if (location) {
                  const headers = new Headers(response2.headers);
                  headers.set("x-sveltekit-location", location);
                  response2 = new Response(void 0, {
                    status: 204,
                    headers
                  });
                }
              }
            }
          } else {
            response2 = route.type === "endpoint" ? await render_endpoint(event2, await route.load()) : await render_page(event2, route, options, state, resolve_opts);
          }
          if (response2) {
            if (response2.status === 200 && response2.headers.has("etag")) {
              let if_none_match_value = request.headers.get("if-none-match");
              if (if_none_match_value == null ? void 0 : if_none_match_value.startsWith('W/"')) {
                if_none_match_value = if_none_match_value.substring(2);
              }
              const etag = response2.headers.get("etag");
              if (if_none_match_value === etag) {
                const headers = new Headers({ etag });
                for (const key2 of [
                  "cache-control",
                  "content-location",
                  "date",
                  "expires",
                  "vary"
                ]) {
                  const value = response2.headers.get(key2);
                  if (value)
                    headers.set(key2, value);
                }
                return new Response(void 0, {
                  status: 304,
                  headers
                });
              }
            }
            return response2;
          }
        }
        if (!state.initiator) {
          const $session = await options.hooks.getSession(event2);
          return await respond_with_error({
            event: event2,
            options,
            state,
            $session,
            status: 404,
            error: new Error(`Not found: ${event2.url.pathname}`),
            resolve_opts
          });
        }
        if (state.prerendering) {
          return new Response("not found", { status: 404 });
        }
        return await fetch(request);
      },
      get request() {
        throw new Error("request in handle has been replaced with event" + details);
      }
    });
    if (response && !(response instanceof Response)) {
      throw new Error("handle must return a Response object" + details);
    }
    return response;
  } catch (e3) {
    const error2 = coalesce_to_error(e3);
    options.handle_error(error2, event);
    try {
      const $session = await options.hooks.getSession(event);
      return await respond_with_error({
        event,
        options,
        state,
        $session,
        status: 500,
        error: error2,
        resolve_opts
      });
    } catch (e22) {
      const error3 = coalesce_to_error(e22);
      return new Response(options.dev ? error3.stack : error3.message, {
        status: 500
      });
    }
  }
}
var base = "";
var assets = "";
function set_paths(paths) {
  base = paths.base;
  assets = paths.assets || base;
}
var template = ({ head, body, assets: assets2, nonce }) => '<!DOCTYPE html>\n<html>\n<head>\n  <meta charset="utf-8">\n  <meta name="viewport" content="width=device-width">\n\n  <title>PeaceBox : Tools for your Mind</title>\n\n  ' + head + '\n\n  <script src="https://kit.fontawesome.com/af75aac62e.js" crossorigin="anonymous"><\/script>\n</head>\n<body>\n<!-- SVG Background -->\n' + body + "\n</body>\n</html>\n\n";
var read = null;
set_paths({ "base": "", "assets": "" });
var Server = class {
  constructor(manifest2) {
    this.options = {
      csp: { "mode": "auto", "directives": { "upgrade-insecure-requests": false, "block-all-mixed-content": false } },
      dev: false,
      floc: false,
      get_stack: (error2) => String(error2),
      handle_error: (error2, event) => {
        this.options.hooks.handleError({
          error: error2,
          event,
          get request() {
            throw new Error("request in handleError has been replaced with event. See https://github.com/sveltejs/kit/pull/3384 for details");
          }
        });
        error2.stack = this.options.get_stack(error2);
      },
      hooks: null,
      hydrate: true,
      manifest: manifest2,
      method_override: { "parameter": "_method", "allowed": [] },
      paths: { base, assets },
      prefix: assets + "/_app/immutable/",
      prerender: {
        default: false,
        enabled: true
      },
      read,
      root: Root,
      service_worker: null,
      router: true,
      template,
      template_contains_nonce: false,
      trailing_slash: "never"
    };
  }
  async respond(request, options = {}) {
    if (!(request instanceof Request)) {
      throw new Error("The first argument to server.respond must be a Request object. See https://github.com/sveltejs/kit/pull/3384 for details");
    }
    if (!this.options.hooks) {
      const module2 = await Promise.resolve().then(() => (init_hooks_1c45ba0b(), hooks_1c45ba0b_exports));
      this.options.hooks = {
        getSession: module2.getSession || (() => ({})),
        handle: module2.handle || (({ event, resolve: resolve2 }) => resolve2(event)),
        handleError: module2.handleError || (({ error: error2 }) => console.error(error2.stack)),
        externalFetch: module2.externalFetch || fetch
      };
    }
    return respond(request, this.options, options);
  }
};

// .svelte-kit/output/server/manifest.js
init_shims();
var manifest = {
  appDir: "_app",
  assets: /* @__PURE__ */ new Set(["favicon.png"]),
  mimeTypes: { ".png": "image/png" },
  _: {
    entry: { "file": "start-bb4e133f.js", "js": ["start-bb4e133f.js", "chunks/index-fb8c27ab.js", "chunks/index-5606ccfd.js"], "css": [] },
    nodes: [
      () => Promise.resolve().then(() => (init__(), __exports)),
      () => Promise.resolve().then(() => (init__2(), __exports2)),
      () => Promise.resolve().then(() => (init__3(), __exports3)),
      () => Promise.resolve().then(() => (init__4(), __exports4)),
      () => Promise.resolve().then(() => (init__5(), __exports5)),
      () => Promise.resolve().then(() => (init__6(), __exports6))
    ],
    routes: [
      {
        type: "page",
        id: "",
        pattern: /^\/$/,
        names: [],
        types: [],
        path: "/",
        shadow: null,
        a: [0, 2],
        b: [1]
      },
      {
        type: "page",
        id: "license",
        pattern: /^\/license\/?$/,
        names: [],
        types: [],
        path: "/license",
        shadow: null,
        a: [0, 3],
        b: [1]
      },
      {
        type: "page",
        id: "privacy",
        pattern: /^\/privacy\/?$/,
        names: [],
        types: [],
        path: "/privacy",
        shadow: null,
        a: [0, 4],
        b: [1]
      },
      {
        type: "page",
        id: "terms",
        pattern: /^\/terms\/?$/,
        names: [],
        types: [],
        path: "/terms",
        shadow: null,
        a: [0, 5],
        b: [1]
      }
    ],
    matchers: async () => {
      return {};
    }
  }
};

// .svelte-kit/.svelte-kit/firebase-to-svelte-kit.js
init_shims();
function toSvelteKitRequest(request) {
  const host = `${request.headers["x-forwarded-proto"]}://${request.headers.host}`;
  const { href, pathname, searchParams: searchParameters } = new URL(request.url || "", host);
  return new Request(href, {
    method: request.method,
    headers: toSvelteKitHeaders(request.headers),
    body: request.rawBody ? request.rawBody : null,
    host,
    path: pathname,
    query: searchParameters
  });
}
function toSvelteKitHeaders(headers) {
  const finalHeaders = {};
  for (const [key2, value] of Object.entries(headers)) {
    finalHeaders[key2] = Array.isArray(value) ? value.join(",") : value;
  }
  return finalHeaders;
}

// .svelte-kit/.svelte-kit/entry.js
var server = new Server(manifest);
async function svelteKit(request, response) {
  const rendered = await server.respond(toSvelteKitRequest(request));
  const body = await rendered.text();
  return rendered ? response.writeHead(rendered.status, rendered.headers).end(body) : response.writeHead(404, "Not Found").end();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
/*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
